/*
 * @Descripttion:
 * @version:
 * @FilePath: /vue-element-admin/src/views/dashboard/js/client.min.js
 */
(() => {
  var m = (s, e) => () => (e || s((e = { exports: {}}).exports, e), e.exports); var Xr = m((qu, si) => { var Uo = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/; var zo = ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor']; si.exports = function(e) { var t = e; var r = e.indexOf('['); var i = e.indexOf(']'); r != -1 && i != -1 && (e = e.substring(0, r) + e.substring(r, i).replace(/:/g, ';') + e.substring(i, e.length)); for (var n = Uo.exec(e || ''), c = {}, a = 14; a--;)c[zo[a]] = n[a] || ''; return r != -1 && i != -1 && (c.source = t, c.host = c.host.substring(1, c.host.length - 1).replace(/;/g, ':'), c.authority = c.authority.replace('[', '').replace(']', '').replace(/;/g, ':'), c.ipv6uri = !0), c.pathNames = Vo(c, c.path), c.queryKey = $o(c, c.query), c }; function Vo(s, e) { var t = /\/{2,9}/g; var r = e.replace(t, '/').split('/'); return (e.substr(0, 1) == '/' || e.length === 0) && r.splice(0, 1), e.substr(e.length - 1, 1) == '/' && r.splice(r.length - 1, 1), r } function $o(s, e) { var t = {}; return e.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function(r, i, n) { i && (t[i] = n) }), t } }); var ni = m((Fu, ii) => { var it = 1e3; var nt = it * 60; var at = nt * 60; var We = at * 24; var Ho = We * 7; var Ko = We * 365.25; ii.exports = function(s, e) { e = e || {}; var t = typeof s; if (t === 'string' && s.length > 0) return Go(s); if (t === 'number' && isFinite(s)) return e.long ? Qo(s) : Wo(s); throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(s)) }; function Go(s) { if (s = String(s), !(s.length > 100)) { var e = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(s); if (e) { var t = parseFloat(e[1]); var r = (e[2] || 'ms').toLowerCase(); switch (r) { case 'years':case 'year':case 'yrs':case 'yr':case 'y':return t * Ko; case 'weeks':case 'week':case 'w':return t * Ho; case 'days':case 'day':case 'd':return t * We; case 'hours':case 'hour':case 'hrs':case 'hr':case 'h':return t * at; case 'minutes':case 'minute':case 'mins':case 'min':case 'm':return t * nt; case 'seconds':case 'second':case 'secs':case 'sec':case 's':return t * it; case 'milliseconds':case 'millisecond':case 'msecs':case 'msec':case 'ms':return t; default:return } } } } function Wo(s) { var e = Math.abs(s); return e >= We ? Math.round(s / We) + 'd' : e >= at ? Math.round(s / at) + 'h' : e >= nt ? Math.round(s / nt) + 'm' : e >= it ? Math.round(s / it) + 's' : s + 'ms' } function Qo(s) { var e = Math.abs(s); return e >= We ? tr(s, e, We, 'day') : e >= at ? tr(s, e, at, 'hour') : e >= nt ? tr(s, e, nt, 'minute') : e >= it ? tr(s, e, it, 'second') : s + ' ms' } function tr(s, e, t, r) { var i = e >= t * 1.5; return Math.round(s / t) + ' ' + r + (i ? 's' : '') } }); var oi = m((Nu, ai) => { function Jo(s) { t.debug = t, t.default = t, t.coerce = o, t.disable = n, t.enable = i, t.enabled = c, t.humanize = ni(), t.destroy = d, Object.keys(s).forEach(l => { t[l] = s[l] }), t.names = [], t.skips = [], t.formatters = {}; function e(l) { let p = 0; for (let u = 0; u < l.length; u++)p = (p << 5) - p + l.charCodeAt(u), p |= 0; return t.colors[Math.abs(p) % t.colors.length] }t.selectColor = e; function t(l) { let p; let u = null; function h(...f) { if (!h.enabled) return; const _ = h; const g = Number(new Date()); const k = g - (p || g); _.diff = k, _.prev = p, _.curr = g, p = g, f[0] = t.coerce(f[0]), typeof f[0] !== 'string' && f.unshift('%O'); let I = 0; f[0] = f[0].replace(/%([a-zA-Z%])/g, (Oe, Ne) => { if (Oe === '%%') return '%'; I++; const Ue = t.formatters[Ne]; if (typeof Ue === 'function') { const rt = f[I]; Oe = Ue.call(_, rt), f.splice(I, 1), I-- } return Oe }), t.formatArgs.call(_, f), (_.log || t.log).apply(_, f) } return h.namespace = l, h.useColors = t.useColors(), h.color = t.selectColor(l), h.extend = r, h.destroy = t.destroy, Object.defineProperty(h, 'enabled', { enumerable: !0, configurable: !1, get: () => u === null ? t.enabled(l) : u, set: f => { u = f } }), typeof t.init === 'function' && t.init(h), h } function r(l, p) { const u = t(this.namespace + (typeof p === 'undefined' ? ':' : p) + l); return u.log = this.log, u } function i(l) { t.save(l), t.names = [], t.skips = []; let p; const u = (typeof l === 'string' ? l : '').split(/[\s,]+/); const h = u.length; for (p = 0; p < h; p++)!u[p] || (l = u[p].replace(/\*/g, '.*?'), l[0] === '-' ? t.skips.push(new RegExp('^' + l.substr(1) + '$')) : t.names.push(new RegExp('^' + l + '$'))) } function n() { const l = [...t.names.map(a), ...t.skips.map(a).map(p => '-' + p)].join(','); return t.enable(''), l } function c(l) { if (l[l.length - 1] === '*') return !0; let p, u; for (p = 0, u = t.skips.length; p < u; p++) if (t.skips[p].test(l)) return !1; for (p = 0, u = t.names.length; p < u; p++) if (t.names[p].test(l)) return !0; return !1 } function a(l) { return l.toString().substring(2, l.toString().length - 2).replace(/\.\*\?$/, '*') } function o(l) { return l instanceof Error ? l.stack || l.message : l } function d() { console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.') } return t.enable(t.load()), t }ai.exports = Jo }); var J = m((Q, rr) => { Q.formatArgs = Xo; Q.save = Zo; Q.load = ec; Q.useColors = Yo; Q.storage = tc(); Q.destroy = (() => { let s = !1; return () => { s || (s = !0, console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.')) } })(); Q.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33']; function Yo() { return typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs) ? !0 : typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? !1 : typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/) } function Xo(s) { if (s[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + s[0] + (this.useColors ? '%c ' : ' ') + '+' + rr.exports.humanize(this.diff), !this.useColors) return; const e = 'color: ' + this.color; s.splice(1, 0, e, 'color: inherit'); let t = 0; let r = 0; s[0].replace(/%[a-zA-Z%]/g, i => { i !== '%%' && (t++, i === '%c' && (r = t)) }), s.splice(r, 0, e) }Q.log = console.debug || console.log || (() => {}); function Zo(s) { try { s ? Q.storage.setItem('debug', s) : Q.storage.removeItem('debug') } catch (e) {} } function ec() { let s; try { s = Q.storage.getItem('debug') } catch (e) {} return !s && typeof process !== 'undefined' && 'env' in process && (s = process.env.DEBUG), s } function tc() { try { return localStorage } catch (s) {} }rr.exports = oi()(Q); var { formatters: rc } = rr.exports; rc.j = function(s) { try { return JSON.stringify(s) } catch (e) { return '[UnexpectedJSONParseError]: ' + e.message } } }); var di = m(sr => { 'use strict'; Object.defineProperty(sr, '__esModule', { value: !0 }); sr.url = void 0; var sc = Xr(); var ci = J()('socket.io-client:url'); function ic(s, e = '', t) { let r = s; t = t || typeof location !== 'undefined' && location, s == null && (s = t.protocol + '//' + t.host), typeof s === 'string' && (s.charAt(0) === '/' && (s.charAt(1) === '/' ? s = t.protocol + s : s = t.host + s), /^(https?|wss?):\/\//.test(s) || (ci('protocol-less url %s', s), typeof t !== 'undefined' ? s = t.protocol + '//' + s : s = 'https://' + s), ci('parse %s', s), r = sc(s)), r.port || (/^(http|ws)$/.test(r.protocol) ? r.port = '80' : /^(http|ws)s$/.test(r.protocol) && (r.port = '443')), r.path = r.path || '/'; const n = r.host.indexOf(':') !== -1 ? '[' + r.host + ']' : r.host; return r.id = r.protocol + '://' + n + ':' + r.port + e, r.href = r.protocol + '://' + n + (t && t.port === r.port ? '' : ':' + r.port), r }sr.url = ic }); var li = m((zu, Zr) => { try { Zr.exports = typeof XMLHttpRequest !== 'undefined' && 'withCredentials' in new XMLHttpRequest() } catch (s) { Zr.exports = !1 } }); var Lt = m((Vu, pi) => { pi.exports = (() => typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : Function('return this')())() }); var es = m(($u, ui) => { var nc = li(); var ac = Lt(); ui.exports = function(s) { const e = s.xdomain; const t = s.xscheme; const r = s.enablesXDR; try { if (typeof XMLHttpRequest !== 'undefined' && (!e || nc)) return new XMLHttpRequest() } catch (i) {} try { if (typeof XDomainRequest !== 'undefined' && !t && r) return new XDomainRequest() } catch (i) {} if (!e) try { return new ac[['Active'].concat('Object').join('X')]('Microsoft.XMLHTTP') } catch (i) {} } }); var ts = m((Hu, fi) => { var le = Object.create(null); le.open = '0'; le.close = '1'; le.ping = '2'; le.pong = '3'; le.message = '4'; le.upgrade = '5'; le.noop = '6'; var hi = Object.create(null); Object.keys(le).forEach(s => { hi[le[s]] = s }); var oc = { type: 'error', data: 'parser error' }; fi.exports = { PACKET_TYPES: le, PACKET_TYPES_REVERSE: hi, ERROR_PACKET: oc } }); var _i = m((Ku, gi) => { var { PACKET_TYPES: cc } = ts(); var dc = typeof Blob === 'function' || typeof Blob !== 'undefined' && Object.prototype.toString.call(Blob) === '[object BlobConstructor]'; var lc = typeof ArrayBuffer === 'function'; var pc = s => typeof ArrayBuffer.isView === 'function' ? ArrayBuffer.isView(s) : s && s.buffer instanceof ArrayBuffer; var uc = ({ type: s, data: e }, t, r) => dc && e instanceof Blob ? t ? r(e) : mi(e, r) : lc && (e instanceof ArrayBuffer || pc(e)) ? t ? r(e instanceof ArrayBuffer ? e : e.buffer) : mi(new Blob([e]), r) : r(cc[s] + (e || '')); var mi = (s, e) => { const t = new FileReader(); return t.onload = function() { const r = t.result.split(',')[1]; e('b' + r) }, t.readAsDataURL(s) }; gi.exports = uc }); var vi = m(rs => { (function(s) { 'use strict'; rs.encode = function(e) { var t = new Uint8Array(e); var r; var i = t.length; var n = ''; for (r = 0; r < i; r += 3)n += s[t[r] >> 2], n += s[(t[r] & 3) << 4 | t[r + 1] >> 4], n += s[(t[r + 1] & 15) << 2 | t[r + 2] >> 6], n += s[t[r + 2] & 63]; return i % 3 == 2 ? n = n.substring(0, n.length - 1) + '=' : i % 3 == 1 && (n = n.substring(0, n.length - 2) + '=='), n }, rs.decode = function(e) { var t = e.length * 0.75; var r = e.length; var i; var n = 0; var c; var a; var o; var d; e[e.length - 1] === '=' && (t--, e[e.length - 2] === '=' && t--); var l = new ArrayBuffer(t); var p = new Uint8Array(l); for (i = 0; i < r; i += 4)c = s.indexOf(e[i]), a = s.indexOf(e[i + 1]), o = s.indexOf(e[i + 2]), d = s.indexOf(e[i + 3]), p[n++] = c << 2 | a >> 4, p[n++] = (a & 15) << 4 | o >> 2, p[n++] = (o & 3) << 6 | d & 63; return l } })('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/') }); var wi = m((Wu, bi) => { var { PACKET_TYPES_REVERSE: ss, ERROR_PACKET: hc } = ts(); var fc = typeof ArrayBuffer === 'function'; var is; fc && (is = vi()); var mc = (s, e) => { if (typeof s !== 'string') return { type: 'message', data: yi(s, e) }; const t = s.charAt(0); return t === 'b' ? { type: 'message', data: gc(s.substring(1), e) } : ss[t] ? s.length > 1 ? { type: ss[t], data: s.substring(1) } : { type: ss[t] } : hc }; var gc = (s, e) => { if (is) { const t = is.decode(s); return yi(t, e) } else return { base64: !0, data: s } }; var yi = (s, e) => { switch (e) { case 'blob':return s instanceof ArrayBuffer ? new Blob([s]) : s; case 'arraybuffer':default:return s } }; bi.exports = mc }); var ot = m((Qu, Ti) => { var Si = _i(); var Ri = wi(); var Ci = String.fromCharCode(30); var _c = (s, e) => { const t = s.length; const r = new Array(t); let i = 0; s.forEach((n, c) => { Si(n, !1, a => { r[c] = a, ++i === t && e(r.join(Ci)) }) }) }; var vc = (s, e) => { const t = s.split(Ci); const r = []; for (let i = 0; i < t.length; i++) { const n = Ri(t[i], e); if (r.push(n), n.type === 'error') break } return r }; Ti.exports = { protocol: 4, encodePacket: Si, encodePayload: _c, decodePacket: Ri, decodePayload: vc } }); var ct = m((Ju, ns) => { typeof ns !== 'undefined' && (ns.exports = Y); function Y(s) { if (s) return yc(s) } function yc(s) { for (var e in Y.prototype)s[e] = Y.prototype[e]; return s }Y.prototype.on = Y.prototype.addEventListener = function(s, e) { return this._callbacks = this._callbacks || {}, (this._callbacks['$' + s] = this._callbacks['$' + s] || []).push(e), this }; Y.prototype.once = function(s, e) { function t() { this.off(s, t), e.apply(this, arguments) } return t.fn = e, this.on(s, t), this }; Y.prototype.off = Y.prototype.removeListener = Y.prototype.removeAllListeners = Y.prototype.removeEventListener = function(s, e) { if (this._callbacks = this._callbacks || {}, arguments.length == 0) return this._callbacks = {}, this; var t = this._callbacks['$' + s]; if (!t) return this; if (arguments.length == 1) return delete this._callbacks['$' + s], this; for (var r, i = 0; i < t.length; i++) if (r = t[i], r === e || r.fn === e) { t.splice(i, 1); break } return t.length === 0 && delete this._callbacks['$' + s], this }; Y.prototype.emit = function(s) { this._callbacks = this._callbacks || {}; for (var e = new Array(arguments.length - 1), t = this._callbacks['$' + s], r = 1; r < arguments.length; r++)e[r - 1] = arguments[r]; if (t) { t = t.slice(0); for (var r = 0, i = t.length; r < i; ++r)t[r].apply(this, e) } return this }; Y.prototype.listeners = function(s) { return this._callbacks = this._callbacks || {}, this._callbacks['$' + s] || [] }; Y.prototype.hasListeners = function(s) { return !!this.listeners(s).length } }); var ir = m((Yu, Ei) => { var bc = ot(); var wc = ct(); var Sc = J()('engine.io-client:transport'); var Pi = class extends wc {constructor(e) { super(); this.opts = e, this.query = e.query, this.readyState = '', this.socket = e.socket }onError(e, t) { const r = new Error(e); return r.type = 'TransportError', r.description = t, this.emit('error', r), this }open() { return (this.readyState === 'closed' || this.readyState === '') && (this.readyState = 'opening', this.doOpen()), this }close() { return (this.readyState === 'opening' || this.readyState === 'open') && (this.doClose(), this.onClose()), this }send(e) { this.readyState === 'open' ? this.write(e) : Sc('transport is not open, discarding packets') }onOpen() { this.readyState = 'open', this.writable = !0, this.emit('open') }onData(e) { const t = bc.decodePacket(e, this.socket.binaryType); this.onPacket(t) }onPacket(e) { this.emit('packet', e) }onClose() { this.readyState = 'closed', this.emit('close') }}; Ei.exports = Pi }); var nr = m(as => { as.encode = function(s) { var e = ''; for (var t in s)s.hasOwnProperty(t) && (e.length && (e += '&'), e += encodeURIComponent(t) + '=' + encodeURIComponent(s[t])); return e }; as.decode = function(s) { for (var e = {}, t = s.split('&'), r = 0, i = t.length; r < i; r++) { var n = t[r].split('='); e[decodeURIComponent(n[0])] = decodeURIComponent(n[1]) } return e } }); var ds = m((Zu, Oi) => { 'use strict'; var Di = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split(''); var ar = 64; var Mi = {}; var ki = 0; var ze = 0; var xi; function os(s) { var e = ''; do e = Di[s % ar] + e, s = Math.floor(s / ar); while (s > 0);return e } function Rc(s) { var e = 0; for (ze = 0; ze < s.length; ze++)e = e * ar + Mi[s.charAt(ze)]; return e } function cs() { var s = os(+new Date()); return s !== xi ? (ki = 0, xi = s) : s + '.' + os(ki++) } for (;ze < ar; ze++)Mi[Di[ze]] = ze; cs.encode = os; cs.decode = Rc; Oi.exports = cs }); var ls = m((eh, Ai) => { var Cc = ir(); var Tc = nr(); var Li = ot(); var Pc = ds(); var ne = J()('engine.io-client:polling'); var Ii = class extends Cc {get name() { return 'polling' }doOpen() { this.poll() }pause(e) { this.readyState = 'pausing'; const t = () => { ne('paused'), this.readyState = 'paused', e() }; if (this.polling || !this.writable) { let r = 0; this.polling && (ne('we are currently polling - waiting to pause'), r++, this.once('pollComplete', function() { ne('pre-pause polling complete'), --r || t() })), this.writable || (ne('we are currently writing - waiting to pause'), r++, this.once('drain', function() { ne('pre-pause writing complete'), --r || t() })) } else t() }poll() { ne('polling'), this.polling = !0, this.doPoll(), this.emit('poll') }onData(e) { ne('polling got data %s', e); const t = r => { if (this.readyState === 'opening' && r.type === 'open' && this.onOpen(), r.type === 'close') return this.onClose(), !1; this.onPacket(r) }; Li.decodePayload(e, this.socket.binaryType).forEach(t), this.readyState !== 'closed' && (this.polling = !1, this.emit('pollComplete'), this.readyState === 'open' ? this.poll() : ne('ignoring poll - transport state "%s"', this.readyState)) }doClose() { const e = () => { ne('writing close packet'), this.write([{ type: 'close' }]) }; this.readyState === 'open' ? (ne('transport open - closing'), e()) : (ne('transport not open - deferring close'), this.once('open', e)) }write(e) { this.writable = !1, Li.encodePayload(e, t => { this.doWrite(t, () => { this.writable = !0, this.emit('drain') }) }) }uri() { let e = this.query || {}; const t = this.opts.secure ? 'https' : 'http'; let r = ''; this.opts.timestampRequests !== !1 && (e[this.opts.timestampParam] = Pc()), !this.supportsBinary && !e.sid && (e.b64 = 1), e = Tc.encode(e), this.opts.port && (t === 'https' && Number(this.opts.port) !== 443 || t === 'http' && Number(this.opts.port) !== 80) && (r = ':' + this.opts.port), e.length && (e = '?' + e); const i = this.opts.hostname.indexOf(':') !== -1; return t + '://' + (i ? '[' + this.opts.hostname + ']' : this.opts.hostname) + r + this.opts.path + e }}; Ai.exports = Ii }); var ps = m((th, ji) => { ji.exports.pick = (s, ...e) => e.reduce((t, r) => (s.hasOwnProperty(r) && (t[r] = s[r]), t), {}) }); var Ui = m((rh, hs) => { var Bi = es(); var Ec = ls(); var Dc = ct(); var { pick: Mc } = ps(); var kc = Lt(); var us = J()('engine.io-client:polling-xhr'); function qi() {} var xc = (function() { return new Bi({ xdomain: !1 }).responseType != null }()); var Fi = class extends Ec {constructor(e) { super(e); if (typeof location !== 'undefined') { const r = location.protocol === 'https:'; let i = location.port; i || (i = r ? 443 : 80), this.xd = typeof location !== 'undefined' && e.hostname !== location.hostname || i !== e.port, this.xs = e.secure !== r } const t = e && e.forceBase64; this.supportsBinary = xc && !t }request(e = {}) { return Object.assign(e, { xd: this.xd, xs: this.xs }, this.opts), new X(this.uri(), e) }doWrite(e, t) { const r = this.request({ method: 'POST', data: e }); r.on('success', t), r.on('error', i => { this.onError('xhr post error', i) }) }doPoll() { us('xhr poll'); const e = this.request(); e.on('data', this.onData.bind(this)), e.on('error', t => { this.onError('xhr poll error', t) }), this.pollXhr = e }}; var X = class extends Dc {constructor(e, t) { super(); this.opts = t, this.method = t.method || 'GET', this.uri = e, this.async = t.async !== !1, this.data = t.data !== void 0 ? t.data : null, this.create() }create() { const e = Mc(this.opts, 'agent', 'enablesXDR', 'pfx', 'key', 'passphrase', 'cert', 'ca', 'ciphers', 'rejectUnauthorized', 'autoUnref'); e.xdomain = !!this.opts.xd, e.xscheme = !!this.opts.xs; const t = this.xhr = new Bi(e); try { us('xhr open %s: %s', this.method, this.uri), t.open(this.method, this.uri, this.async); try { if (this.opts.extraHeaders) { t.setDisableHeaderCheck && t.setDisableHeaderCheck(!0); for (const r in this.opts.extraHeaders) this.opts.extraHeaders.hasOwnProperty(r) && t.setRequestHeader(r, this.opts.extraHeaders[r]) } } catch (r) {} if (this.method === 'POST') try { t.setRequestHeader('Content-type', 'text/plain;charset=UTF-8') } catch (r) {} try { t.setRequestHeader('Accept', '*/*') } catch (r) {}'withCredentials' in t && (t.withCredentials = this.opts.withCredentials), this.opts.requestTimeout && (t.timeout = this.opts.requestTimeout), this.hasXDR() ? (t.onload = () => { this.onLoad() }, t.onerror = () => { this.onError(t.responseText) }) : t.onreadystatechange = () => { t.readyState === 4 && (t.status === 200 || t.status === 1223 ? this.onLoad() : setTimeout(() => { this.onError(typeof t.status === 'number' ? t.status : 0) }, 0)) }, us('xhr data %s', this.data), t.send(this.data) } catch (r) { setTimeout(() => { this.onError(r) }, 0); return } typeof document !== 'undefined' && (this.index = X.requestsCount++, X.requests[this.index] = this) }onSuccess() { this.emit('success'), this.cleanup() }onData(e) { this.emit('data', e), this.onSuccess() }onError(e) { this.emit('error', e), this.cleanup(!0) }cleanup(e) { if (!(typeof this.xhr === 'undefined' || this.xhr === null)) { if (this.hasXDR() ? this.xhr.onload = this.xhr.onerror = qi : this.xhr.onreadystatechange = qi, e) try { this.xhr.abort() } catch (t) {} typeof document !== 'undefined' && delete X.requests[this.index], this.xhr = null } }onLoad() { const e = this.xhr.responseText; e !== null && this.onData(e) }hasXDR() { return typeof XDomainRequest !== 'undefined' && !this.xs && this.enablesXDR }abort() { this.cleanup() }}; X.requestsCount = 0; X.requests = {}; if (typeof document !== 'undefined') { if (typeof attachEvent === 'function')attachEvent('onunload', Ni); else if (typeof addEventListener === 'function') { const s = 'onpagehide' in kc ? 'pagehide' : 'unload'; addEventListener(s, Ni, !1) } } function Ni() { for (const s in X.requests)X.requests.hasOwnProperty(s) && X.requests[s].abort() }hs.exports = Fi; hs.exports.Request = X }); var Hi = m((sh, $i) => {
    var Oc = ls(); var zi = Lt(); var Lc = /\n/g; var Ic = /\\n/g; var or; var Vi = class extends Oc {
      constructor(e) { super(e); this.query = this.query || {}, or || (or = zi.___eio = zi.___eio || []), this.index = or.length, or.push(this.onData.bind(this)), this.query.j = this.index } get supportsBinary() { return !1 }doClose() { this.script && (this.script.onerror = () => {}, this.script.parentNode.removeChild(this.script), this.script = null), this.form && (this.form.parentNode.removeChild(this.form), this.form = null, this.iframe = null), super.doClose() }doPoll() { const e = document.createElement('script'); this.script && (this.script.parentNode.removeChild(this.script), this.script = null), e.async = !0, e.src = this.uri(), e.onerror = i => { this.onError('jsonp poll error', i) }; const t = document.getElementsByTagName('script')[0]; t ? t.parentNode.insertBefore(e, t) : (document.head || document.body).appendChild(e), this.script = e, typeof navigator !== 'undefined' && /gecko/i.test(navigator.userAgent) && setTimeout(function() { const i = document.createElement('iframe'); document.body.appendChild(i), document.body.removeChild(i) }, 100) }doWrite(e, t) {
        let r; if (!this.form) { const c = document.createElement('form'); const a = document.createElement('textarea'); const o = this.iframeId = 'eio_iframe_' + this.index; c.className = 'socketio', c.style.position = 'absolute', c.style.top = '-1000px', c.style.left = '-1000px', c.target = o, c.method = 'POST', c.setAttribute('accept-charset', 'utf-8'), a.name = 'd', c.appendChild(a), document.body.appendChild(c), this.form = c, this.area = a } this.form.action = this.uri(); function i() { n(), t() } const n = () => { if (this.iframe) try { this.form.removeChild(this.iframe) } catch (c) { this.onError('jsonp polling iframe removal error', c) } try { const c = '<iframe src="javascript:0" name="' + this.iframeId + '">'; r = document.createElement(c) } catch (c) { r = document.createElement('iframe'), r.name = this.iframeId, r.src = 'javascript:0' }r.id = this.iframeId, this.form.appendChild(r), this.iframe = r }; n(), e = e.replace(Ic, `\\
`), this.area.value = e.replace(Lc, '\\n'); try { this.form.submit() } catch (c) {} this.iframe.attachEvent ? this.iframe.onreadystatechange = () => { this.iframe.readyState === 'complete' && i() } : this.iframe.onload = i
      }
    }; $i.exports = Vi
  }); var Wi = m((ih, Gi) => { var Ki = Lt(); Gi.exports = { WebSocket: Ki.WebSocket || Ki.MozWebSocket, usingBrowserWebSocket: !0, defaultBinaryType: 'arraybuffer' } }); var Xi = m((nh, Yi) => { var Qi = ir(); var Ac = ot(); var jc = nr(); var Bc = ds(); var { pick: qc } = ps(); var { WebSocket: It, usingBrowserWebSocket: fs, defaultBinaryType: Fc } = Wi(); var Nc = J()('engine.io-client:websocket'); var Ji = typeof navigator !== 'undefined' && typeof navigator.product === 'string' && navigator.product.toLowerCase() === 'reactnative'; var cr = class extends Qi {constructor(e) { super(e); this.supportsBinary = !e.forceBase64 } get name() { return 'websocket' }doOpen() { if (!this.check()) return; const e = this.uri(); const t = this.opts.protocols; const r = Ji ? {} : qc(this.opts, 'agent', 'perMessageDeflate', 'pfx', 'key', 'passphrase', 'cert', 'ca', 'ciphers', 'rejectUnauthorized', 'localAddress', 'protocolVersion', 'origin', 'maxPayload', 'family', 'checkServerIdentity'); this.opts.extraHeaders && (r.headers = this.opts.extraHeaders); try { this.ws = fs && !Ji ? t ? new It(e, t) : new It(e) : new It(e, t, r) } catch (i) { return this.emit('error', i) } this.ws.binaryType = this.socket.binaryType || Fc, this.addEventListeners() }addEventListeners() { this.ws.onopen = () => { this.opts.autoUnref && this.ws._socket.unref(), this.onOpen() }, this.ws.onclose = this.onClose.bind(this), this.ws.onmessage = e => this.onData(e.data), this.ws.onerror = e => this.onError('websocket error', e) }write(e) { this.writable = !1; for (let t = 0; t < e.length; t++) { const r = e[t]; const i = t === e.length - 1; Ac.encodePacket(r, this.supportsBinary, n => { const c = {}; fs || (r.options && (c.compress = r.options.compress), this.opts.perMessageDeflate && (typeof n === 'string' ? Buffer.byteLength(n) : n.length) < this.opts.perMessageDeflate.threshold && (c.compress = !1)); try { fs ? this.ws.send(n) : this.ws.send(n, c) } catch (a) { Nc('websocket closed before onclose event') }i && setTimeout(() => { this.writable = !0, this.emit('drain') }, 0) }) } }onClose() { Qi.prototype.onClose.call(this) }doClose() { typeof this.ws !== 'undefined' && (this.ws.close(), this.ws = null) }uri() { let e = this.query || {}; const t = this.opts.secure ? 'wss' : 'ws'; let r = ''; this.opts.port && (t === 'wss' && Number(this.opts.port) !== 443 || t === 'ws' && Number(this.opts.port) !== 80) && (r = ':' + this.opts.port), this.opts.timestampRequests && (e[this.opts.timestampParam] = Bc()), this.supportsBinary || (e.b64 = 1), e = jc.encode(e), e.length && (e = '?' + e); const i = this.opts.hostname.indexOf(':') !== -1; return t + '://' + (i ? '[' + this.opts.hostname + ']' : this.opts.hostname) + r + this.opts.path + e }check() { return !!It && !('__initialize' in It && this.name === cr.prototype.name) }}; Yi.exports = cr }); var gs = m(ms => { var Uc = es(); var zc = Ui(); var Vc = Hi(); var $c = Xi(); ms.polling = Hc; ms.websocket = $c; function Hc(s) { let e; let t = !1; let r = !1; const i = s.jsonp !== !1; if (typeof location !== 'undefined') { const n = location.protocol === 'https:'; let c = location.port; c || (c = n ? 443 : 80), t = s.hostname !== location.hostname || c !== s.port, r = s.secure !== n } if (s.xdomain = t, s.xscheme = r, e = new Uc(s), 'open' in e && !s.forceJSONP) return new zc(s); if (!i) throw new Error('JSONP disabled'); return new Vc(s) } }); var rn = m((oh, tn) => { var Kc = gs(); var Gc = ct(); var O = J()('engine.io-client:socket'); var Zi = ot(); var en = Xr(); var Wc = nr(); var pe = class extends Gc {constructor(e, t = {}) { super(); e && typeof e === 'object' && (t = e, e = null), e ? (e = en(e), t.hostname = e.host, t.secure = e.protocol === 'https' || e.protocol === 'wss', t.port = e.port, e.query && (t.query = e.query)) : t.host && (t.hostname = en(t.host).host), this.secure = t.secure != null ? t.secure : typeof location !== 'undefined' && location.protocol === 'https:', t.hostname && !t.port && (t.port = this.secure ? '443' : '80'), this.hostname = t.hostname || (typeof location !== 'undefined' ? location.hostname : 'localhost'), this.port = t.port || (typeof location !== 'undefined' && location.port ? location.port : this.secure ? 443 : 80), this.transports = t.transports || ['polling', 'websocket'], this.readyState = '', this.writeBuffer = [], this.prevBufferLen = 0, this.opts = Object.assign({ path: '/engine.io', agent: !1, withCredentials: !1, upgrade: !0, jsonp: !0, timestampParam: 't', rememberUpgrade: !1, rejectUnauthorized: !0, perMessageDeflate: { threshold: 1024 }, transportOptions: {}, closeOnBeforeunload: !0 }, t), this.opts.path = this.opts.path.replace(/\/$/, '') + '/', typeof this.opts.query === 'string' && (this.opts.query = Wc.decode(this.opts.query)), this.id = null, this.upgrades = null, this.pingInterval = null, this.pingTimeout = null, this.pingTimeoutTimer = null, typeof addEventListener === 'function' && (this.opts.closeOnBeforeunload && addEventListener('beforeunload', () => { this.transport && (this.transport.removeAllListeners(), this.transport.close()) }, !1), this.hostname !== 'localhost' && (this.offlineEventListener = () => { this.onClose('transport close') }, addEventListener('offline', this.offlineEventListener, !1))), this.open() }createTransport(e) { O('creating transport "%s"', e); const t = Qc(this.opts.query); t.EIO = Zi.protocol, t.transport = e, this.id && (t.sid = this.id); const r = Object.assign({}, this.opts.transportOptions[e], this.opts, { query: t, socket: this, hostname: this.hostname, secure: this.secure, port: this.port }); return O('options: %j', r), new Kc[e](r) }open() { let e; if (this.opts.rememberUpgrade && pe.priorWebsocketSuccess && this.transports.indexOf('websocket') !== -1)e = 'websocket'; else if (this.transports.length === 0) { setTimeout(() => { this.emit('error', 'No transports available') }, 0); return } else e = this.transports[0]; this.readyState = 'opening'; try { e = this.createTransport(e) } catch (t) { O('error while creating transport: %s', t), this.transports.shift(), this.open(); return }e.open(), this.setTransport(e) }setTransport(e) { O('setting transport %s', e.name), this.transport && (O('clearing existing transport %s', this.transport.name), this.transport.removeAllListeners()), this.transport = e, e.on('drain', this.onDrain.bind(this)).on('packet', this.onPacket.bind(this)).on('error', this.onError.bind(this)).on('close', () => { this.onClose('transport close') }) }probe(e) { O('probing transport "%s"', e); let t = this.createTransport(e, { probe: 1 }); let r = !1; pe.priorWebsocketSuccess = !1; const i = () => { r || (O('probe transport "%s" opened', e), t.send([{ type: 'ping', data: 'probe' }]), t.once('packet', p => { if (!r) if (p.type === 'pong' && p.data === 'probe') { if (O('probe transport "%s" pong', e), this.upgrading = !0, this.emit('upgrading', t), !t) return; pe.priorWebsocketSuccess = t.name === 'websocket', O('pausing current transport "%s"', this.transport.name), this.transport.pause(() => { r || this.readyState !== 'closed' && (O('changing transport and sending upgrade packet'), l(), this.setTransport(t), t.send([{ type: 'upgrade' }]), this.emit('upgrade', t), t = null, this.upgrading = !1, this.flush()) }) } else { O('probe transport "%s" failed', e); const u = new Error('probe error'); u.transport = t.name, this.emit('upgradeError', u) } })) }; function n() { r || (r = !0, l(), t.close(), t = null) } const c = p => { const u = new Error('probe error: ' + p); u.transport = t.name, n(), O('probe transport "%s" failed because of error: %s', e, p), this.emit('upgradeError', u) }; function a() { c('transport closed') } function o() { c('socket closed') } function d(p) { t && p.name !== t.name && (O('"%s" works - aborting "%s"', p.name, t.name), n()) } const l = () => { t.removeListener('open', i), t.removeListener('error', c), t.removeListener('close', a), this.removeListener('close', o), this.removeListener('upgrading', d) }; t.once('open', i), t.once('error', c), t.once('close', a), this.once('close', o), this.once('upgrading', d), t.open() }onOpen() { if (O('socket open'), this.readyState = 'open', pe.priorWebsocketSuccess = this.transport.name === 'websocket', this.emit('open'), this.flush(), this.readyState === 'open' && this.opts.upgrade && this.transport.pause) { O('starting upgrade probes'); let e = 0; const t = this.upgrades.length; for (;e < t; e++) this.probe(this.upgrades[e]) } }onPacket(e) { if (this.readyState === 'opening' || this.readyState === 'open' || this.readyState === 'closing') switch (O('socket receive: type "%s", data "%s"', e.type, e.data), this.emit('packet', e), this.emit('heartbeat'), e.type) { case 'open':this.onHandshake(JSON.parse(e.data)); break; case 'ping':this.resetPingTimeout(), this.sendPacket('pong'), this.emit('pong'); break; case 'error':const t = new Error('server error'); t.code = e.data, this.onError(t); break; case 'message':this.emit('data', e.data), this.emit('message', e.data); break } else O('packet received with socket readyState "%s"', this.readyState) }onHandshake(e) { this.emit('handshake', e), this.id = e.sid, this.transport.query.sid = e.sid, this.upgrades = this.filterUpgrades(e.upgrades), this.pingInterval = e.pingInterval, this.pingTimeout = e.pingTimeout, this.onOpen(), this.readyState !== 'closed' && this.resetPingTimeout() }resetPingTimeout() { clearTimeout(this.pingTimeoutTimer), this.pingTimeoutTimer = setTimeout(() => { this.onClose('ping timeout') }, this.pingInterval + this.pingTimeout), this.opts.autoUnref && this.pingTimeoutTimer.unref() }onDrain() { this.writeBuffer.splice(0, this.prevBufferLen), this.prevBufferLen = 0, this.writeBuffer.length === 0 ? this.emit('drain') : this.flush() }flush() { this.readyState !== 'closed' && this.transport.writable && !this.upgrading && this.writeBuffer.length && (O('flushing %d packets in socket', this.writeBuffer.length), this.transport.send(this.writeBuffer), this.prevBufferLen = this.writeBuffer.length, this.emit('flush')) }write(e, t, r) { return this.sendPacket('message', e, t, r), this }send(e, t, r) { return this.sendPacket('message', e, t, r), this }sendPacket(e, t, r, i) { if (typeof t === 'function' && (i = t, t = void 0), typeof r === 'function' && (i = r, r = null), this.readyState === 'closing' || this.readyState === 'closed') return; r = r || {}, r.compress = r.compress !== !1; const n = { type: e, data: t, options: r }; this.emit('packetCreate', n), this.writeBuffer.push(n), i && this.once('flush', i), this.flush() }close() { const e = () => { this.onClose('forced close'), O('socket closing - telling transport to close'), this.transport.close() }; const t = () => { this.removeListener('upgrade', t), this.removeListener('upgradeError', t), e() }; const r = () => { this.once('upgrade', t), this.once('upgradeError', t) }; return (this.readyState === 'opening' || this.readyState === 'open') && (this.readyState = 'closing', this.writeBuffer.length ? this.once('drain', () => { this.upgrading ? r() : e() }) : this.upgrading ? r() : e()), this }onError(e) { O('socket error %j', e), pe.priorWebsocketSuccess = !1, this.emit('error', e), this.onClose('transport error', e) }onClose(e, t) { (this.readyState === 'opening' || this.readyState === 'open' || this.readyState === 'closing') && (O('socket close with reason: "%s"', e), clearTimeout(this.pingIntervalTimer), clearTimeout(this.pingTimeoutTimer), this.transport.removeAllListeners('close'), this.transport.close(), this.transport.removeAllListeners(), typeof removeEventListener === 'function' && removeEventListener('offline', this.offlineEventListener, !1), this.readyState = 'closed', this.id = null, this.emit('close', e, t), this.writeBuffer = [], this.prevBufferLen = 0) }filterUpgrades(e) { const t = []; let r = 0; const i = e.length; for (;r < i; r++)~this.transports.indexOf(e[r]) && t.push(e[r]); return t }}; pe.priorWebsocketSuccess = !1; pe.protocol = Zi.protocol; function Qc(s) { const e = {}; for (const t in s)s.hasOwnProperty(t) && (e[t] = s[t]); return e }tn.exports = pe }); var sn = m((ch, Qe) => { var _s = rn(); Qe.exports = (s, e) => new _s(s, e); Qe.exports.Socket = _s; Qe.exports.protocol = _s.protocol; Qe.exports.Transport = ir(); Qe.exports.transports = gs(); Qe.exports.parser = ot() }); var vs = m(dt => { 'use strict'; Object.defineProperty(dt, '__esModule', { value: !0 }); dt.hasBinary = dt.isBinary = void 0; var Jc = typeof ArrayBuffer === 'function'; var Yc = s => typeof ArrayBuffer.isView === 'function' ? ArrayBuffer.isView(s) : s.buffer instanceof ArrayBuffer; var nn = Object.prototype.toString; var Xc = typeof Blob === 'function' || typeof Blob !== 'undefined' && nn.call(Blob) === '[object BlobConstructor]'; var Zc = typeof File === 'function' || typeof File !== 'undefined' && nn.call(File) === '[object FileConstructor]'; function an(s) { return Jc && (s instanceof ArrayBuffer || Yc(s)) || Xc && s instanceof Blob || Zc && s instanceof File }dt.isBinary = an; function dr(s, e) { if (!s || typeof s !== 'object') return !1; if (Array.isArray(s)) { for (let t = 0, r = s.length; t < r; t++) if (dr(s[t])) return !0; return !1 } if (an(s)) return !0; if (s.toJSON && typeof s.toJSON === 'function' && arguments.length === 1) return dr(s.toJSON(), !0); for (const t in s) if (Object.prototype.hasOwnProperty.call(s, t) && dr(s[t])) return !0; return !1 }dt.hasBinary = dr }); var on = m(lt => { 'use strict'; Object.defineProperty(lt, '__esModule', { value: !0 }); lt.reconstructPacket = lt.deconstructPacket = void 0; var ed = vs(); function td(s) { const e = []; const t = s.data; const r = s; return r.data = ys(t, e), r.attachments = e.length, { packet: r, buffers: e } }lt.deconstructPacket = td; function ys(s, e) { if (!s) return s; if (ed.isBinary(s)) { const t = { _placeholder: !0, num: e.length }; return e.push(s), t } else if (Array.isArray(s)) { const t = new Array(s.length); for (let r = 0; r < s.length; r++)t[r] = ys(s[r], e); return t } else if (typeof s === 'object' && !(s instanceof Date)) { const t = {}; for (const r in s)s.hasOwnProperty(r) && (t[r] = ys(s[r], e)); return t } return s } function rd(s, e) { return s.data = bs(s.data, e), s.attachments = void 0, s }lt.reconstructPacket = rd; function bs(s, e) { if (!s) return s; if (s && s._placeholder) return e[s.num]; if (Array.isArray(s)) for (let t = 0; t < s.length; t++)s[t] = bs(s[t], e); else if (typeof s === 'object') for (const t in s)s.hasOwnProperty(t) && (s[t] = bs(s[t], e)); return s } }); var pr = m(ae => { 'use strict'; Object.defineProperty(ae, '__esModule', { value: !0 }); ae.Decoder = ae.Encoder = ae.PacketType = ae.protocol = void 0; var sd = ct(); var cn = on(); var dn = vs(); var ws = J()('socket.io-parser'); ae.protocol = 5; var L; (function(s) { s[s.CONNECT = 0] = 'CONNECT', s[s.DISCONNECT = 1] = 'DISCONNECT', s[s.EVENT = 2] = 'EVENT', s[s.ACK = 3] = 'ACK', s[s.CONNECT_ERROR = 4] = 'CONNECT_ERROR', s[s.BINARY_EVENT = 5] = 'BINARY_EVENT', s[s.BINARY_ACK = 6] = 'BINARY_ACK' })(L = ae.PacketType || (ae.PacketType = {})); var ln = class {encode(e) { return ws('encoding packet %j', e), (e.type === L.EVENT || e.type === L.ACK) && dn.hasBinary(e) ? (e.type = e.type === L.EVENT ? L.BINARY_EVENT : L.BINARY_ACK, this.encodeAsBinary(e)) : [this.encodeAsString(e)] }encodeAsString(e) { let t = '' + e.type; return (e.type === L.BINARY_EVENT || e.type === L.BINARY_ACK) && (t += e.attachments + '-'), e.nsp && e.nsp !== '/' && (t += e.nsp + ','), e.id != null && (t += e.id), e.data != null && (t += JSON.stringify(e.data)), ws('encoded %j as %s', e, t), t }encodeAsBinary(e) { const t = cn.deconstructPacket(e); const r = this.encodeAsString(t.packet); const i = t.buffers; return i.unshift(r), i }}; ae.Encoder = ln; var lr = class extends sd {constructor() { super() }add(e) { let t; if (typeof e === 'string')t = this.decodeString(e), t.type === L.BINARY_EVENT || t.type === L.BINARY_ACK ? (this.reconstructor = new pn(t), t.attachments === 0 && super.emit('decoded', t)) : super.emit('decoded', t); else if (dn.isBinary(e) || e.base64) if (this.reconstructor)t = this.reconstructor.takeBinaryData(e), t && (this.reconstructor = null, super.emit('decoded', t)); else throw new Error('got binary data when not reconstructing a packet'); else throw new Error('Unknown type: ' + e) }decodeString(e) { let t = 0; const r = { type: Number(e.charAt(0)) }; if (L[r.type] === void 0) throw new Error('unknown packet type ' + r.type); if (r.type === L.BINARY_EVENT || r.type === L.BINARY_ACK) { const n = t + 1; for (;e.charAt(++t) !== '-' && t != e.length;);const c = e.substring(n, t); if (c != Number(c) || e.charAt(t) !== '-') throw new Error('Illegal attachments'); r.attachments = Number(c) } if (e.charAt(t + 1) === '/') { const n = t + 1; for (;++t && !(e.charAt(t) === ',' || t === e.length););r.nsp = e.substring(n, t) } else r.nsp = '/'; const i = e.charAt(t + 1); if (i !== '' && Number(i) == i) { const n = t + 1; for (;++t;) { const c = e.charAt(t); if (c == null || Number(c) != c) { --t; break } if (t === e.length) break }r.id = Number(e.substring(n, t + 1)) } if (e.charAt(++t)) { const n = id(e.substr(t)); if (lr.isPayloadValid(r.type, n))r.data = n; else throw new Error('invalid payload') } return ws('decoded %s as %j', e, r), r }static isPayloadValid(e, t) { switch (e) { case L.CONNECT:return typeof t === 'object'; case L.DISCONNECT:return t === void 0; case L.CONNECT_ERROR:return typeof t === 'string' || typeof t === 'object'; case L.EVENT:case L.BINARY_EVENT:return Array.isArray(t) && t.length > 0; case L.ACK:case L.BINARY_ACK:return Array.isArray(t) } }destroy() { this.reconstructor && this.reconstructor.finishedReconstruction() }}; ae.Decoder = lr; function id(s) { try { return JSON.parse(s) } catch (e) { return !1 } } var pn = class {constructor(e) { this.packet = e, this.buffers = [], this.reconPack = e }takeBinaryData(e) { if (this.buffers.push(e), this.buffers.length === this.reconPack.attachments) { const t = cn.reconstructPacket(this.reconPack, this.buffers); return this.finishedReconstruction(), t } return null }finishedReconstruction() { this.reconPack = null, this.buffers = [] }} }); var Ss = m(ur => { 'use strict'; Object.defineProperty(ur, '__esModule', { value: !0 }); ur.on = void 0; function nd(s, e, t) { return s.on(e, t), function() { s.off(e, t) } }ur.on = nd }); var Rs = m(hr => { 'use strict'; Object.defineProperty(hr, '__esModule', { value: !0 }); hr.StrictEventEmitter = void 0; var ad = ct(); var un = class extends ad {on(e, t) { return super.on(e, t), this }once(e, t) { return super.once(e, t), this }emit(e, ...t) { return super.emit(e, ...t), this }emitReserved(e, ...t) { return super.emit(e, ...t), this }listeners(e) { return super.listeners(e) }}; hr.StrictEventEmitter = un }); var Cs = m(mr => { 'use strict'; Object.defineProperty(mr, '__esModule', { value: !0 }); mr.Socket = void 0; var Z = pr(); var fr = Ss(); var od = Rs(); var ee = J()('socket.io-client:socket'); var cd = Object.freeze({ connect: 1, connect_error: 1, disconnect: 1, disconnecting: 1, newListener: 1, removeListener: 1 }); var hn = class extends od.StrictEventEmitter {constructor(e, t, r) { super(); this.receiveBuffer = [], this.sendBuffer = [], this.ids = 0, this.acks = {}, this.flags = {}, this.io = e, this.nsp = t, this.ids = 0, this.acks = {}, this.receiveBuffer = [], this.sendBuffer = [], this.connected = !1, this.disconnected = !0, this.flags = {}, r && r.auth && (this.auth = r.auth), this.io._autoConnect && this.open() }subEvents() { if (this.subs) return; const e = this.io; this.subs = [fr.on(e, 'open', this.onopen.bind(this)), fr.on(e, 'packet', this.onpacket.bind(this)), fr.on(e, 'error', this.onerror.bind(this)), fr.on(e, 'close', this.onclose.bind(this))] } get active() { return !!this.subs }connect() { return this.connected ? this : (this.subEvents(), this.io._reconnecting || this.io.open(), this.io._readyState === 'open' && this.onopen(), this) }open() { return this.connect() }send(...e) { return e.unshift('message'), this.emit.apply(this, e), this }emit(e, ...t) { if (cd.hasOwnProperty(e)) throw new Error('"' + e + '" is a reserved event name'); t.unshift(e); const r = { type: Z.PacketType.EVENT, data: t }; r.options = {}, r.options.compress = this.flags.compress !== !1, typeof t[t.length - 1] === 'function' && (ee('emitting packet with ack id %d', this.ids), this.acks[this.ids] = t.pop(), r.id = this.ids++); const i = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable; return this.flags.volatile && (!i || !this.connected) ? ee('discard packet as the transport is not currently writable') : this.connected ? this.packet(r) : this.sendBuffer.push(r), this.flags = {}, this }packet(e) { e.nsp = this.nsp, this.io._packet(e) }onopen() { ee('transport is open - connecting'), typeof this.auth === 'function' ? this.auth(e => { this.packet({ type: Z.PacketType.CONNECT, data: e }) }) : this.packet({ type: Z.PacketType.CONNECT, data: this.auth }) }onerror(e) { this.connected || this.emitReserved('connect_error', e) }onclose(e) { ee('close (%s)', e), this.connected = !1, this.disconnected = !0, delete this.id, this.emitReserved('disconnect', e) }onpacket(e) { if (e.nsp === this.nsp) switch (e.type) { case Z.PacketType.CONNECT:if (e.data && e.data.sid) { const i = e.data.sid; this.onconnect(i) } else this.emitReserved('connect_error', new Error('It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)')); break; case Z.PacketType.EVENT:this.onevent(e); break; case Z.PacketType.BINARY_EVENT:this.onevent(e); break; case Z.PacketType.ACK:this.onack(e); break; case Z.PacketType.BINARY_ACK:this.onack(e); break; case Z.PacketType.DISCONNECT:this.ondisconnect(); break; case Z.PacketType.CONNECT_ERROR:const r = new Error(e.data.message); r.data = e.data.data, this.emitReserved('connect_error', r); break } }onevent(e) { const t = e.data || []; ee('emitting event %j', t), e.id != null && (ee('attaching ack callback to event'), t.push(this.ack(e.id))), this.connected ? this.emitEvent(t) : this.receiveBuffer.push(Object.freeze(t)) }emitEvent(e) { if (this._anyListeners && this._anyListeners.length) { const t = this._anyListeners.slice(); for (const r of t)r.apply(this, e) } super.emit.apply(this, e) }ack(e) { const t = this; let r = !1; return function(...i) { r || (r = !0, ee('sending ack %j', i), t.packet({ type: Z.PacketType.ACK, id: e, data: i })) } }onack(e) { const t = this.acks[e.id]; typeof t === 'function' ? (ee('calling ack %s with %j', e.id, e.data), t.apply(this, e.data), delete this.acks[e.id]) : ee('bad ack %s', e.id) }onconnect(e) { ee('socket connected with id %s', e), this.id = e, this.connected = !0, this.disconnected = !1, this.emitBuffered(), this.emitReserved('connect') }emitBuffered() { this.receiveBuffer.forEach(e => this.emitEvent(e)), this.receiveBuffer = [], this.sendBuffer.forEach(e => this.packet(e)), this.sendBuffer = [] }ondisconnect() { ee('server disconnect (%s)', this.nsp), this.destroy(), this.onclose('io server disconnect') }destroy() { this.subs && (this.subs.forEach(e => e()), this.subs = void 0), this.io._destroy(this) }disconnect() { return this.connected && (ee('performing disconnect (%s)', this.nsp), this.packet({ type: Z.PacketType.DISCONNECT })), this.destroy(), this.connected && this.onclose('io client disconnect'), this }close() { return this.disconnect() }compress(e) { return this.flags.compress = e, this } get volatile() { return this.flags.volatile = !0, this }onAny(e) { return this._anyListeners = this._anyListeners || [], this._anyListeners.push(e), this }prependAny(e) { return this._anyListeners = this._anyListeners || [], this._anyListeners.unshift(e), this }offAny(e) { if (!this._anyListeners) return this; if (e) { const t = this._anyListeners; for (let r = 0; r < t.length; r++) if (e === t[r]) return t.splice(r, 1), this } else this._anyListeners = []; return this }listenersAny() { return this._anyListeners || [] }}; mr.Socket = hn }); var mn = m((mh, fn) => { fn.exports = pt; function pt(s) { s = s || {}, this.ms = s.min || 100, this.max = s.max || 1e4, this.factor = s.factor || 2, this.jitter = s.jitter > 0 && s.jitter <= 1 ? s.jitter : 0, this.attempts = 0 }pt.prototype.duration = function() { var s = this.ms * Math.pow(this.factor, this.attempts++); if (this.jitter) { var e = Math.random(); var t = Math.floor(e * this.jitter * s); s = (Math.floor(e * 10) & 1) == 0 ? s - t : s + t } return Math.min(s, this.max) | 0 }; pt.prototype.reset = function() { this.attempts = 0 }; pt.prototype.setMin = function(s) { this.ms = s }; pt.prototype.setMax = function(s) { this.max = s }; pt.prototype.setJitter = function(s) { this.jitter = s } }); var Ts = m(gr => { 'use strict'; Object.defineProperty(gr, '__esModule', { value: !0 }); gr.Manager = void 0; var dd = sn(); var ld = Cs(); var pd = pr(); var Je = Ss(); var ud = mn(); var hd = Rs(); var B = J()('socket.io-client:manager'); var gn = class extends hd.StrictEventEmitter {constructor(e, t) { super(); this.nsps = {}, this.subs = [], e && typeof e === 'object' && (t = e, e = void 0), t = t || {}, t.path = t.path || '/socket.io', this.opts = t, this.reconnection(t.reconnection !== !1), this.reconnectionAttempts(t.reconnectionAttempts || Infinity), this.reconnectionDelay(t.reconnectionDelay || 1e3), this.reconnectionDelayMax(t.reconnectionDelayMax || 5e3), this.randomizationFactor(t.randomizationFactor || 0.5), this.backoff = new ud({ min: this.reconnectionDelay(), max: this.reconnectionDelayMax(), jitter: this.randomizationFactor() }), this.timeout(t.timeout == null ? 2e4 : t.timeout), this._readyState = 'closed', this.uri = e; const r = t.parser || pd; this.encoder = new r.Encoder(), this.decoder = new r.Decoder(), this._autoConnect = t.autoConnect !== !1, this._autoConnect && this.open() }reconnection(e) { return arguments.length ? (this._reconnection = !!e, this) : this._reconnection }reconnectionAttempts(e) { return e === void 0 ? this._reconnectionAttempts : (this._reconnectionAttempts = e, this) }reconnectionDelay(e) { var t; return e === void 0 ? this._reconnectionDelay : (this._reconnectionDelay = e, (t = this.backoff) === null || t === void 0 || t.setMin(e), this) }randomizationFactor(e) { var t; return e === void 0 ? this._randomizationFactor : (this._randomizationFactor = e, (t = this.backoff) === null || t === void 0 || t.setJitter(e), this) }reconnectionDelayMax(e) { var t; return e === void 0 ? this._reconnectionDelayMax : (this._reconnectionDelayMax = e, (t = this.backoff) === null || t === void 0 || t.setMax(e), this) }timeout(e) { return arguments.length ? (this._timeout = e, this) : this._timeout }maybeReconnectOnOpen() { !this._reconnecting && this._reconnection && this.backoff.attempts === 0 && this.reconnect() }open(e) { if (B('readyState %s', this._readyState), ~this._readyState.indexOf('open')) return this; B('opening %s', this.uri), this.engine = dd(this.uri, this.opts); const t = this.engine; const r = this; this._readyState = 'opening', this.skipReconnect = !1; const i = Je.on(t, 'open', function() { r.onopen(), e && e() }); const n = Je.on(t, 'error', c => { B('error'), r.cleanup(), r._readyState = 'closed', this.emitReserved('error', c), e ? e(c) : r.maybeReconnectOnOpen() }); if (this._timeout !== !1) { const c = this._timeout; B('connect attempt will timeout after %d', c), c === 0 && i(); const a = setTimeout(() => { B('connect attempt timed out after %d', c), i(), t.close(), t.emit('error', new Error('timeout')) }, c); this.opts.autoUnref && a.unref(), this.subs.push(function() { clearTimeout(a) }) } return this.subs.push(i), this.subs.push(n), this }connect(e) { return this.open(e) }onopen() { B('open'), this.cleanup(), this._readyState = 'open', this.emitReserved('open'); const e = this.engine; this.subs.push(Je.on(e, 'ping', this.onping.bind(this)), Je.on(e, 'data', this.ondata.bind(this)), Je.on(e, 'error', this.onerror.bind(this)), Je.on(e, 'close', this.onclose.bind(this)), Je.on(this.decoder, 'decoded', this.ondecoded.bind(this))) }onping() { this.emitReserved('ping') }ondata(e) { this.decoder.add(e) }ondecoded(e) { this.emitReserved('packet', e) }onerror(e) { B('error', e), this.emitReserved('error', e) }socket(e, t) { let r = this.nsps[e]; return r || (r = new ld.Socket(this, e, t), this.nsps[e] = r), r }_destroy(e) { const t = Object.keys(this.nsps); for (const r of t) if (this.nsps[r].active) { B('socket %s is still active, skipping close', r); return } this._close() }_packet(e) { B('writing packet %j', e); const t = this.encoder.encode(e); for (let r = 0; r < t.length; r++) this.engine.write(t[r], e.options) }cleanup() { B('cleanup'), this.subs.forEach(e => e()), this.subs.length = 0, this.decoder.destroy() }_close() { B('disconnect'), this.skipReconnect = !0, this._reconnecting = !1, this._readyState === 'opening' && this.cleanup(), this.backoff.reset(), this._readyState = 'closed', this.engine && this.engine.close() }disconnect() { return this._close() }onclose(e) { B('onclose'), this.cleanup(), this.backoff.reset(), this._readyState = 'closed', this.emitReserved('close', e), this._reconnection && !this.skipReconnect && this.reconnect() }reconnect() { if (this._reconnecting || this.skipReconnect) return this; const e = this; if (this.backoff.attempts >= this._reconnectionAttempts)B('reconnect failed'), this.backoff.reset(), this.emitReserved('reconnect_failed'), this._reconnecting = !1; else { const t = this.backoff.duration(); B('will wait %dms before reconnect attempt', t), this._reconnecting = !0; const r = setTimeout(() => { e.skipReconnect || (B('attempting reconnect'), this.emitReserved('reconnect_attempt', e.backoff.attempts), !e.skipReconnect && e.open(i => { i ? (B('reconnect attempt error'), e._reconnecting = !1, e.reconnect(), this.emitReserved('reconnect_error', i)) : (B('reconnect success'), e.onreconnect()) })) }, t); this.opts.autoUnref && r.unref(), this.subs.push(function() { clearTimeout(r) }) } }onreconnect() { const e = this.backoff.attempts; this._reconnecting = !1, this.backoff.reset(), this.emitReserved('reconnect', e) }}; gr.Manager = gn }); var bn = m((K, yn) => { 'use strict'; Object.defineProperty(K, '__esModule', { value: !0 }); K.io = K.Socket = K.Manager = K.protocol = void 0; var fd = di(); var _n = Ts(); var vn = J()('socket.io-client'); yn.exports = K = _r; var At = K.managers = {}; function _r(s, e) { typeof s === 'object' && (e = s, s = void 0), e = e || {}; const t = fd.url(s, e.path || '/socket.io'); const r = t.source; const i = t.id; const n = t.path; const c = At[i] && n in At[i].nsps; const a = e.forceNew || e['force new connection'] || e.multiplex === !1 || c; let o; return a ? (vn('ignoring socket cache for %s', r), o = new _n.Manager(r, e)) : (At[i] || (vn('new io instance for %s', r), At[i] = new _n.Manager(r, e)), o = At[i]), t.query && !e.query && (e.query = t.queryKey), o.socket(t.path, e) }K.io = _r; var md = pr(); Object.defineProperty(K, 'protocol', { enumerable: !0, get: function() { return md.protocol } }); K.connect = _r; var gd = Ts(); Object.defineProperty(K, 'Manager', { enumerable: !0, get: function() { return gd.Manager } }); var _d = Cs(); Object.defineProperty(K, 'Socket', { enumerable: !0, get: function() { return _d.Socket } }); K.default = _r }); var Sn = m(wn => { wn.promise = function(s) { return function(t, r = {}) { return new Promise(i => { s.emit(t, r, i) }) } } }); var Ps = m((yh, Rn) => { Rn.exports = class {constructor(e) { this.room = e, this.socket = e.socket, this.name = e.name, this.room_id = e.room_id, this.debug = e.debug, this.isProducer = !0 }log(...e) { this.debug && console.log(...e) }error(...e) { console.error(...e) } async onJoinRoom(e) { this.log('base', 'onJoinRoom', e), this.roomInfo = e } async onInitSockets(e) { this.log('base', 'onInitSockets'), this.socket = e } async onProduce(e) { this.log('base', 'onProduce', e) } async onCloseProducer(e) { this.log('base', 'onCloseProducer', e) } async onClean(e = !1) { this.log('base', 'onClean') } async onAddPeer(e) { this.log('base', 'onAddPeer', e.id) } async onRemovePeer(e) { this.log('base', 'onRemovePeer', e.id) }onCommand(e) { this.log('base', 'command', e.msgType) } async sendCmd(e) { return this.socket ? await this.socket.request('cmd', e) : { code: 500, errorMsg: 'no socket' } }} }); var Tn = m((bh, Cn) => { Cn.exports = function() { return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(e) { var t = Math.random() * 16 | 0; var r = e == 'x' ? t : t & 3 | 8; return r.toString(16) }) } }); var En = m((Sh, Pn) => {
    var vd = Ps(); var yd = Tn(); Pn.exports = class extends vd {
      constructor(e) { super(e); this.log('p2p client'), this.m_conf = e.config, this.m_streams = new Map(), this.m_producers = new Map(), this.m_consumers = new Map() } async onJoinRoom(e) { this.log('p2p', 'onJoinRoom', e), this.myInfo = e.myInfo, this.roomInfo = e.roomInfo, this.hi() } async onInitSockets(e) { this.log('p2p', 'onInitSockets'), this.socket = e } async onProduce(e) { !this.isProducer || (this.log('p2p', 'onProduce', e), await this.produce(e)) } async onCloseProducer(e) { this.log('p2p', 'onCloseProducer', e), this.hungup(null, e.type), this.m_streams.delete(e.type) } async onClean(e = !1) { this.log('p2p', 'onClean offline:', e), this.m_producers.forEach((t, r) => { t.closeAll() }), this.m_producers.clear(), this.m_consumers.forEach((t, r) => { t.closeAll() }), this.m_consumers.clear(), this.m_streams.forEach((t, r) => { this.room.removeUserMedia(t.elem) }), this.m_streams.clear() }onCommand(e) { if (this.log('p2p', 'command', e), !(e.msgType !== 'p2pCmd' || !e.msg || !e.msg.cmd)) switch (e.msg.cmd) { case 'hi':this.recvHi(e); break; case 'hungup':this.recvHungup(e); break; case 'candidate':this.recvCandidate(e); break; case 'offer':this.recvOffer(e); break; case 'answer':this.recvAnswer(e); break } } async hi(e = null) { const t = await this.sendCmd({ cmd: 'hi' }, e); this.log('p2p', 'send hi', t) } async recvHi(e) { this.m_streams.forEach((t, r) => { const i = e.fromId; const n = e.peerName; this.producePeer(i, n, t) }) } async hungup(e, t) { this.log('p2p', 'send hungup', e, t), await this.sendCmd({ cmd: 'hungup', type: t }, e), e ? this.closeProducer(this.p2pId(e, t)) : this.m_producers.forEach((r, i) => { r.type === t && this.closeProducer(r.pcId) }) } async recvHungup(e) { this.closeConsumer(this.p2pId(e.fromId, e.msg.type)) } async candidate(e, t = null, r) { const i = await this.sendCmd({ cmd: 'candidate', candidate: e, type: r }, t); this.log('p2p', 'send candidate', i) } async recvCandidate(e) { if (e.fromId !== this.myInfo.id) { this.log('handle candidate'); try { const t = this.consume(e.fromId, e.peerName, e.msg.type); t.signalingState !== 'have-local-offer' && (this.log(t.signalingState), await t.addIceCandidate(e.msg.candidate)) } catch (t) { console.warn(t) } } } async offer(e, t, r) { const i = await this.sendCmd({ cmd: 'offer', desc: e, type: r }, t); this.log('p2p', 'send offer', i) } async recvOffer(e) { this.log('handle offer'); try { const t = this.consume(e.fromId, e.peerName, e.msg.type); await t.setRemoteDescription(e.msg.desc); const r = await t.createAnswer(); await t.setLocalDescription(r), r.sdp = this._setMediaBitrates(r.sdp), this.answer(r, e.fromId, e.msg.type) } catch (t) { console.warn(t) } } async answer(e, t, r) { const i = await this.sendCmd({ cmd: 'answer', desc: e, type: r }, t); this.log('p2p', 'send answer', i) } async recvAnswer(e) { this.log('handle answer', e.fromId, e.peerName, e.msg.type); try { await this.m_producers.get(this.p2pId(e.fromId, e.msg.type)).setRemoteDescription(e.msg.desc) } catch (t) { console.warn(t) } } async sendCmd(e, t = null) { const r = { toUserId: t, msgId: yd(), msgType: 'p2pCmd', msg: e }; return await super.sendCmd(r) }p2pId(e, t) { return 'p2p_' + e + t } async produce(e) { if (this.m_streams.has(e.type)) { this.error('p2p', 'there is already a producer for type ', e.type); return } this.m_streams.set(e.type, e), e.type === 'screenType' && (e.stream.oninactive = () => { this.log('screen share is stop'), this.room.closeProducer(e.type) }), this.roomInfo = await this.room.roomInfo(), this.roomInfo.peers.forEach(t => { t.id !== this.myInfo.id && this.producePeer(t.id, t.name, e) }) }producePeer(e, t, r) { const i = r.type; const n = r.stream; const c = this.p2pId(e, i); let a = null; return this.m_producers.has(c) ? a = this.m_producers.get(c) : (a = this.newPeer(e, t, i, 'producer'), this.m_producers.set(c, a)), n && n.getTracks().forEach(o => { this.log('producePeer:', e, t, i), a.addTrack(o, n) }), a }closeProducer(e) { this.m_producers.has(e) && (this.m_producers.get(e).closeAll(), this.m_producers.delete(e)) }consume(e, t, r) { const i = this.p2pId(e, r); let n = null; return this.m_consumers.has(i) ? n = this.m_consumers.get(i) : (n = this.newPeer(e, t, r, 'consumer'), this.m_consumers.set(i, n)), n }closeConsumer(e) { this.m_consumers.has(e) && (this.m_consumers.get(e).closeAll(), this.m_consumers.delete(e)) }newPeer(e, t, r, i) { this.log('newPeer', e, t, r); const n = this.p2pId(e, r); let c = this.m_conf.iceServers; c || (c = [{ urls: ['stun:dapp.umnet.cn:3478', 'stun:open.umnet.cn:3478', 'stun:stun.l.google.com:19302', 'stun:stun.stunprotocol.org:3478', 'stun:stun.iptel.org:3478'] }]); const a = new RTCPeerConnection({ iceServers: c }); return a.pcId = n, a.type = r, a.peerId = e, a.peerName = t, a.roles = i, a.consumers = new Map(), a.isNegotiating = !1, a._closed = !1, a.onicecandidate = async({ candidate: o }) => { this.log('p2p', 'on ice candidate', o, e, r), o && this.candidate(o, e, r) }, a.onnegotiationneeded = async() => { await a.sendOffer() }, a.ontrack = async o => { this.log('ontrack from:', e); for (let d = 0; d < o.streams.length; d++) { const l = 'p2p_'; const p = o.streams[d]; const u = p.getTracks(); const h = l + p.id; let f = 'audio'; for (let _ = 0; _ < u.length && (f = u[_].kind, f !== 'video'); _++);a.consumers.set(h, { kind: f, consumer_id: h, peerId: e, peerName: t, stream: p, type: r }), this.room.consume(f, h, e, t, p, r) } }, a.onconnectionstatechange = async o => { switch (this.log('p2p', 'on connection state change:', a.connectionState), a.connectionState) { case 'connected':a.cancelRetrySfu(); break; case 'disconnected':a.closeAll(), a.cancelRetrySfu(); break; case 'failed':a.closeAll(), a.cancelRetrySfu(), a.roles === 'producer' && this.room.tryNext(this, { id: a.peerId, name: a.peerName, type: a.type, roles: a.roles }, this.m_streams.get(a.type)); break; case 'closed':a.closeAll(), a.cancelRetrySfu(); break } }, a.onsignalingstatechange = o => { this.log('p2p', 'onsignalingstatechange', a.signalingState), a.isNegotiating = a.signalingState != 'stable' }, a.clearConsumers = () => { a.consumers.forEach((o, d) => { this.room.closeConsumer(d) }), a.consumers.clear() }, a.sendOffer = async() => { if (a.isNegotiating) { this.log('SKIP nested negotiations'); return }a.isNegotiating = !0; try { const o = await a.createOffer(); await a.setLocalDescription(o), o.sdp = this._setMediaBitrates(o.sdp), this.offer(o, e, r) } catch (o) { console.error(o) } }, a.closeAll = () => { a._closed || (a._closed = !0, a.clearConsumers(), a.close(), a.roles === 'producer' ? this.closeProducer(a.pcId) : this.closeConsumer(a.pcId)) }, a.retrySfu = setTimeout(() => { a.roles === 'producer' && this.room.tryNext(this, { id: a.peerId, name: a.peerName, type: a.type, roles: a.roles }, this.m_streams.get(a.type)) }, 15e3), a.cancelRetrySfu = () => { clearTimeout(a.retrySfu) }, a }_setMediaBitrates(e) { const t = this.m_conf; return t.rateconf && t.rateconf.video > 0 && t.rateconf.audio > 0 ? this._setMediaBitrate(this._setMediaBitrate(e, 'video', t.rateconf.video), 'audio', t.rateconf.audio) : e }_setMediaBitrate(e, t, r) {
        for (var i = e.split(`
`), n = -1, c = 0; c < i.length; c++) if (i[c].indexOf('m=' + t) === 0) { n = c; break } if (n === -1) return console.debug('Could not find the m line for', t), e; for (console.debug('Found the m line for', t, 'at line', n), n++; i[n].indexOf('i=') === 0 || i[n].indexOf('c=') === 0;)n++; if (i[n].indexOf('b') === 0) {
          return console.debug('Replaced b line at line', n), i[n] = 'b=AS:' + r, i.join(`
`)
        } console.debug('Adding new b line before line', n); var a = i.slice(0, n); return a.push('b=AS:' + r), a = a.concat(i.slice(n, i.length)), a.join(`
`)
      }
    }
  }); var Dn = m((jt, Es) => { (function(s, e) { typeof jt === 'object' && typeof Es === 'object' ? Es.exports = e() : typeof define === 'function' && define.amd ? define([], e) : typeof jt === 'object' ? jt.bowser = e() : s.bowser = e() })(jt, function() { return (function(s) { var e = {}; function t(r) { if (e[r]) return e[r].exports; var i = e[r] = { i: r, l: !1, exports: {}}; return s[r].call(i.exports, i, i.exports, t), i.l = !0, i.exports } return t.m = s, t.c = e, t.d = function(r, i, n) { t.o(r, i) || Object.defineProperty(r, i, { enumerable: !0, get: n }) }, t.r = function(r) { typeof Symbol !== 'undefined' && Symbol.toStringTag && Object.defineProperty(r, Symbol.toStringTag, { value: 'Module' }), Object.defineProperty(r, '__esModule', { value: !0 }) }, t.t = function(r, i) { if (1 & i && (r = t(r)), 8 & i || 4 & i && typeof r === 'object' && r && r.__esModule) return r; var n = Object.create(null); if (t.r(n), Object.defineProperty(n, 'default', { enumerable: !0, value: r }), 2 & i && typeof r !== 'string') for (var c in r)t.d(n, c, function(a) { return r[a] }.bind(null, c)); return n }, t.n = function(r) { var i = r && r.__esModule ? function() { return r.default } : function() { return r }; return t.d(i, 'a', i), i }, t.o = function(r, i) { return Object.prototype.hasOwnProperty.call(r, i) }, t.p = '', t(t.s = 90) }({ 17: function(s, e, t) { 'use strict'; e.__esModule = !0, e.default = void 0; var r = t(18); var i = (function() { function n() {} return n.getFirstMatch = function(c, a) { var o = a.match(c); return o && o.length > 0 && o[1] || '' }, n.getSecondMatch = function(c, a) { var o = a.match(c); return o && o.length > 1 && o[2] || '' }, n.matchAndReturnConst = function(c, a, o) { if (c.test(a)) return o }, n.getWindowsVersionName = function(c) { switch (c) { case 'NT':return 'NT'; case 'XP':return 'XP'; case 'NT 5.0':return '2000'; case 'NT 5.1':return 'XP'; case 'NT 5.2':return '2003'; case 'NT 6.0':return 'Vista'; case 'NT 6.1':return '7'; case 'NT 6.2':return '8'; case 'NT 6.3':return '8.1'; case 'NT 10.0':return '10'; default:return } }, n.getMacOSVersionName = function(c) { var a = c.split('.').splice(0, 2).map(function(o) { return parseInt(o, 10) || 0 }); if (a.push(0), a[0] === 10) switch (a[1]) { case 5:return 'Leopard'; case 6:return 'Snow Leopard'; case 7:return 'Lion'; case 8:return 'Mountain Lion'; case 9:return 'Mavericks'; case 10:return 'Yosemite'; case 11:return 'El Capitan'; case 12:return 'Sierra'; case 13:return 'High Sierra'; case 14:return 'Mojave'; case 15:return 'Catalina'; default:return } }, n.getAndroidVersionName = function(c) { var a = c.split('.').splice(0, 2).map(function(o) { return parseInt(o, 10) || 0 }); if (a.push(0), !(a[0] === 1 && a[1] < 5)) return a[0] === 1 && a[1] < 6 ? 'Cupcake' : a[0] === 1 && a[1] >= 6 ? 'Donut' : a[0] === 2 && a[1] < 2 ? 'Eclair' : a[0] === 2 && a[1] === 2 ? 'Froyo' : a[0] === 2 && a[1] > 2 ? 'Gingerbread' : a[0] === 3 ? 'Honeycomb' : a[0] === 4 && a[1] < 1 ? 'Ice Cream Sandwich' : a[0] === 4 && a[1] < 4 ? 'Jelly Bean' : a[0] === 4 && a[1] >= 4 ? 'KitKat' : a[0] === 5 ? 'Lollipop' : a[0] === 6 ? 'Marshmallow' : a[0] === 7 ? 'Nougat' : a[0] === 8 ? 'Oreo' : a[0] === 9 ? 'Pie' : void 0 }, n.getVersionPrecision = function(c) { return c.split('.').length }, n.compareVersions = function(c, a, o) { o === void 0 && (o = !1); var d = n.getVersionPrecision(c); var l = n.getVersionPrecision(a); var p = Math.max(d, l); var u = 0; var h = n.map([c, a], function(f) { var _ = p - n.getVersionPrecision(f); var g = f + new Array(_ + 1).join('.0'); return n.map(g.split('.'), function(k) { return new Array(20 - k.length).join('0') + k }).reverse() }); for (o && (u = p - Math.min(d, l)), p -= 1; p >= u;) { if (h[0][p] > h[1][p]) return 1; if (h[0][p] === h[1][p]) { if (p === u) return 0; p -= 1 } else if (h[0][p] < h[1][p]) return -1 } }, n.map = function(c, a) { var o; var d = []; if (Array.prototype.map) return Array.prototype.map.call(c, a); for (o = 0; o < c.length; o += 1)d.push(a(c[o])); return d }, n.find = function(c, a) { var o, d; if (Array.prototype.find) return Array.prototype.find.call(c, a); for (o = 0, d = c.length; o < d; o += 1) { var l = c[o]; if (a(l, o)) return l } }, n.assign = function(c) { for (var a, o, d = c, l = arguments.length, p = new Array(l > 1 ? l - 1 : 0), u = 1; u < l; u++)p[u - 1] = arguments[u]; if (Object.assign) return Object.assign.apply(Object, [c].concat(p)); var h = function() { var f = p[a]; typeof f === 'object' && f !== null && Object.keys(f).forEach(function(_) { d[_] = f[_] }) }; for (a = 0, o = p.length; a < o; a += 1)h(); return c }, n.getBrowserAlias = function(c) { return r.BROWSER_ALIASES_MAP[c] }, n.getBrowserTypeByAlias = function(c) { return r.BROWSER_MAP[c] || '' }, n }()); e.default = i, s.exports = e.default }, 18: function(s, e, t) { 'use strict'; e.__esModule = !0, e.ENGINE_MAP = e.OS_MAP = e.PLATFORMS_MAP = e.BROWSER_MAP = e.BROWSER_ALIASES_MAP = void 0, e.BROWSER_ALIASES_MAP = { 'Amazon Silk': 'amazon_silk', 'Android Browser': 'android', Bada: 'bada', BlackBerry: 'blackberry', Chrome: 'chrome', Chromium: 'chromium', Electron: 'electron', Epiphany: 'epiphany', Firefox: 'firefox', Focus: 'focus', Generic: 'generic', 'Google Search': 'google_search', Googlebot: 'googlebot', 'Internet Explorer': 'ie', 'K-Meleon': 'k_meleon', Maxthon: 'maxthon', 'Microsoft Edge': 'edge', 'MZ Browser': 'mz', 'NAVER Whale Browser': 'naver', Opera: 'opera', 'Opera Coast': 'opera_coast', PhantomJS: 'phantomjs', Puffin: 'puffin', QupZilla: 'qupzilla', QQ: 'qq', QQLite: 'qqlite', Safari: 'safari', Sailfish: 'sailfish', 'Samsung Internet for Android': 'samsung_internet', SeaMonkey: 'seamonkey', Sleipnir: 'sleipnir', Swing: 'swing', Tizen: 'tizen', 'UC Browser': 'uc', Vivaldi: 'vivaldi', 'WebOS Browser': 'webos', WeChat: 'wechat', 'Yandex Browser': 'yandex', Roku: 'roku' }, e.BROWSER_MAP = { amazon_silk: 'Amazon Silk', android: 'Android Browser', bada: 'Bada', blackberry: 'BlackBerry', chrome: 'Chrome', chromium: 'Chromium', electron: 'Electron', epiphany: 'Epiphany', firefox: 'Firefox', focus: 'Focus', generic: 'Generic', googlebot: 'Googlebot', google_search: 'Google Search', ie: 'Internet Explorer', k_meleon: 'K-Meleon', maxthon: 'Maxthon', edge: 'Microsoft Edge', mz: 'MZ Browser', naver: 'NAVER Whale Browser', opera: 'Opera', opera_coast: 'Opera Coast', phantomjs: 'PhantomJS', puffin: 'Puffin', qupzilla: 'QupZilla', qq: 'QQ Browser', qqlite: 'QQ Browser Lite', safari: 'Safari', sailfish: 'Sailfish', samsung_internet: 'Samsung Internet for Android', seamonkey: 'SeaMonkey', sleipnir: 'Sleipnir', swing: 'Swing', tizen: 'Tizen', uc: 'UC Browser', vivaldi: 'Vivaldi', webos: 'WebOS Browser', wechat: 'WeChat', yandex: 'Yandex Browser' }, e.PLATFORMS_MAP = { tablet: 'tablet', mobile: 'mobile', desktop: 'desktop', tv: 'tv' }, e.OS_MAP = { WindowsPhone: 'Windows Phone', Windows: 'Windows', MacOS: 'macOS', iOS: 'iOS', Android: 'Android', WebOS: 'WebOS', BlackBerry: 'BlackBerry', Bada: 'Bada', Tizen: 'Tizen', Linux: 'Linux', ChromeOS: 'Chrome OS', PlayStation4: 'PlayStation 4', Roku: 'Roku' }, e.ENGINE_MAP = { EdgeHTML: 'EdgeHTML', Blink: 'Blink', Trident: 'Trident', Presto: 'Presto', Gecko: 'Gecko', WebKit: 'WebKit' } }, 90: function(s, e, t) { 'use strict'; e.__esModule = !0, e.default = void 0; var r; var i = (r = t(91)) && r.__esModule ? r : { default: r }; var n = t(18); function c(o, d) { for (var l = 0; l < d.length; l++) { var p = d[l]; p.enumerable = p.enumerable || !1, p.configurable = !0, 'value' in p && (p.writable = !0), Object.defineProperty(o, p.key, p) } } var a = (function() { function o() {} var d, l, p; return o.getParser = function(u, h) { if (h === void 0 && (h = !1), typeof u !== 'string') throw new Error('UserAgent should be a string'); return new i.default(u, h) }, o.parse = function(u) { return new i.default(u).getResult() }, d = o, p = [{ key: 'BROWSER_MAP', get: function() { return n.BROWSER_MAP } }, { key: 'ENGINE_MAP', get: function() { return n.ENGINE_MAP } }, { key: 'OS_MAP', get: function() { return n.OS_MAP } }, { key: 'PLATFORMS_MAP', get: function() { return n.PLATFORMS_MAP } }], (l = null) && c(d.prototype, l), p && c(d, p), o }()); e.default = a, s.exports = e.default }, 91: function(s, e, t) { 'use strict'; e.__esModule = !0, e.default = void 0; var r = o(t(92)); var i = o(t(93)); var n = o(t(94)); var c = o(t(95)); var a = o(t(17)); function o(l) { return l && l.__esModule ? l : { default: l } } var d = (function() { function l(u, h) { if (h === void 0 && (h = !1), u == null || u === '') throw new Error("UserAgent parameter can't be empty"); this._ua = u, this.parsedResult = {}, h !== !0 && this.parse() } var p = l.prototype; return p.getUA = function() { return this._ua }, p.test = function(u) { return u.test(this._ua) }, p.parseBrowser = function() { var u = this; this.parsedResult.browser = {}; var h = a.default.find(r.default, function(f) { if (typeof f.test === 'function') return f.test(u); if (f.test instanceof Array) return f.test.some(function(_) { return u.test(_) }); throw new Error("Browser's test function is not valid") }); return h && (this.parsedResult.browser = h.describe(this.getUA())), this.parsedResult.browser }, p.getBrowser = function() { return this.parsedResult.browser ? this.parsedResult.browser : this.parseBrowser() }, p.getBrowserName = function(u) { return u ? String(this.getBrowser().name).toLowerCase() || '' : this.getBrowser().name || '' }, p.getBrowserVersion = function() { return this.getBrowser().version }, p.getOS = function() { return this.parsedResult.os ? this.parsedResult.os : this.parseOS() }, p.parseOS = function() { var u = this; this.parsedResult.os = {}; var h = a.default.find(i.default, function(f) { if (typeof f.test === 'function') return f.test(u); if (f.test instanceof Array) return f.test.some(function(_) { return u.test(_) }); throw new Error("Browser's test function is not valid") }); return h && (this.parsedResult.os = h.describe(this.getUA())), this.parsedResult.os }, p.getOSName = function(u) { var h = this.getOS().name; return u ? String(h).toLowerCase() || '' : h || '' }, p.getOSVersion = function() { return this.getOS().version }, p.getPlatform = function() { return this.parsedResult.platform ? this.parsedResult.platform : this.parsePlatform() }, p.getPlatformType = function(u) { u === void 0 && (u = !1); var h = this.getPlatform().type; return u ? String(h).toLowerCase() || '' : h || '' }, p.parsePlatform = function() { var u = this; this.parsedResult.platform = {}; var h = a.default.find(n.default, function(f) { if (typeof f.test === 'function') return f.test(u); if (f.test instanceof Array) return f.test.some(function(_) { return u.test(_) }); throw new Error("Browser's test function is not valid") }); return h && (this.parsedResult.platform = h.describe(this.getUA())), this.parsedResult.platform }, p.getEngine = function() { return this.parsedResult.engine ? this.parsedResult.engine : this.parseEngine() }, p.getEngineName = function(u) { return u ? String(this.getEngine().name).toLowerCase() || '' : this.getEngine().name || '' }, p.parseEngine = function() { var u = this; this.parsedResult.engine = {}; var h = a.default.find(c.default, function(f) { if (typeof f.test === 'function') return f.test(u); if (f.test instanceof Array) return f.test.some(function(_) { return u.test(_) }); throw new Error("Browser's test function is not valid") }); return h && (this.parsedResult.engine = h.describe(this.getUA())), this.parsedResult.engine }, p.parse = function() { return this.parseBrowser(), this.parseOS(), this.parsePlatform(), this.parseEngine(), this }, p.getResult = function() { return a.default.assign({}, this.parsedResult) }, p.satisfies = function(u) { var h = this; var f = {}; var _ = 0; var g = {}; var k = 0; if (Object.keys(u).forEach(function(H) { var st = u[H]; typeof st === 'string' ? (g[H] = st, k += 1) : typeof st === 'object' && (f[H] = st, _ += 1) }), _ > 0) { var I = Object.keys(f); var V = a.default.find(I, function(H) { return h.isOS(H) }); if (V) { var Oe = this.satisfies(f[V]); if (Oe !== void 0) return Oe } var Ne = a.default.find(I, function(H) { return h.isPlatform(H) }); if (Ne) { var Ue = this.satisfies(f[Ne]); if (Ue !== void 0) return Ue } } if (k > 0) { var rt = Object.keys(g); var Ot = a.default.find(rt, function(H) { return h.isBrowser(H, !0) }); if (Ot !== void 0) return this.compareVersion(g[Ot]) } }, p.isBrowser = function(u, h) { h === void 0 && (h = !1); var f = this.getBrowserName().toLowerCase(); var _ = u.toLowerCase(); var g = a.default.getBrowserTypeByAlias(_); return h && g && (_ = g.toLowerCase()), _ === f }, p.compareVersion = function(u) { var h = [0]; var f = u; var _ = !1; var g = this.getBrowserVersion(); if (typeof g === 'string') return u[0] === '>' || u[0] === '<' ? (f = u.substr(1), u[1] === '=' ? (_ = !0, f = u.substr(2)) : h = [], u[0] === '>' ? h.push(1) : h.push(-1)) : u[0] === '=' ? f = u.substr(1) : u[0] === '~' && (_ = !0, f = u.substr(1)), h.indexOf(a.default.compareVersions(g, f, _)) > -1 }, p.isOS = function(u) { return this.getOSName(!0) === String(u).toLowerCase() }, p.isPlatform = function(u) { return this.getPlatformType(!0) === String(u).toLowerCase() }, p.isEngine = function(u) { return this.getEngineName(!0) === String(u).toLowerCase() }, p.is = function(u, h) { return h === void 0 && (h = !1), this.isBrowser(u, h) || this.isOS(u) || this.isPlatform(u) }, p.some = function(u) { var h = this; return u === void 0 && (u = []), u.some(function(f) { return h.is(f) }) }, l }()); e.default = d, s.exports = e.default }, 92: function(s, e, t) { 'use strict'; e.__esModule = !0, e.default = void 0; var r; var i = (r = t(17)) && r.__esModule ? r : { default: r }; var n = /version\/(\d+(\.?_?\d+)+)/i; var c = [{ test: [/googlebot/i], describe: function(a) { var o = { name: 'Googlebot' }; var d = i.default.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, a) || i.default.getFirstMatch(n, a); return d && (o.version = d), o } }, { test: [/opera/i], describe: function(a) { var o = { name: 'Opera' }; var d = i.default.getFirstMatch(n, a) || i.default.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, a); return d && (o.version = d), o } }, { test: [/opr\/|opios/i], describe: function(a) { var o = { name: 'Opera' }; var d = i.default.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, a) || i.default.getFirstMatch(n, a); return d && (o.version = d), o } }, { test: [/SamsungBrowser/i], describe: function(a) { var o = { name: 'Samsung Internet for Android' }; var d = i.default.getFirstMatch(n, a) || i.default.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, a); return d && (o.version = d), o } }, { test: [/Whale/i], describe: function(a) { var o = { name: 'NAVER Whale Browser' }; var d = i.default.getFirstMatch(n, a) || i.default.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, a); return d && (o.version = d), o } }, { test: [/MZBrowser/i], describe: function(a) { var o = { name: 'MZ Browser' }; var d = i.default.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, a) || i.default.getFirstMatch(n, a); return d && (o.version = d), o } }, { test: [/focus/i], describe: function(a) { var o = { name: 'Focus' }; var d = i.default.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, a) || i.default.getFirstMatch(n, a); return d && (o.version = d), o } }, { test: [/swing/i], describe: function(a) { var o = { name: 'Swing' }; var d = i.default.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, a) || i.default.getFirstMatch(n, a); return d && (o.version = d), o } }, { test: [/coast/i], describe: function(a) { var o = { name: 'Opera Coast' }; var d = i.default.getFirstMatch(n, a) || i.default.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, a); return d && (o.version = d), o } }, { test: [/opt\/\d+(?:.?_?\d+)+/i], describe: function(a) { var o = { name: 'Opera Touch' }; var d = i.default.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, a) || i.default.getFirstMatch(n, a); return d && (o.version = d), o } }, { test: [/yabrowser/i], describe: function(a) { var o = { name: 'Yandex Browser' }; var d = i.default.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, a) || i.default.getFirstMatch(n, a); return d && (o.version = d), o } }, { test: [/ucbrowser/i], describe: function(a) { var o = { name: 'UC Browser' }; var d = i.default.getFirstMatch(n, a) || i.default.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, a); return d && (o.version = d), o } }, { test: [/Maxthon|mxios/i], describe: function(a) { var o = { name: 'Maxthon' }; var d = i.default.getFirstMatch(n, a) || i.default.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, a); return d && (o.version = d), o } }, { test: [/epiphany/i], describe: function(a) { var o = { name: 'Epiphany' }; var d = i.default.getFirstMatch(n, a) || i.default.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, a); return d && (o.version = d), o } }, { test: [/puffin/i], describe: function(a) { var o = { name: 'Puffin' }; var d = i.default.getFirstMatch(n, a) || i.default.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, a); return d && (o.version = d), o } }, { test: [/sleipnir/i], describe: function(a) { var o = { name: 'Sleipnir' }; var d = i.default.getFirstMatch(n, a) || i.default.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, a); return d && (o.version = d), o } }, { test: [/k-meleon/i], describe: function(a) { var o = { name: 'K-Meleon' }; var d = i.default.getFirstMatch(n, a) || i.default.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, a); return d && (o.version = d), o } }, { test: [/micromessenger/i], describe: function(a) { var o = { name: 'WeChat' }; var d = i.default.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, a) || i.default.getFirstMatch(n, a); return d && (o.version = d), o } }, { test: [/qqbrowser/i], describe: function(a) { var o = { name: /qqbrowserlite/i.test(a) ? 'QQ Browser Lite' : 'QQ Browser' }; var d = i.default.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, a) || i.default.getFirstMatch(n, a); return d && (o.version = d), o } }, { test: [/msie|trident/i], describe: function(a) { var o = { name: 'Internet Explorer' }; var d = i.default.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, a); return d && (o.version = d), o } }, { test: [/\sedg\//i], describe: function(a) { var o = { name: 'Microsoft Edge' }; var d = i.default.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, a); return d && (o.version = d), o } }, { test: [/edg([ea]|ios)/i], describe: function(a) { var o = { name: 'Microsoft Edge' }; var d = i.default.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, a); return d && (o.version = d), o } }, { test: [/vivaldi/i], describe: function(a) { var o = { name: 'Vivaldi' }; var d = i.default.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, a); return d && (o.version = d), o } }, { test: [/seamonkey/i], describe: function(a) { var o = { name: 'SeaMonkey' }; var d = i.default.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, a); return d && (o.version = d), o } }, { test: [/sailfish/i], describe: function(a) { var o = { name: 'Sailfish' }; var d = i.default.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, a); return d && (o.version = d), o } }, { test: [/silk/i], describe: function(a) { var o = { name: 'Amazon Silk' }; var d = i.default.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, a); return d && (o.version = d), o } }, { test: [/phantom/i], describe: function(a) { var o = { name: 'PhantomJS' }; var d = i.default.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, a); return d && (o.version = d), o } }, { test: [/slimerjs/i], describe: function(a) { var o = { name: 'SlimerJS' }; var d = i.default.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, a); return d && (o.version = d), o } }, { test: [/blackberry|\bbb\d+/i, /rim\stablet/i], describe: function(a) { var o = { name: 'BlackBerry' }; var d = i.default.getFirstMatch(n, a) || i.default.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, a); return d && (o.version = d), o } }, { test: [/(web|hpw)[o0]s/i], describe: function(a) { var o = { name: 'WebOS Browser' }; var d = i.default.getFirstMatch(n, a) || i.default.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, a); return d && (o.version = d), o } }, { test: [/bada/i], describe: function(a) { var o = { name: 'Bada' }; var d = i.default.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, a); return d && (o.version = d), o } }, { test: [/tizen/i], describe: function(a) { var o = { name: 'Tizen' }; var d = i.default.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, a) || i.default.getFirstMatch(n, a); return d && (o.version = d), o } }, { test: [/qupzilla/i], describe: function(a) { var o = { name: 'QupZilla' }; var d = i.default.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, a) || i.default.getFirstMatch(n, a); return d && (o.version = d), o } }, { test: [/firefox|iceweasel|fxios/i], describe: function(a) { var o = { name: 'Firefox' }; var d = i.default.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, a); return d && (o.version = d), o } }, { test: [/electron/i], describe: function(a) { var o = { name: 'Electron' }; var d = i.default.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, a); return d && (o.version = d), o } }, { test: [/MiuiBrowser/i], describe: function(a) { var o = { name: 'Miui' }; var d = i.default.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, a); return d && (o.version = d), o } }, { test: [/chromium/i], describe: function(a) { var o = { name: 'Chromium' }; var d = i.default.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, a) || i.default.getFirstMatch(n, a); return d && (o.version = d), o } }, { test: [/chrome|crios|crmo/i], describe: function(a) { var o = { name: 'Chrome' }; var d = i.default.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, a); return d && (o.version = d), o } }, { test: [/GSA/i], describe: function(a) { var o = { name: 'Google Search' }; var d = i.default.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, a); return d && (o.version = d), o } }, { test: function(a) { var o = !a.test(/like android/i); var d = a.test(/android/i); return o && d }, describe: function(a) { var o = { name: 'Android Browser' }; var d = i.default.getFirstMatch(n, a); return d && (o.version = d), o } }, { test: [/playstation 4/i], describe: function(a) { var o = { name: 'PlayStation 4' }; var d = i.default.getFirstMatch(n, a); return d && (o.version = d), o } }, { test: [/safari|applewebkit/i], describe: function(a) { var o = { name: 'Safari' }; var d = i.default.getFirstMatch(n, a); return d && (o.version = d), o } }, { test: [/.*/i], describe: function(a) { var o = a.search('\\(') !== -1 ? /^(.*)\/(.*)[ \t]\((.*)/ : /^(.*)\/(.*) /; return { name: i.default.getFirstMatch(o, a), version: i.default.getSecondMatch(o, a) } } }]; e.default = c, s.exports = e.default }, 93: function(s, e, t) { 'use strict'; e.__esModule = !0, e.default = void 0; var r; var i = (r = t(17)) && r.__esModule ? r : { default: r }; var n = t(18); var c = [{ test: [/Roku\/DVP/], describe: function(a) { var o = i.default.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, a); return { name: n.OS_MAP.Roku, version: o } } }, { test: [/windows phone/i], describe: function(a) { var o = i.default.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, a); return { name: n.OS_MAP.WindowsPhone, version: o } } }, { test: [/windows /i], describe: function(a) { var o = i.default.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, a); var d = i.default.getWindowsVersionName(o); return { name: n.OS_MAP.Windows, version: o, versionName: d } } }, { test: [/Macintosh(.*?) FxiOS(.*?)\//], describe: function(a) { var o = { name: n.OS_MAP.iOS }; var d = i.default.getSecondMatch(/(Version\/)(\d[\d.]+)/, a); return d && (o.version = d), o } }, { test: [/macintosh/i], describe: function(a) { var o = i.default.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, a).replace(/[_\s]/g, '.'); var d = i.default.getMacOSVersionName(o); var l = { name: n.OS_MAP.MacOS, version: o }; return d && (l.versionName = d), l } }, { test: [/(ipod|iphone|ipad)/i], describe: function(a) { var o = i.default.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, a).replace(/[_\s]/g, '.'); return { name: n.OS_MAP.iOS, version: o } } }, { test: function(a) { var o = !a.test(/like android/i); var d = a.test(/android/i); return o && d }, describe: function(a) { var o = i.default.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, a); var d = i.default.getAndroidVersionName(o); var l = { name: n.OS_MAP.Android, version: o }; return d && (l.versionName = d), l } }, { test: [/(web|hpw)[o0]s/i], describe: function(a) { var o = i.default.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, a); var d = { name: n.OS_MAP.WebOS }; return o && o.length && (d.version = o), d } }, { test: [/blackberry|\bbb\d+/i, /rim\stablet/i], describe: function(a) { var o = i.default.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, a) || i.default.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, a) || i.default.getFirstMatch(/\bbb(\d+)/i, a); return { name: n.OS_MAP.BlackBerry, version: o } } }, { test: [/bada/i], describe: function(a) { var o = i.default.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, a); return { name: n.OS_MAP.Bada, version: o } } }, { test: [/tizen/i], describe: function(a) { var o = i.default.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, a); return { name: n.OS_MAP.Tizen, version: o } } }, { test: [/linux/i], describe: function() { return { name: n.OS_MAP.Linux } } }, { test: [/CrOS/], describe: function() { return { name: n.OS_MAP.ChromeOS } } }, { test: [/PlayStation 4/], describe: function(a) { var o = i.default.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, a); return { name: n.OS_MAP.PlayStation4, version: o } } }]; e.default = c, s.exports = e.default }, 94: function(s, e, t) { 'use strict'; e.__esModule = !0, e.default = void 0; var r; var i = (r = t(17)) && r.__esModule ? r : { default: r }; var n = t(18); var c = [{ test: [/googlebot/i], describe: function() { return { type: 'bot', vendor: 'Google' } } }, { test: [/huawei/i], describe: function(a) { var o = i.default.getFirstMatch(/(can-l01)/i, a) && 'Nova'; var d = { type: n.PLATFORMS_MAP.mobile, vendor: 'Huawei' }; return o && (d.model = o), d } }, { test: [/nexus\s*(?:7|8|9|10).*/i], describe: function() { return { type: n.PLATFORMS_MAP.tablet, vendor: 'Nexus' } } }, { test: [/ipad/i], describe: function() { return { type: n.PLATFORMS_MAP.tablet, vendor: 'Apple', model: 'iPad' } } }, { test: [/Macintosh(.*?) FxiOS(.*?)\//], describe: function() { return { type: n.PLATFORMS_MAP.tablet, vendor: 'Apple', model: 'iPad' } } }, { test: [/kftt build/i], describe: function() { return { type: n.PLATFORMS_MAP.tablet, vendor: 'Amazon', model: 'Kindle Fire HD 7' } } }, { test: [/silk/i], describe: function() { return { type: n.PLATFORMS_MAP.tablet, vendor: 'Amazon' } } }, { test: [/tablet(?! pc)/i], describe: function() { return { type: n.PLATFORMS_MAP.tablet } } }, { test: function(a) { var o = a.test(/ipod|iphone/i); var d = a.test(/like (ipod|iphone)/i); return o && !d }, describe: function(a) { var o = i.default.getFirstMatch(/(ipod|iphone)/i, a); return { type: n.PLATFORMS_MAP.mobile, vendor: 'Apple', model: o } } }, { test: [/nexus\s*[0-6].*/i, /galaxy nexus/i], describe: function() { return { type: n.PLATFORMS_MAP.mobile, vendor: 'Nexus' } } }, { test: [/[^-]mobi/i], describe: function() { return { type: n.PLATFORMS_MAP.mobile } } }, { test: function(a) { return a.getBrowserName(!0) === 'blackberry' }, describe: function() { return { type: n.PLATFORMS_MAP.mobile, vendor: 'BlackBerry' } } }, { test: function(a) { return a.getBrowserName(!0) === 'bada' }, describe: function() { return { type: n.PLATFORMS_MAP.mobile } } }, { test: function(a) { return a.getBrowserName() === 'windows phone' }, describe: function() { return { type: n.PLATFORMS_MAP.mobile, vendor: 'Microsoft' } } }, { test: function(a) { var o = Number(String(a.getOSVersion()).split('.')[0]); return a.getOSName(!0) === 'android' && o >= 3 }, describe: function() { return { type: n.PLATFORMS_MAP.tablet } } }, { test: function(a) { return a.getOSName(!0) === 'android' }, describe: function() { return { type: n.PLATFORMS_MAP.mobile } } }, { test: function(a) { return a.getOSName(!0) === 'macos' }, describe: function() { return { type: n.PLATFORMS_MAP.desktop, vendor: 'Apple' } } }, { test: function(a) { return a.getOSName(!0) === 'windows' }, describe: function() { return { type: n.PLATFORMS_MAP.desktop } } }, { test: function(a) { return a.getOSName(!0) === 'linux' }, describe: function() { return { type: n.PLATFORMS_MAP.desktop } } }, { test: function(a) { return a.getOSName(!0) === 'playstation 4' }, describe: function() { return { type: n.PLATFORMS_MAP.tv } } }, { test: function(a) { return a.getOSName(!0) === 'roku' }, describe: function() { return { type: n.PLATFORMS_MAP.tv } } }]; e.default = c, s.exports = e.default }, 95: function(s, e, t) { 'use strict'; e.__esModule = !0, e.default = void 0; var r; var i = (r = t(17)) && r.__esModule ? r : { default: r }; var n = t(18); var c = [{ test: function(a) { return a.getBrowserName(!0) === 'microsoft edge' }, describe: function(a) { if (/\sedg\//i.test(a)) return { name: n.ENGINE_MAP.Blink }; var o = i.default.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, a); return { name: n.ENGINE_MAP.EdgeHTML, version: o } } }, { test: [/trident/i], describe: function(a) { var o = { name: n.ENGINE_MAP.Trident }; var d = i.default.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, a); return d && (o.version = d), o } }, { test: function(a) { return a.test(/presto/i) }, describe: function(a) { var o = { name: n.ENGINE_MAP.Presto }; var d = i.default.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, a); return d && (o.version = d), o } }, { test: function(a) { var o = a.test(/gecko/i); var d = a.test(/like gecko/i); return o && !d }, describe: function(a) { var o = { name: n.ENGINE_MAP.Gecko }; var d = i.default.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, a); return d && (o.version = d), o } }, { test: [/(apple)?webkit\/537\.36/i], describe: function() { return { name: n.ENGINE_MAP.Blink } } }, { test: [/(apple)?webkit/i], describe: function(a) { var o = { name: n.ENGINE_MAP.WebKit }; var d = i.default.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, a); return d && (o.version = d), o } }]; e.default = c, s.exports = e.default } })) }) }); var A = m(ft => { 'use strict'; var bd = ft && ft.__importDefault || function(s) { return s && s.__esModule ? s : { default: s } }; Object.defineProperty(ft, '__esModule', { value: !0 }); ft.Logger = void 0; var ut = bd(J()); var ht = 'mediasoup-client'; var Mn = class {constructor(e) { e ? (this._debug = ut.default(`${ht}:${e}`), this._warn = ut.default(`${ht}:WARN:${e}`), this._error = ut.default(`${ht}:ERROR:${e}`)) : (this._debug = ut.default(ht), this._warn = ut.default(`${ht}:WARN`), this._error = ut.default(`${ht}:ERROR`)), this._debug.log = console.info.bind(console), this._warn.log = console.warn.bind(console), this._error.log = console.error.bind(console) } get debug() { return this._debug } get warn() { return this._warn } get error() { return this._error }}; ft.Logger = Mn }); var Nn = m((Ch, Ds) => { 'use strict'; var mt = typeof Reflect === 'object' ? Reflect : null; var kn = mt && typeof mt.apply === 'function' ? mt.apply : function(e, t, r) { return Function.prototype.apply.call(e, t, r) }; var vr; mt && typeof mt.ownKeys === 'function' ? vr = mt.ownKeys : Object.getOwnPropertySymbols ? vr = function(e) { return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e)) } : vr = function(e) { return Object.getOwnPropertyNames(e) }; function wd(s) { console && console.warn && console.warn(s) } var xn = Number.isNaN || function(e) { return e !== e }; function M() { M.init.call(this) }Ds.exports = M; Ds.exports.once = Td; M.EventEmitter = M; M.prototype._events = void 0; M.prototype._eventsCount = 0; M.prototype._maxListeners = void 0; var On = 10; function yr(s) { if (typeof s !== 'function') throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof s) }Object.defineProperty(M, 'defaultMaxListeners', { enumerable: !0, get: function() { return On }, set: function(s) { if (typeof s !== 'number' || s < 0 || xn(s)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + s + '.'); On = s } }); M.init = function() { (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0 }; M.prototype.setMaxListeners = function(e) { if (typeof e !== 'number' || e < 0 || xn(e)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + '.'); return this._maxListeners = e, this }; function Ln(s) { return s._maxListeners === void 0 ? M.defaultMaxListeners : s._maxListeners }M.prototype.getMaxListeners = function() { return Ln(this) }; M.prototype.emit = function(e) { for (var t = [], r = 1; r < arguments.length; r++)t.push(arguments[r]); var i = e === 'error'; var n = this._events; if (n !== void 0)i = i && n.error === void 0; else if (!i) return !1; if (i) { var c; if (t.length > 0 && (c = t[0]), c instanceof Error) throw c; var a = new Error('Unhandled error.' + (c ? ' (' + c.message + ')' : '')); throw a.context = c, a } var o = n[e]; if (o === void 0) return !1; if (typeof o === 'function')kn(o, this, t); else for (var d = o.length, l = qn(o, d), r = 0; r < d; ++r)kn(l[r], this, t); return !0 }; function In(s, e, t, r) { var i, n, c; if (yr(t), n = s._events, n === void 0 ? (n = s._events = Object.create(null), s._eventsCount = 0) : (n.newListener !== void 0 && (s.emit('newListener', e, t.listener ? t.listener : t), n = s._events), c = n[e]), c === void 0)c = n[e] = t, ++s._eventsCount; else if (typeof c === 'function' ? c = n[e] = r ? [t, c] : [c, t] : r ? c.unshift(t) : c.push(t), i = Ln(s), i > 0 && c.length > i && !c.warned) { c.warned = !0; var a = new Error('Possible EventEmitter memory leak detected. ' + c.length + ' ' + String(e) + ' listeners added. Use emitter.setMaxListeners() to increase limit'); a.name = 'MaxListenersExceededWarning', a.emitter = s, a.type = e, a.count = c.length, wd(a) } return s }M.prototype.addListener = function(e, t) { return In(this, e, t, !1) }; M.prototype.on = M.prototype.addListener; M.prototype.prependListener = function(e, t) { return In(this, e, t, !0) }; function Sd() { if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments) } function An(s, e, t) { var r = { fired: !1, wrapFn: void 0, target: s, type: e, listener: t }; var i = Sd.bind(r); return i.listener = t, r.wrapFn = i, i }M.prototype.once = function(e, t) { return yr(t), this.on(e, An(this, e, t)), this }; M.prototype.prependOnceListener = function(e, t) { return yr(t), this.prependListener(e, An(this, e, t)), this }; M.prototype.removeListener = function(e, t) { var r, i, n, c, a; if (yr(t), i = this._events, i === void 0) return this; if (r = i[e], r === void 0) return this; if (r === t || r.listener === t)--this._eventsCount == 0 ? this._events = Object.create(null) : (delete i[e], i.removeListener && this.emit('removeListener', e, r.listener || t)); else if (typeof r !== 'function') { for (n = -1, c = r.length - 1; c >= 0; c--) if (r[c] === t || r[c].listener === t) { a = r[c].listener, n = c; break } if (n < 0) return this; n === 0 ? r.shift() : Rd(r, n), r.length === 1 && (i[e] = r[0]), i.removeListener !== void 0 && this.emit('removeListener', e, a || t) } return this }; M.prototype.off = M.prototype.removeListener; M.prototype.removeAllListeners = function(e) { var t, r, i; if (r = this._events, r === void 0) return this; if (r.removeListener === void 0) return arguments.length === 0 ? (this._events = Object.create(null), this._eventsCount = 0) : r[e] !== void 0 && (--this._eventsCount == 0 ? this._events = Object.create(null) : delete r[e]), this; if (arguments.length === 0) { var n = Object.keys(r); var c; for (i = 0; i < n.length; ++i)c = n[i], c !== 'removeListener' && this.removeAllListeners(c); return this.removeAllListeners('removeListener'), this._events = Object.create(null), this._eventsCount = 0, this } if (t = r[e], typeof t === 'function') this.removeListener(e, t); else if (t !== void 0) for (i = t.length - 1; i >= 0; i--) this.removeListener(e, t[i]); return this }; function jn(s, e, t) { var r = s._events; if (r === void 0) return []; var i = r[e]; return i === void 0 ? [] : typeof i === 'function' ? t ? [i.listener || i] : [i] : t ? Cd(i) : qn(i, i.length) }M.prototype.listeners = function(e) { return jn(this, e, !0) }; M.prototype.rawListeners = function(e) { return jn(this, e, !1) }; M.listenerCount = function(s, e) { return typeof s.listenerCount === 'function' ? s.listenerCount(e) : Bn.call(s, e) }; M.prototype.listenerCount = Bn; function Bn(s) { var e = this._events; if (e !== void 0) { var t = e[s]; if (typeof t === 'function') return 1; if (t !== void 0) return t.length } return 0 }M.prototype.eventNames = function() { return this._eventsCount > 0 ? vr(this._events) : [] }; function qn(s, e) { for (var t = new Array(e), r = 0; r < e; ++r)t[r] = s[r]; return t } function Rd(s, e) { for (;e + 1 < s.length; e++)s[e] = s[e + 1]; s.pop() } function Cd(s) { for (var e = new Array(s.length), t = 0; t < e.length; ++t)e[t] = s[t].listener || s[t]; return e } function Td(s, e) { return new Promise(function(t, r) { function i(c) { s.removeListener(e, n), r(c) } function n() { typeof s.removeListener === 'function' && s.removeListener('error', i), t([].slice.call(arguments)) }Fn(s, e, n, { once: !0 }), e !== 'error' && Pd(s, i, { once: !0 }) }) } function Pd(s, e, t) { typeof s.on === 'function' && Fn(s, 'error', e, t) } function Fn(s, e, t, r) { if (typeof s.on === 'function')r.once ? s.once(e, t) : s.on(e, t); else if (typeof s.addEventListener === 'function')s.addEventListener(e, function i(n) { r.once && s.removeEventListener(e, i), t(n) }); else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof s) } }); var Ve = m(br => { 'use strict'; Object.defineProperty(br, '__esModule', { value: !0 }); br.EnhancedEventEmitter = void 0; var Ed = Nn(); var Dd = A(); var Un = new Dd.Logger('EnhancedEventEmitter'); var zn = class extends Ed.EventEmitter {constructor() { super(); this.setMaxListeners(Infinity) }safeEmit(e, ...t) { const r = this.listenerCount(e); try { return this.emit(e, ...t) } catch (i) { return Un.error('safeEmit() | event listener threw an error [event:%s]:%o', e, i), Boolean(r) } } async safeEmitAsPromise(e, ...t) { return new Promise((r, i) => { try { this.emit(e, ...t, r, i) } catch (n) { Un.error('safeEmitAsPromise() | event listener threw an error [event:%s]:%o', e, n), i(n) } }) }}; br.EnhancedEventEmitter = zn }); var oe = m(gt => { 'use strict'; Object.defineProperty(gt, '__esModule', { value: !0 }); gt.InvalidStateError = gt.UnsupportedError = void 0; var wr = class extends Error {constructor(e) { super(e); this.name = 'UnsupportedError', Error.hasOwnProperty('captureStackTrace') ? Error.captureStackTrace(this, wr) : this.stack = new Error(e).stack }}; gt.UnsupportedError = wr; var Sr = class extends Error {constructor(e) { super(e); this.name = 'InvalidStateError', Error.hasOwnProperty('captureStackTrace') ? Error.captureStackTrace(this, Sr) : this.stack = new Error(e).stack }}; gt.InvalidStateError = Sr }); var $ = m(_t => { 'use strict'; Object.defineProperty(_t, '__esModule', { value: !0 }); _t.generateRandomNumber = _t.clone = void 0; function Md(s, e) { return typeof s === 'undefined' ? e : JSON.parse(JSON.stringify(s)) }_t.clone = Md; function kd() { return Math.round(Math.random() * 1e7) }_t.generateRandomNumber = kd }); var ia = m(y => { var Ye = J()('h264-profile-level-id'); Ye.log = console.info.bind(console); var Xe = 1; var Bt = 2; var Rr = 3; var Ms = 4; var ks = 5; y.ProfileConstrainedBaseline = Xe; y.ProfileBaseline = Bt; y.ProfileMain = Rr; y.ProfileConstrainedHigh = Ms; y.ProfileHigh = ks; var vt = 0; var Cr = 10; var xs = 11; var Vn = 12; var $n = 13; var Hn = 20; var Kn = 21; var Gn = 22; var Wn = 30; var Os = 31; var Qn = 32; var Jn = 40; var Yn = 41; var Xn = 42; var Zn = 50; var ea = 51; var ta = 52; y.Level1_b = vt; y.Level1 = Cr; y.Level1_1 = xs; y.Level1_2 = Vn; y.Level1_3 = $n; y.Level2 = Hn; y.Level2_1 = Kn; y.Level2_2 = Gn; y.Level3 = Wn; y.Level3_1 = Os; y.Level3_2 = Qn; y.Level4 = Jn; y.Level4_1 = Yn; y.Level4_2 = Xn; y.Level5 = Zn; y.Level5_1 = ea; y.Level5_2 = ta; var qt = class {constructor(e, t) { this.profile = e, this.level = t }}; y.ProfileLevelId = qt; var xd = new qt(Xe, Os); var Od = 16; var Le = class {constructor(e) { this._mask = ~ra('x', e), this._maskedValue = ra('1', e) }isMatch(e) { return this._maskedValue === (e & this._mask) }}; var Ie = class {constructor(e, t, r) { this.profile_idc = e, this.profile_iop = t, this.profile = r }}; var Ld = [new Ie(66, new Le('x1xx0000'), Xe), new Ie(77, new Le('1xxx0000'), Xe), new Ie(88, new Le('11xx0000'), Xe), new Ie(66, new Le('x0xx0000'), Bt), new Ie(88, new Le('10xx0000'), Bt), new Ie(77, new Le('0x0x0000'), Rr), new Ie(100, new Le('00000000'), ks), new Ie(100, new Le('00001100'), Ms)]; y.parseProfileLevelId = function(s) { if (typeof s !== 'string' || s.length !== 6) return null; const e = parseInt(s, 16); if (e === 0) return null; const t = e & 255; const r = e >> 8 & 255; const i = e >> 16 & 255; let n; switch (t) { case xs: { n = (r & Od) != 0 ? vt : xs; break } case Cr:case Vn:case $n:case Hn:case Kn:case Gn:case Wn:case Os:case Qn:case Jn:case Yn:case Xn:case Zn:case ea:case ta: { n = t; break } default:return Ye('parseProfileLevelId() | unrecognized level_idc:%s', t), null } for (const c of Ld) if (i === c.profile_idc && c.profile_iop.isMatch(r)) return new qt(c.profile, n); return Ye('parseProfileLevelId() | unrecognized profile_idc/profile_iop combination'), null }; y.profileLevelIdToString = function(s) { if (s.level == vt) switch (s.profile) { case Xe:return '42f00b'; case Bt:return '42100b'; case Rr:return '4d100b'; default:return Ye('profileLevelIdToString() | Level 1_b not is allowed for profile:%s', s.profile), null }let e; switch (s.profile) { case Xe: { e = '42e0'; break } case Bt: { e = '4200'; break } case Rr: { e = '4d00'; break } case Ms: { e = '640c'; break } case ks: { e = '6400'; break } default:return Ye('profileLevelIdToString() | unrecognized profile:%s', s.profile), null }let t = s.level.toString(16); return t.length === 1 && (t = `0${t}`), `${e}${t}` }; y.parseSdpProfileLevelId = function(s = {}) { const e = s['profile-level-id']; return e ? y.parseProfileLevelId(e) : xd }; y.isSameProfile = function(s = {}, e = {}) { const t = y.parseSdpProfileLevelId(s); const r = y.parseSdpProfileLevelId(e); return Boolean(t && r && t.profile === r.profile) }; y.generateProfileLevelIdForAnswer = function(s = {}, e = {}) { if (!s['profile-level-id'] && !e['profile-level-id']) return Ye('generateProfileLevelIdForAnswer() | no profile-level-id in local and remote params'), null; const t = y.parseSdpProfileLevelId(s); const r = y.parseSdpProfileLevelId(e); if (!t) throw new TypeError('invalid local_profile_level_id'); if (!r) throw new TypeError('invalid remote_profile_level_id'); if (t.profile !== r.profile) throw new TypeError('H264 Profile mismatch'); const i = sa(s) && sa(e); const n = t.level; const c = r.level; const a = Ad(n, c); const o = i ? n : a; return Ye('generateProfileLevelIdForAnswer() | result: [profile:%s, level:%s]', t.profile, o), y.profileLevelIdToString(new qt(t.profile, o)) }; function ra(s, e) { return (e[0] === s) << 7 | (e[1] === s) << 6 | (e[2] === s) << 5 | (e[3] === s) << 4 | (e[4] === s) << 3 | (e[5] === s) << 2 | (e[6] === s) << 1 | (e[7] === s) << 0 } function Id(s, e) { return s === vt ? e !== Cr && e !== vt : e === vt ? s !== Cr : s < e } function Ad(s, e) { return Id(s, e) ? s : e } function sa(s = {}) { const e = s['level-asymmetry-allowed']; return e === 1 || e === '1' } }); var te = m(v => { 'use strict'; var jd = v && v.__createBinding || (Object.create ? function(s, e, t, r) { r === void 0 && (r = t), Object.defineProperty(s, r, { enumerable: !0, get: function() { return e[t] } }) } : function(s, e, t, r) { r === void 0 && (r = t), s[r] = e[t] }); var Bd = v && v.__setModuleDefault || (Object.create ? function(s, e) { Object.defineProperty(s, 'default', { enumerable: !0, value: e }) } : function(s, e) { s.default = e }); var na = v && v.__importStar || function(s) { if (s && s.__esModule) return s; var e = {}; if (s != null) for (var t in s)t !== 'default' && Object.hasOwnProperty.call(s, t) && jd(e, s, t); return Bd(e, s), e }; Object.defineProperty(v, '__esModule', { value: !0 }); v.canReceive = v.canSend = v.generateProbatorRtpParameters = v.reduceCodecs = v.getSendingRemoteRtpParameters = v.getSendingRtpParameters = v.getRecvRtpCapabilities = v.getExtendedRtpCapabilities = v.validateSctpStreamParameters = v.validateSctpParameters = v.validateNumSctpStreams = v.validateSctpCapabilities = v.validateRtcpParameters = v.validateRtpEncodingParameters = v.validateRtpHeaderExtensionParameters = v.validateRtpCodecParameters = v.validateRtpParameters = v.validateRtpHeaderExtension = v.validateRtcpFeedback = v.validateRtpCodecCapability = v.validateRtpCapabilities = void 0; var aa = na(ia()); var qd = na($()); var Fd = 'probator'; var Nd = 1234; var Ud = 127; function zd(s) { if (typeof s !== 'object') throw new TypeError('caps is not an object'); if (s.codecs && !Array.isArray(s.codecs)) throw new TypeError('caps.codecs is not an array'); s.codecs || (s.codecs = []); for (const e of s.codecs)oa(e); if (s.headerExtensions && !Array.isArray(s.headerExtensions)) throw new TypeError('caps.headerExtensions is not an array'); s.headerExtensions || (s.headerExtensions = []); for (const e of s.headerExtensions)ca(e) }v.validateRtpCapabilities = zd; function oa(s) { const e = new RegExp('^(audio|video)/(.+)', 'i'); if (typeof s !== 'object') throw new TypeError('codec is not an object'); if (!s.mimeType || typeof s.mimeType !== 'string') throw new TypeError('missing codec.mimeType'); const t = e.exec(s.mimeType); if (!t) throw new TypeError('invalid codec.mimeType'); if (s.kind = t[1].toLowerCase(), s.preferredPayloadType && typeof s.preferredPayloadType !== 'number') throw new TypeError('invalid codec.preferredPayloadType'); if (typeof s.clockRate !== 'number') throw new TypeError('missing codec.clockRate'); s.kind === 'audio' ? typeof s.channels !== 'number' && (s.channels = 1) : delete s.channels, (!s.parameters || typeof s.parameters !== 'object') && (s.parameters = {}); for (const r of Object.keys(s.parameters)) { let i = s.parameters[r]; if (i === void 0 && (s.parameters[r] = '', i = ''), typeof i !== 'string' && typeof i !== 'number') throw new TypeError(`invalid codec parameter [key:${r}s, value:${i}]`); if (r === 'apt' && typeof i !== 'number') throw new TypeError('invalid codec apt parameter') }(!s.rtcpFeedback || !Array.isArray(s.rtcpFeedback)) && (s.rtcpFeedback = []); for (const r of s.rtcpFeedback)Ls(r) }v.validateRtpCodecCapability = oa; function Ls(s) { if (typeof s !== 'object') throw new TypeError('fb is not an object'); if (!s.type || typeof s.type !== 'string') throw new TypeError('missing fb.type'); (!s.parameter || typeof s.parameter !== 'string') && (s.parameter = '') }v.validateRtcpFeedback = Ls; function ca(s) { if (typeof s !== 'object') throw new TypeError('ext is not an object'); if ((!s.kind || typeof s.kind !== 'string') && (s.kind = ''), s.kind !== '' && s.kind !== 'audio' && s.kind !== 'video') throw new TypeError('invalid ext.kind'); if (!s.uri || typeof s.uri !== 'string') throw new TypeError('missing ext.uri'); if (typeof s.preferredId !== 'number') throw new TypeError('missing ext.preferredId'); if (s.preferredEncrypt && typeof s.preferredEncrypt !== 'boolean') throw new TypeError('invalid ext.preferredEncrypt'); if (s.preferredEncrypt || (s.preferredEncrypt = !1), s.direction && typeof s.direction !== 'string') throw new TypeError('invalid ext.direction'); s.direction || (s.direction = 'sendrecv') }v.validateRtpHeaderExtension = ca; function Is(s) { if (typeof s !== 'object') throw new TypeError('params is not an object'); if (s.mid && typeof s.mid !== 'string') throw new TypeError('params.mid is not a string'); if (!Array.isArray(s.codecs)) throw new TypeError('missing params.codecs'); for (const e of s.codecs)da(e); if (s.headerExtensions && !Array.isArray(s.headerExtensions)) throw new TypeError('params.headerExtensions is not an array'); s.headerExtensions || (s.headerExtensions = []); for (const e of s.headerExtensions)la(e); if (s.encodings && !Array.isArray(s.encodings)) throw new TypeError('params.encodings is not an array'); s.encodings || (s.encodings = []); for (const e of s.encodings)pa(e); if (s.rtcp && typeof s.rtcp !== 'object') throw new TypeError('params.rtcp is not an object'); s.rtcp || (s.rtcp = {}), ua(s.rtcp) }v.validateRtpParameters = Is; function da(s) { const e = new RegExp('^(audio|video)/(.+)', 'i'); if (typeof s !== 'object') throw new TypeError('codec is not an object'); if (!s.mimeType || typeof s.mimeType !== 'string') throw new TypeError('missing codec.mimeType'); const t = e.exec(s.mimeType); if (!t) throw new TypeError('invalid codec.mimeType'); if (typeof s.payloadType !== 'number') throw new TypeError('missing codec.payloadType'); if (typeof s.clockRate !== 'number') throw new TypeError('missing codec.clockRate'); t[1].toLowerCase() === 'audio' ? typeof s.channels !== 'number' && (s.channels = 1) : delete s.channels, (!s.parameters || typeof s.parameters !== 'object') && (s.parameters = {}); for (const i of Object.keys(s.parameters)) { let n = s.parameters[i]; if (n === void 0 && (s.parameters[i] = '', n = ''), typeof n !== 'string' && typeof n !== 'number') throw new TypeError(`invalid codec parameter [key:${i}s, value:${n}]`); if (i === 'apt' && typeof n !== 'number') throw new TypeError('invalid codec apt parameter') }(!s.rtcpFeedback || !Array.isArray(s.rtcpFeedback)) && (s.rtcpFeedback = []); for (const i of s.rtcpFeedback)Ls(i) }v.validateRtpCodecParameters = da; function la(s) { if (typeof s !== 'object') throw new TypeError('ext is not an object'); if (!s.uri || typeof s.uri !== 'string') throw new TypeError('missing ext.uri'); if (typeof s.id !== 'number') throw new TypeError('missing ext.id'); if (s.encrypt && typeof s.encrypt !== 'boolean') throw new TypeError('invalid ext.encrypt'); s.encrypt || (s.encrypt = !1), (!s.parameters || typeof s.parameters !== 'object') && (s.parameters = {}); for (const e of Object.keys(s.parameters)) { let t = s.parameters[e]; if (t === void 0 && (s.parameters[e] = '', t = ''), typeof t !== 'string' && typeof t !== 'number') throw new TypeError('invalid header extension parameter') } }v.validateRtpHeaderExtensionParameters = la; function pa(s) { if (typeof s !== 'object') throw new TypeError('encoding is not an object'); if (s.ssrc && typeof s.ssrc !== 'number') throw new TypeError('invalid encoding.ssrc'); if (s.rid && typeof s.rid !== 'string') throw new TypeError('invalid encoding.rid'); if (s.rtx && typeof s.rtx !== 'object') throw new TypeError('invalid encoding.rtx'); if (s.rtx && typeof s.rtx.ssrc !== 'number') throw new TypeError('missing encoding.rtx.ssrc'); if ((!s.dtx || typeof s.dtx !== 'boolean') && (s.dtx = !1), s.scalabilityMode && typeof s.scalabilityMode !== 'string') throw new TypeError('invalid encoding.scalabilityMode') }v.validateRtpEncodingParameters = pa; function ua(s) { if (typeof s !== 'object') throw new TypeError('rtcp is not an object'); if (s.cname && typeof s.cname !== 'string') throw new TypeError('invalid rtcp.cname'); (!s.reducedSize || typeof s.reducedSize !== 'boolean') && (s.reducedSize = !0) }v.validateRtcpParameters = ua; function Vd(s) { if (typeof s !== 'object') throw new TypeError('caps is not an object'); if (!s.numStreams || typeof s.numStreams !== 'object') throw new TypeError('missing caps.numStreams'); ha(s.numStreams) }v.validateSctpCapabilities = Vd; function ha(s) { if (typeof s !== 'object') throw new TypeError('numStreams is not an object'); if (typeof s.OS !== 'number') throw new TypeError('missing numStreams.OS'); if (typeof s.MIS !== 'number') throw new TypeError('missing numStreams.MIS') }v.validateNumSctpStreams = ha; function $d(s) { if (typeof s !== 'object') throw new TypeError('params is not an object'); if (typeof s.port !== 'number') throw new TypeError('missing params.port'); if (typeof s.OS !== 'number') throw new TypeError('missing params.OS'); if (typeof s.MIS !== 'number') throw new TypeError('missing params.MIS'); if (typeof s.maxMessageSize !== 'number') throw new TypeError('missing params.maxMessageSize') }v.validateSctpParameters = $d; function Hd(s) { if (typeof s !== 'object') throw new TypeError('params is not an object'); if (typeof s.streamId !== 'number') throw new TypeError('missing params.streamId'); let e = !1; if (typeof s.ordered === 'boolean' ? e = !0 : s.ordered = !0, s.maxPacketLifeTime && typeof s.maxPacketLifeTime !== 'number') throw new TypeError('invalid params.maxPacketLifeTime'); if (s.maxRetransmits && typeof s.maxRetransmits !== 'number') throw new TypeError('invalid params.maxRetransmits'); if (s.maxPacketLifeTime && s.maxRetransmits) throw new TypeError('cannot provide both maxPacketLifeTime and maxRetransmits'); if (e && s.ordered && (s.maxPacketLifeTime || s.maxRetransmits)) throw new TypeError('cannot be ordered with maxPacketLifeTime or maxRetransmits'); if (!e && (s.maxPacketLifeTime || s.maxRetransmits) && (s.ordered = !1), s.priority && typeof s.priority !== 'string') throw new TypeError('invalid params.priority'); if (s.label && typeof s.label !== 'string') throw new TypeError('invalid params.label'); if (s.protocol && typeof s.protocol !== 'string') throw new TypeError('invalid params.protocol') }v.validateSctpStreamParameters = Hd; function Kd(s, e) { const t = { codecs: [], headerExtensions: [] }; for (const r of e.codecs || []) { if (Ft(r)) continue; const i = (s.codecs || []).find(c => fa(c, r, { strict: !0, modify: !0 })); if (!i) continue; const n = { mimeType: i.mimeType, kind: i.kind, clockRate: i.clockRate, channels: i.channels, localPayloadType: i.preferredPayloadType, localRtxPayloadType: void 0, remotePayloadType: r.preferredPayloadType, remoteRtxPayloadType: void 0, localParameters: i.parameters, remoteParameters: r.parameters, rtcpFeedback: tl(i, r) }; t.codecs.push(n) } for (const r of t.codecs) { const i = s.codecs.find(c => Ft(c) && c.parameters.apt === r.localPayloadType); const n = e.codecs.find(c => Ft(c) && c.parameters.apt === r.remotePayloadType); i && n && (r.localRtxPayloadType = i.preferredPayloadType, r.remoteRtxPayloadType = n.preferredPayloadType) } for (const r of e.headerExtensions) { const i = s.headerExtensions.find(c => el(c, r)); if (!i) continue; const n = { kind: r.kind, uri: r.uri, sendId: i.preferredId, recvId: r.preferredId, encrypt: i.preferredEncrypt, direction: 'sendrecv' }; switch (r.direction) { case 'sendrecv':n.direction = 'sendrecv'; break; case 'recvonly':n.direction = 'sendonly'; break; case 'sendonly':n.direction = 'recvonly'; break; case 'inactive':n.direction = 'inactive'; break }t.headerExtensions.push(n) } return t }v.getExtendedRtpCapabilities = Kd; function Gd(s) { const e = { codecs: [], headerExtensions: [] }; for (const t of s.codecs) { const r = { mimeType: t.mimeType, kind: t.kind, preferredPayloadType: t.remotePayloadType, clockRate: t.clockRate, channels: t.channels, parameters: t.localParameters, rtcpFeedback: t.rtcpFeedback }; if (e.codecs.push(r), !t.remoteRtxPayloadType) continue; const i = { mimeType: `${t.kind}/rtx`, kind: t.kind, preferredPayloadType: t.remoteRtxPayloadType, clockRate: t.clockRate, parameters: { apt: t.remotePayloadType }, rtcpFeedback: [] }; e.codecs.push(i) } for (const t of s.headerExtensions) { if (t.direction !== 'sendrecv' && t.direction !== 'recvonly') continue; const r = { kind: t.kind, uri: t.uri, preferredId: t.recvId, preferredEncrypt: t.encrypt, direction: t.direction }; e.headerExtensions.push(r) } return e }v.getRecvRtpCapabilities = Gd; function Wd(s, e) { const t = { mid: void 0, codecs: [], headerExtensions: [], encodings: [], rtcp: {}}; for (const r of e.codecs) { if (r.kind !== s) continue; const i = { mimeType: r.mimeType, payloadType: r.localPayloadType, clockRate: r.clockRate, channels: r.channels, parameters: r.localParameters, rtcpFeedback: r.rtcpFeedback }; if (t.codecs.push(i), r.localRtxPayloadType) { const n = { mimeType: `${r.kind}/rtx`, payloadType: r.localRtxPayloadType, clockRate: r.clockRate, parameters: { apt: r.localPayloadType }, rtcpFeedback: [] }; t.codecs.push(n) } } for (const r of e.headerExtensions) { if (r.kind && r.kind !== s || r.direction !== 'sendrecv' && r.direction !== 'sendonly') continue; const i = { uri: r.uri, id: r.sendId, encrypt: r.encrypt, parameters: {}}; t.headerExtensions.push(i) } return t }v.getSendingRtpParameters = Wd; function Qd(s, e) { const t = { mid: void 0, codecs: [], headerExtensions: [], encodings: [], rtcp: {}}; for (const r of e.codecs) { if (r.kind !== s) continue; const i = { mimeType: r.mimeType, payloadType: r.localPayloadType, clockRate: r.clockRate, channels: r.channels, parameters: r.remoteParameters, rtcpFeedback: r.rtcpFeedback }; if (t.codecs.push(i), r.localRtxPayloadType) { const n = { mimeType: `${r.kind}/rtx`, payloadType: r.localRtxPayloadType, clockRate: r.clockRate, parameters: { apt: r.localPayloadType }, rtcpFeedback: [] }; t.codecs.push(n) } } for (const r of e.headerExtensions) { if (r.kind && r.kind !== s || r.direction !== 'sendrecv' && r.direction !== 'sendonly') continue; const i = { uri: r.uri, id: r.sendId, encrypt: r.encrypt, parameters: {}}; t.headerExtensions.push(i) } if (t.headerExtensions.some(r => r.uri === 'http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01')) for (const r of t.codecs)r.rtcpFeedback = (r.rtcpFeedback || []).filter(i => i.type !== 'goog-remb'); else if (t.headerExtensions.some(r => r.uri === 'http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time')) for (const r of t.codecs)r.rtcpFeedback = (r.rtcpFeedback || []).filter(i => i.type !== 'transport-cc'); else for (const r of t.codecs)r.rtcpFeedback = (r.rtcpFeedback || []).filter(i => i.type !== 'transport-cc' && i.type !== 'goog-remb'); return t }v.getSendingRemoteRtpParameters = Qd; function Jd(s, e) { const t = []; if (!e)t.push(s[0]), Ft(s[1]) && t.push(s[1]); else { for (let r = 0; r < s.length; ++r) if (fa(s[r], e)) { t.push(s[r]), Ft(s[r + 1]) && t.push(s[r + 1]); break } if (t.length === 0) throw new TypeError('no matching codec found') } return t }v.reduceCodecs = Jd; function Yd(s) { s = qd.clone(s, {}), Is(s); const e = { mid: Fd, codecs: [], headerExtensions: [], encodings: [{ ssrc: Nd }], rtcp: { cname: 'probator' }}; return e.codecs.push(s.codecs[0]), e.codecs[0].payloadType = Ud, e.headerExtensions = s.headerExtensions, e }v.generateProbatorRtpParameters = Yd; function Xd(s, e) { return e.codecs.some(t => t.kind === s) }v.canSend = Xd; function Zd(s, e) { if (Is(s), s.codecs.length === 0) return !1; const t = s.codecs[0]; return e.codecs.some(r => r.remotePayloadType === t.payloadType) }v.canReceive = Zd; function Ft(s) { return s ? /.+\/rtx$/i.test(s.mimeType) : !1 } function fa(s, e, { strict: t = !1, modify: r = !1 } = {}) { const i = s.mimeType.toLowerCase(); const n = e.mimeType.toLowerCase(); if (i !== n || s.clockRate !== e.clockRate || s.channels !== e.channels) return !1; switch (i) { case 'video/h264': { const c = s.parameters['packetization-mode'] || 0; const a = e.parameters['packetization-mode'] || 0; if (c !== a) return !1; if (t) { if (!aa.isSameProfile(s.parameters, e.parameters)) return !1; let o; try { o = aa.generateProfileLevelIdForAnswer(s.parameters, e.parameters) } catch (d) { return !1 }r && (o ? (s.parameters['profile-level-id'] = o, e.parameters['profile-level-id'] = o) : (delete s.parameters['profile-level-id'], delete e.parameters['profile-level-id'])) } break } case 'video/vp9': { if (t) { const c = s.parameters['profile-id'] || 0; const a = e.parameters['profile-id'] || 0; if (c !== a) return !1 } break } } return !0 } function el(s, e) { return !(s.kind && e.kind && s.kind !== e.kind || s.uri !== e.uri) } function tl(s, e) { const t = []; for (const r of s.rtcpFeedback || []) { const i = (e.rtcpFeedback || []).find(n => n.type === r.type && (n.parameter === r.parameter || !n.parameter && !r.parameter)); i && t.push(i) } return t } }); var ga = m(Nt => { 'use strict'; var As = Nt && Nt.__awaiter || function(s, e, t, r) { function i(n) { return n instanceof t ? n : new t(function(c) { c(n) }) } return new (t || (t = Promise))(function(n, c) { function a(l) { try { d(r.next(l)) } catch (p) { c(p) } } function o(l) { try { d(r.throw(l)) } catch (p) { c(p) } } function d(l) { l.done ? n(l.value) : i(l.value).then(a, o) }d((r = r.apply(s, e || [])).next()) }) }; Object.defineProperty(Nt, '__esModule', { value: !0 }); var ma = class {constructor({ ClosedErrorClass: e = Error, StoppedErrorClass: t = Error } = { ClosedErrorClass: Error, StoppedErrorClass: Error }) { this.closed = !1, this.pendingTasks = [], this.ClosedErrorClass = Error, this.StoppedErrorClass = Error, this.ClosedErrorClass = e, this.StoppedErrorClass = t } get size() { return this.pendingTasks.length }close() { if (!this.closed) { this.closed = !0; for (const e of this.pendingTasks)e.stopped = !0, e.reject(new this.ClosedErrorClass('AwaitQueue closed')); this.pendingTasks.length = 0 } }push(e, t) { return As(this, void 0, void 0, function * () { if (this.closed) throw new this.ClosedErrorClass('AwaitQueue closed'); if (typeof e !== 'function') throw new TypeError('given task is not a function'); if (!e.name && t) try { Object.defineProperty(e, 'name', { value: t }) } catch (r) {} return new Promise((r, i) => { const n = { task: e, name: t, resolve: r, reject: i, stopped: !1, enqueuedAt: new Date(), executedAt: void 0 }; this.pendingTasks.push(n), this.pendingTasks.length === 1 && this.next() }) }) }stop() { if (!this.closed) { for (const e of this.pendingTasks)e.stopped = !0, e.reject(new this.StoppedErrorClass('AwaitQueue stopped')); this.pendingTasks.length = 0 } }dump() { const e = new Date(); return this.pendingTasks.map(t => ({ task: t.task, name: t.name, enqueuedTime: t.executedAt ? t.executedAt.getTime() - t.enqueuedAt.getTime() : e.getTime() - t.enqueuedAt.getTime(), executingTime: t.executedAt ? e.getTime() - t.executedAt.getTime() : 0 })) }next() { return As(this, void 0, void 0, function * () { const e = this.pendingTasks[0]; !e || (yield this.executeTask(e), this.pendingTasks.shift(), this.next()) }) }executeTask(e) { return As(this, void 0, void 0, function * () { if (!e.stopped) { e.executedAt = new Date(); try { const t = yield e.task(); if (e.stopped) return; e.resolve(t) } catch (t) { if (e.stopped) return; e.reject(t) } } }) }}; Nt.AwaitQueue = ma }); var js = m(Tr => { 'use strict'; Object.defineProperty(Tr, '__esModule', { value: !0 }); Tr.Producer = void 0; var rl = A(); var _a = Ve(); var yt = oe(); var ue = new rl.Logger('Producer'); var va = class extends _a.EnhancedEventEmitter {constructor({ id: e, localId: t, rtpSender: r, track: i, rtpParameters: n, stopTracks: c, disableTrackOnPause: a, zeroRtpOnPause: o, appData: d }) { super(); this._closed = !1, this._observer = new _a.EnhancedEventEmitter(), ue.debug('constructor()'), this._id = e, this._localId = t, this._rtpSender = r, this._track = i, this._kind = i.kind, this._rtpParameters = n, this._paused = a ? !i.enabled : !1, this._maxSpatialLayer = void 0, this._stopTracks = c, this._disableTrackOnPause = a, this._zeroRtpOnPause = o, this._appData = d, this._onTrackEnded = this._onTrackEnded.bind(this), this._handleTrack() } get id() { return this._id } get localId() { return this._localId } get closed() { return this._closed } get kind() { return this._kind } get rtpSender() { return this._rtpSender } get track() { return this._track } get rtpParameters() { return this._rtpParameters } get paused() { return this._paused } get maxSpatialLayer() { return this._maxSpatialLayer } get appData() { return this._appData } set appData(e) { throw new Error('cannot override appData object') } get observer() { return this._observer }close() { this._closed || (ue.debug('close()'), this._closed = !0, this._destroyTrack(), this.emit('@close'), this._observer.safeEmit('close')) }transportClosed() { this._closed || (ue.debug('transportClosed()'), this._closed = !0, this._destroyTrack(), this.safeEmit('transportclose'), this._observer.safeEmit('close')) } async getStats() { if (this._closed) throw new yt.InvalidStateError('closed'); return this.safeEmitAsPromise('@getstats') }pause() { if (ue.debug('pause()'), this._closed) { ue.error('pause() | Producer closed'); return } this._paused = !0, this._track && this._disableTrackOnPause && (this._track.enabled = !1), this._zeroRtpOnPause && this.safeEmitAsPromise('@replacetrack', null).catch(() => {}), this._observer.safeEmit('pause') }resume() { if (ue.debug('resume()'), this._closed) { ue.error('resume() | Producer closed'); return } this._paused = !1, this._track && this._disableTrackOnPause && (this._track.enabled = !0), this._zeroRtpOnPause && this.safeEmitAsPromise('@replacetrack', this._track).catch(() => {}), this._observer.safeEmit('resume') } async replaceTrack({ track: e }) { if (ue.debug('replaceTrack() [track:%o]', e), this._closed) { if (e && this._stopTracks) try { e.stop() } catch (t) {} throw new yt.InvalidStateError('closed') } else if (e && e.readyState === 'ended') throw new yt.InvalidStateError('track ended'); if (e === this._track) { ue.debug('replaceTrack() | same track, ignored'); return }(!this._zeroRtpOnPause || !this._paused) && await this.safeEmitAsPromise('@replacetrack', e), this._destroyTrack(), this._track = e, this._track && this._disableTrackOnPause && (this._paused ? this._paused && (this._track.enabled = !1) : this._track.enabled = !0), this._handleTrack() } async setMaxSpatialLayer(e) { if (this._closed) throw new yt.InvalidStateError('closed'); if (this._kind !== 'video') throw new yt.UnsupportedError('not a video Producer'); if (typeof e !== 'number') throw new TypeError('invalid spatialLayer'); e !== this._maxSpatialLayer && (await this.safeEmitAsPromise('@setmaxspatiallayer', e), this._maxSpatialLayer = e) } async setRtpEncodingParameters(e) { if (this._closed) throw new yt.InvalidStateError('closed'); if (typeof e !== 'object') throw new TypeError('invalid params'); await this.safeEmitAsPromise('@setrtpencodingparameters', e) }_onTrackEnded() { ue.debug('track "ended" event'), this.safeEmit('trackended'), this._observer.safeEmit('trackended') }_handleTrack() { !this._track || this._track.addEventListener('ended', this._onTrackEnded) }_destroyTrack() { if (this._track) try { this._track.removeEventListener('ended', this._onTrackEnded), this._stopTracks && this._track.stop() } catch (e) {} }}; Tr.Producer = va }); var Bs = m(Pr => { 'use strict'; Object.defineProperty(Pr, '__esModule', { value: !0 }); Pr.Consumer = void 0; var sl = A(); var ya = Ve(); var il = oe(); var $e = new sl.Logger('Consumer'); var ba = class extends ya.EnhancedEventEmitter {constructor({ id: e, localId: t, producerId: r, rtpReceiver: i, track: n, rtpParameters: c, appData: a }) { super(); this._closed = !1, this._observer = new ya.EnhancedEventEmitter(), $e.debug('constructor()'), this._id = e, this._localId = t, this._producerId = r, this._rtpReceiver = i, this._track = n, this._rtpParameters = c, this._paused = !n.enabled, this._appData = a, this._onTrackEnded = this._onTrackEnded.bind(this), this._handleTrack() } get id() { return this._id } get localId() { return this._localId } get producerId() { return this._producerId } get closed() { return this._closed } get kind() { return this._track.kind } get rtpReceiver() { return this._rtpReceiver } get track() { return this._track } get rtpParameters() { return this._rtpParameters } get paused() { return this._paused } get appData() { return this._appData } set appData(e) { throw new Error('cannot override appData object') } get observer() { return this._observer }close() { this._closed || ($e.debug('close()'), this._closed = !0, this._destroyTrack(), this.emit('@close'), this._observer.safeEmit('close')) }transportClosed() { this._closed || ($e.debug('transportClosed()'), this._closed = !0, this._destroyTrack(), this.safeEmit('transportclose'), this._observer.safeEmit('close')) } async getStats() { if (this._closed) throw new il.InvalidStateError('closed'); return this.safeEmitAsPromise('@getstats') }pause() { if ($e.debug('pause()'), this._closed) { $e.error('pause() | Consumer closed'); return } this._paused = !0, this._track.enabled = !1, this._observer.safeEmit('pause') }resume() { if ($e.debug('resume()'), this._closed) { $e.error('resume() | Consumer closed'); return } this._paused = !1, this._track.enabled = !0, this._observer.safeEmit('resume') }_onTrackEnded() { $e.debug('track "ended" event'), this.safeEmit('trackended'), this._observer.safeEmit('trackended') }_handleTrack() { this._track.addEventListener('ended', this._onTrackEnded) }_destroyTrack() { try { this._track.removeEventListener('ended', this._onTrackEnded), this._track.stop() } catch (e) {} }}; Pr.Consumer = ba }); var qs = m(Er => { 'use strict'; Object.defineProperty(Er, '__esModule', { value: !0 }); Er.DataProducer = void 0; var nl = A(); var wa = Ve(); var al = oe(); var Ae = new nl.Logger('DataProducer'); var Sa = class extends wa.EnhancedEventEmitter {constructor({ id: e, dataChannel: t, sctpStreamParameters: r, appData: i }) { super(); this._closed = !1, this._observer = new wa.EnhancedEventEmitter(), Ae.debug('constructor()'), this._id = e, this._dataChannel = t, this._sctpStreamParameters = r, this._appData = i, this._handleDataChannel() } get id() { return this._id } get closed() { return this._closed } get sctpStreamParameters() { return this._sctpStreamParameters } get readyState() { return this._dataChannel.readyState } get label() { return this._dataChannel.label } get protocol() { return this._dataChannel.protocol } get bufferedAmount() { return this._dataChannel.bufferedAmount } get bufferedAmountLowThreshold() { return this._dataChannel.bufferedAmountLowThreshold } set bufferedAmountLowThreshold(e) { this._dataChannel.bufferedAmountLowThreshold = e } get appData() { return this._appData } set appData(e) { throw new Error('cannot override appData object') } get observer() { return this._observer }close() { this._closed || (Ae.debug('close()'), this._closed = !0, this._dataChannel.close(), this.emit('@close'), this._observer.safeEmit('close')) }transportClosed() { this._closed || (Ae.debug('transportClosed()'), this._closed = !0, this._dataChannel.close(), this.safeEmit('transportclose'), this._observer.safeEmit('close')) }send(e) { if (Ae.debug('send()'), this._closed) throw new al.InvalidStateError('closed'); this._dataChannel.send(e) }_handleDataChannel() { this._dataChannel.addEventListener('open', () => { this._closed || (Ae.debug('DataChannel "open" event'), this.safeEmit('open')) }), this._dataChannel.addEventListener('error', e => { if (this._closed) return; let{ error: t } = e; t || (t = new Error('unknown DataChannel error')), t.errorDetail === 'sctp-failure' ? Ae.error('DataChannel SCTP error [sctpCauseCode:%s]: %s', t.sctpCauseCode, t.message) : Ae.error('DataChannel "error" event: %o', t), this.safeEmit('error', t) }), this._dataChannel.addEventListener('close', () => { this._closed || (Ae.warn('DataChannel "close" event'), this._closed = !0, this.emit('@close'), this.safeEmit('close')) }), this._dataChannel.addEventListener('message', () => { this._closed || Ae.warn('DataChannel "message" event in a DataProducer, message discarded') }), this._dataChannel.addEventListener('bufferedamountlow', () => { this._closed || this.safeEmit('bufferedamountlow') }) }}; Er.DataProducer = Sa }); var Fs = m(Dr => { 'use strict'; Object.defineProperty(Dr, '__esModule', { value: !0 }); Dr.DataConsumer = void 0; var ol = A(); var Ra = Ve(); var Ze = new ol.Logger('DataConsumer'); var Ca = class extends Ra.EnhancedEventEmitter {constructor({ id: e, dataProducerId: t, dataChannel: r, sctpStreamParameters: i, appData: n }) { super(); this._closed = !1, this._observer = new Ra.EnhancedEventEmitter(), Ze.debug('constructor()'), this._id = e, this._dataProducerId = t, this._dataChannel = r, this._sctpStreamParameters = i, this._appData = n, this._handleDataChannel() } get id() { return this._id } get dataProducerId() { return this._dataProducerId } get closed() { return this._closed } get sctpStreamParameters() { return this._sctpStreamParameters } get readyState() { return this._dataChannel.readyState } get label() { return this._dataChannel.label } get protocol() { return this._dataChannel.protocol } get binaryType() { return this._dataChannel.binaryType } set binaryType(e) { this._dataChannel.binaryType = e } get appData() { return this._appData } set appData(e) { throw new Error('cannot override appData object') } get observer() { return this._observer }close() { this._closed || (Ze.debug('close()'), this._closed = !0, this._dataChannel.close(), this.emit('@close'), this._observer.safeEmit('close')) }transportClosed() { this._closed || (Ze.debug('transportClosed()'), this._closed = !0, this._dataChannel.close(), this.safeEmit('transportclose'), this._observer.safeEmit('close')) }_handleDataChannel() { this._dataChannel.addEventListener('open', () => { this._closed || (Ze.debug('DataChannel "open" event'), this.safeEmit('open')) }), this._dataChannel.addEventListener('error', e => { if (this._closed) return; let{ error: t } = e; t || (t = new Error('unknown DataChannel error')), t.errorDetail === 'sctp-failure' ? Ze.error('DataChannel SCTP error [sctpCauseCode:%s]: %s', t.sctpCauseCode, t.message) : Ze.error('DataChannel "error" event: %o', t), this.safeEmit('error', t) }), this._dataChannel.addEventListener('close', () => { this._closed || (Ze.warn('DataChannel "close" event'), this._closed = !0, this.emit('@close'), this.safeEmit('close')) }), this._dataChannel.addEventListener('message', e => { this._closed || this.safeEmit('message', e.data) }) }}; Dr.DataConsumer = Ca }); var Us = m(he => { 'use strict'; var cl = he && he.__createBinding || (Object.create ? function(s, e, t, r) { r === void 0 && (r = t), Object.defineProperty(s, r, { enumerable: !0, get: function() { return e[t] } }) } : function(s, e, t, r) { r === void 0 && (r = t), s[r] = e[t] }); var dl = he && he.__setModuleDefault || (Object.create ? function(s, e) { Object.defineProperty(s, 'default', { enumerable: !0, value: e }) } : function(s, e) { s.default = e }); var Ta = he && he.__importStar || function(s) { if (s && s.__esModule) return s; var e = {}; if (s != null) for (var t in s)t !== 'default' && Object.hasOwnProperty.call(s, t) && cl(e, s, t); return dl(e, s), e }; Object.defineProperty(he, '__esModule', { value: !0 }); he.Transport = void 0; var ll = ga(); var pl = A(); var Pa = Ve(); var j = oe(); var Ns = Ta($()); var Ut = Ta(te()); var ul = js(); var hl = Bs(); var fl = qs(); var ml = Fs(); var re = new pl.Logger('Transport'); var Ea = class extends Pa.EnhancedEventEmitter {constructor({ direction: e, id: t, iceParameters: r, iceCandidates: i, dtlsParameters: n, sctpParameters: c, iceServers: a, iceTransportPolicy: o, additionalSettings: d, proprietaryConstraints: l, appData: p, handlerFactory: u, extendedRtpCapabilities: h, canProduceByKind: f }) { super(); this._closed = !1, this._connectionState = 'new', this._producers = new Map(), this._consumers = new Map(), this._dataProducers = new Map(), this._dataConsumers = new Map(), this._probatorConsumerCreated = !1, this._awaitQueue = new ll.AwaitQueue({ ClosedErrorClass: j.InvalidStateError }), this._observer = new Pa.EnhancedEventEmitter(), re.debug('constructor() [id:%s, direction:%s]', t, e), this._id = t, this._direction = e, this._extendedRtpCapabilities = h, this._canProduceByKind = f, this._maxSctpMessageSize = c ? c.maxMessageSize : null, d = Ns.clone(d, {}), delete d.iceServers, delete d.iceTransportPolicy, delete d.bundlePolicy, delete d.rtcpMuxPolicy, delete d.sdpSemantics, this._handler = u(), this._handler.run({ direction: e, iceParameters: r, iceCandidates: i, dtlsParameters: n, sctpParameters: c, iceServers: a, iceTransportPolicy: o, additionalSettings: d, proprietaryConstraints: l, extendedRtpCapabilities: h }), this._appData = p, this._handleHandler() } get id() { return this._id } get closed() { return this._closed } get direction() { return this._direction } get handler() { return this._handler } get connectionState() { return this._connectionState } get appData() { return this._appData } set appData(e) { throw new Error('cannot override appData object') } get observer() { return this._observer }close() { if (!this._closed) { re.debug('close()'), this._closed = !0, this._awaitQueue.close(), this._handler.close(); for (const e of this._producers.values())e.transportClosed(); this._producers.clear(); for (const e of this._consumers.values())e.transportClosed(); this._consumers.clear(); for (const e of this._dataProducers.values())e.transportClosed(); this._dataProducers.clear(); for (const e of this._dataConsumers.values())e.transportClosed(); this._dataConsumers.clear(), this._observer.safeEmit('close') } } async getStats() { if (this._closed) throw new j.InvalidStateError('closed'); return this._handler.getTransportStats() } async restartIce({ iceParameters: e }) { if (re.debug('restartIce()'), this._closed) throw new j.InvalidStateError('closed'); if (!e) throw new TypeError('missing iceParameters'); return this._awaitQueue.push(async() => this._handler.restartIce(e), 'transport.restartIce()') } async updateIceServers({ iceServers: e } = {}) { if (re.debug('updateIceServers()'), this._closed) throw new j.InvalidStateError('closed'); if (!Array.isArray(e)) throw new TypeError('missing iceServers'); return this._awaitQueue.push(async() => this._handler.updateIceServers(e), 'transport.updateIceServers()') } async produce({ track: e, encodings: t, codecOptions: r, codec: i, stopTracks: n = !0, disableTrackOnPause: c = !0, zeroRtpOnPause: a = !1, appData: o = {}} = {}) { if (re.debug('produce() [track:%o]', e), e) { if (this._direction !== 'send') throw new j.UnsupportedError('not a sending Transport'); if (this._canProduceByKind[e.kind]) { if (e.readyState === 'ended') throw new j.InvalidStateError('track ended'); if (this.listenerCount('connect') === 0 && this._connectionState === 'new') throw new TypeError('no "connect" listener set into this transport'); if (this.listenerCount('produce') === 0) throw new TypeError('no "produce" listener set into this transport'); if (o && typeof o !== 'object') throw new TypeError('if given, appData must be an object') } else throw new j.UnsupportedError(`cannot produce ${e.kind}`) } else throw new TypeError('missing track'); return this._awaitQueue.push(async() => { let d; if (t && !Array.isArray(t)) throw TypeError('encodings must be an array'); t && t.length === 0 ? d = void 0 : t && (d = t.map(h => { const f = { active: !0 }; return h.active === !1 && (f.active = !1), typeof h.dtx === 'boolean' && (f.dtx = h.dtx), typeof h.scalabilityMode === 'string' && (f.scalabilityMode = h.scalabilityMode), typeof h.scaleResolutionDownBy === 'number' && (f.scaleResolutionDownBy = h.scaleResolutionDownBy), typeof h.maxBitrate === 'number' && (f.maxBitrate = h.maxBitrate), typeof h.maxFramerate === 'number' && (f.maxFramerate = h.maxFramerate), typeof h.adaptivePtime === 'boolean' && (f.adaptivePtime = h.adaptivePtime), typeof h.priority === 'string' && (f.priority = h.priority), typeof h.networkPriority === 'string' && (f.networkPriority = h.networkPriority), f })); const { localId: l, rtpParameters: p, rtpSender: u } = await this._handler.send({ track: e, encodings: d, codecOptions: r, codec: i }); try { Ut.validateRtpParameters(p); const { id: h } = await this.safeEmitAsPromise('produce', { kind: e.kind, rtpParameters: p, appData: o }); const f = new ul.Producer({ id: h, localId: l, rtpSender: u, track: e, rtpParameters: p, stopTracks: n, disableTrackOnPause: c, zeroRtpOnPause: a, appData: o }); return this._producers.set(f.id, f), this._handleProducer(f), this._observer.safeEmit('newproducer', f), f } catch (h) { throw this._handler.stopSending(l).catch(() => {}), h } }, 'transport.produce()').catch(d => { if (n) try { e.stop() } catch (l) {} throw d }) } async consume({ id: e, producerId: t, kind: r, rtpParameters: i, appData: n = {}}) { if (re.debug('consume()'), i = Ns.clone(i, void 0), this._closed) throw new j.InvalidStateError('closed'); if (this._direction !== 'recv') throw new j.UnsupportedError('not a receiving Transport'); if (typeof e !== 'string') throw new TypeError('missing id'); if (typeof t !== 'string') throw new TypeError('missing producerId'); if (r !== 'audio' && r !== 'video') throw new TypeError(`invalid kind '${r}'`); if (this.listenerCount('connect') === 0 && this._connectionState === 'new') throw new TypeError('no "connect" listener set into this transport'); if (n && typeof n !== 'object') throw new TypeError('if given, appData must be an object'); return this._awaitQueue.push(async() => { if (!Ut.canReceive(i, this._extendedRtpCapabilities)) throw new j.UnsupportedError('cannot consume this Producer'); const { localId: a, rtpReceiver: o, track: d } = await this._handler.receive({ trackId: e, kind: r, rtpParameters: i }); const l = new hl.Consumer({ id: e, localId: a, producerId: t, rtpReceiver: o, track: d, rtpParameters: i, appData: n }); if (this._consumers.set(l.id, l), this._handleConsumer(l), !this._probatorConsumerCreated && r === 'video') try { const p = Ut.generateProbatorRtpParameters(l.rtpParameters); await this._handler.receive({ trackId: 'probator', kind: 'video', rtpParameters: p }), re.debug('consume() | Consumer for RTP probation created'), this._probatorConsumerCreated = !0 } catch (p) { re.error('consume() | failed to create Consumer for RTP probation:%o', p) } return this._observer.safeEmit('newconsumer', l), l }, 'transport.consume()') } async produceData({ ordered: e = !0, maxPacketLifeTime: t, maxRetransmits: r, priority: i = 'low', label: n = '', protocol: c = '', appData: a = {}} = {}) { if (re.debug('produceData()'), this._direction !== 'send') throw new j.UnsupportedError('not a sending Transport'); if (this._maxSctpMessageSize) if (['very-low', 'low', 'medium', 'high'].includes(i)) { if (this.listenerCount('connect') === 0 && this._connectionState === 'new') throw new TypeError('no "connect" listener set into this transport'); if (this.listenerCount('producedata') === 0) throw new TypeError('no "producedata" listener set into this transport'); if (a && typeof a !== 'object') throw new TypeError('if given, appData must be an object') } else throw new TypeError('wrong priority'); else throw new j.UnsupportedError('SCTP not enabled by remote Transport'); return (t || r) && (e = !1), this._awaitQueue.push(async() => { const { dataChannel: o, sctpStreamParameters: d } = await this._handler.sendDataChannel({ ordered: e, maxPacketLifeTime: t, maxRetransmits: r, priority: i, label: n, protocol: c }); Ut.validateSctpStreamParameters(d); const { id: l } = await this.safeEmitAsPromise('producedata', { sctpStreamParameters: d, label: n, protocol: c, appData: a }); const p = new fl.DataProducer({ id: l, dataChannel: o, sctpStreamParameters: d, appData: a }); return this._dataProducers.set(p.id, p), this._handleDataProducer(p), this._observer.safeEmit('newdataproducer', p), p }, 'transport.produceData()') } async consumeData({ id: e, dataProducerId: t, sctpStreamParameters: r, label: i = '', protocol: n = '', appData: c = {}}) { if (re.debug('consumeData()'), r = Ns.clone(r, void 0), this._closed) throw new j.InvalidStateError('closed'); if (this._direction !== 'recv') throw new j.UnsupportedError('not a receiving Transport'); if (this._maxSctpMessageSize) { if (typeof e !== 'string') throw new TypeError('missing id'); if (typeof t !== 'string') throw new TypeError('missing dataProducerId'); if (this.listenerCount('connect') === 0 && this._connectionState === 'new') throw new TypeError('no "connect" listener set into this transport'); if (c && typeof c !== 'object') throw new TypeError('if given, appData must be an object') } else throw new j.UnsupportedError('SCTP not enabled by remote Transport'); return Ut.validateSctpStreamParameters(r), this._awaitQueue.push(async() => { const { dataChannel: a } = await this._handler.receiveDataChannel({ sctpStreamParameters: r, label: i, protocol: n }); const o = new ml.DataConsumer({ id: e, dataProducerId: t, dataChannel: a, sctpStreamParameters: r, appData: c }); return this._dataConsumers.set(o.id, o), this._handleDataConsumer(o), this._observer.safeEmit('newdataconsumer', o), o }, 'transport.consumeData()') }_handleHandler() { const e = this._handler; e.on('@connect', ({ dtlsParameters: t }, r, i) => { if (this._closed) { i(new j.InvalidStateError('closed')); return } this.safeEmit('connect', { dtlsParameters: t }, r, i) }), e.on('@connectionstatechange', t => { t !== this._connectionState && (re.debug('connection state changed to %s', t), this._connectionState = t, this._closed || this.safeEmit('connectionstatechange', t)) }) }_handleProducer(e) { e.on('@close', () => { this._producers.delete(e.id), !this._closed && this._awaitQueue.push(async() => this._handler.stopSending(e.localId), 'producer @close event').catch(t => re.warn('producer.close() failed:%o', t)) }), e.on('@replacetrack', (t, r, i) => { this._awaitQueue.push(async() => this._handler.replaceTrack(e.localId, t), 'producer @replacetrack event').then(r).catch(i) }), e.on('@setmaxspatiallayer', (t, r, i) => { this._awaitQueue.push(async() => this._handler.setMaxSpatialLayer(e.localId, t), 'producer @setmaxspatiallayer event').then(r).catch(i) }), e.on('@setrtpencodingparameters', (t, r, i) => { this._awaitQueue.push(async() => this._handler.setRtpEncodingParameters(e.localId, t), 'producer @setrtpencodingparameters event').then(r).catch(i) }), e.on('@getstats', (t, r) => { if (this._closed) return r(new j.InvalidStateError('closed')); this._handler.getSenderStats(e.localId).then(t).catch(r) }) }_handleConsumer(e) { e.on('@close', () => { this._consumers.delete(e.id), !this._closed && this._awaitQueue.push(async() => this._handler.stopReceiving(e.localId), 'consumer @close event').catch(() => {}) }), e.on('@getstats', (t, r) => { if (this._closed) return r(new j.InvalidStateError('closed')); this._handler.getReceiverStats(e.localId).then(t).catch(r) }) }_handleDataProducer(e) { e.on('@close', () => { this._dataProducers.delete(e.id) }) }_handleDataConsumer(e) { e.on('@close', () => { this._dataConsumers.delete(e.id) }) }}; he.Transport = Ea }); var zs = m((jh, Ma) => { var Da = Ma.exports = { v: [{ name: 'version', reg: /^(\d*)$/ }], o: [{ name: 'origin', reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/, names: ['username', 'sessionId', 'sessionVersion', 'netType', 'ipVer', 'address'], format: '%s %s %d %s IP%d %s' }], s: [{ name: 'name' }], i: [{ name: 'description' }], u: [{ name: 'uri' }], e: [{ name: 'email' }], p: [{ name: 'phone' }], z: [{ name: 'timezones' }], r: [{ name: 'repeats' }], t: [{ name: 'timing', reg: /^(\d*) (\d*)/, names: ['start', 'stop'], format: '%d %d' }], c: [{ name: 'connection', reg: /^IN IP(\d) (\S*)/, names: ['version', 'ip'], format: 'IN IP%d %s' }], b: [{ push: 'bandwidth', reg: /^(TIAS|AS|CT|RR|RS):(\d*)/, names: ['type', 'limit'], format: '%s:%s' }], m: [{ reg: /^(\w*) (\d*) ([\w/]*)(?: (.*))?/, names: ['type', 'port', 'protocol', 'payloads'], format: '%s %d %s %s' }], a: [{ push: 'rtp', reg: /^rtpmap:(\d*) ([\w\-.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/, names: ['payload', 'codec', 'rate', 'encoding'], format: function(s) { return s.encoding ? 'rtpmap:%d %s/%s/%s' : s.rate ? 'rtpmap:%d %s/%s' : 'rtpmap:%d %s' } }, { push: 'fmtp', reg: /^fmtp:(\d*) ([\S| ]*)/, names: ['payload', 'config'], format: 'fmtp:%d %s' }, { name: 'control', reg: /^control:(.*)/, format: 'control:%s' }, { name: 'rtcp', reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/, names: ['port', 'netType', 'ipVer', 'address'], format: function(s) { return s.address != null ? 'rtcp:%d %s IP%d %s' : 'rtcp:%d' } }, { push: 'rtcpFbTrrInt', reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/, names: ['payload', 'value'], format: 'rtcp-fb:%s trr-int %d' }, { push: 'rtcpFb', reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/, names: ['payload', 'type', 'subtype'], format: function(s) { return s.subtype != null ? 'rtcp-fb:%s %s %s' : 'rtcp-fb:%s %s' } }, { push: 'ext', reg: /^extmap:(\d+)(?:\/(\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\S*)(?: (\S*))?/, names: ['value', 'direction', 'encrypt-uri', 'uri', 'config'], format: function(s) { return 'extmap:%d' + (s.direction ? '/%s' : '%v') + (s['encrypt-uri'] ? ' %s' : '%v') + ' %s' + (s.config ? ' %s' : '') } }, { name: 'extmapAllowMixed', reg: /^(extmap-allow-mixed)/ }, { push: 'crypto', reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/, names: ['id', 'suite', 'config', 'sessionConfig'], format: function(s) { return s.sessionConfig != null ? 'crypto:%d %s %s %s' : 'crypto:%d %s %s' } }, { name: 'setup', reg: /^setup:(\w*)/, format: 'setup:%s' }, { name: 'connectionType', reg: /^connection:(new|existing)/, format: 'connection:%s' }, { name: 'mid', reg: /^mid:([^\s]*)/, format: 'mid:%s' }, { name: 'msid', reg: /^msid:(.*)/, format: 'msid:%s' }, { name: 'ptime', reg: /^ptime:(\d*(?:\.\d*)*)/, format: 'ptime:%d' }, { name: 'maxptime', reg: /^maxptime:(\d*(?:\.\d*)*)/, format: 'maxptime:%d' }, { name: 'direction', reg: /^(sendrecv|recvonly|sendonly|inactive)/ }, { name: 'icelite', reg: /^(ice-lite)/ }, { name: 'iceUfrag', reg: /^ice-ufrag:(\S*)/, format: 'ice-ufrag:%s' }, { name: 'icePwd', reg: /^ice-pwd:(\S*)/, format: 'ice-pwd:%s' }, { name: 'fingerprint', reg: /^fingerprint:(\S*) (\S*)/, names: ['type', 'hash'], format: 'fingerprint:%s %s' }, { push: 'candidates', reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/, names: ['foundation', 'component', 'transport', 'priority', 'ip', 'port', 'type', 'raddr', 'rport', 'tcptype', 'generation', 'network-id', 'network-cost'], format: function(s) { var e = 'candidate:%s %d %s %d %s %d typ %s'; return e += s.raddr != null ? ' raddr %s rport %d' : '%v%v', e += s.tcptype != null ? ' tcptype %s' : '%v', s.generation != null && (e += ' generation %d'), e += s['network-id'] != null ? ' network-id %d' : '%v', e += s['network-cost'] != null ? ' network-cost %d' : '%v', e } }, { name: 'endOfCandidates', reg: /^(end-of-candidates)/ }, { name: 'remoteCandidates', reg: /^remote-candidates:(.*)/, format: 'remote-candidates:%s' }, { name: 'iceOptions', reg: /^ice-options:(\S*)/, format: 'ice-options:%s' }, { push: 'ssrcs', reg: /^ssrc:(\d*) ([\w_-]*)(?::(.*))?/, names: ['id', 'attribute', 'value'], format: function(s) { var e = 'ssrc:%d'; return s.attribute != null && (e += ' %s', s.value != null && (e += ':%s')), e } }, { push: 'ssrcGroups', reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/, names: ['semantics', 'ssrcs'], format: 'ssrc-group:%s %s' }, { name: 'msidSemantic', reg: /^msid-semantic:\s?(\w*) (\S*)/, names: ['semantic', 'token'], format: 'msid-semantic: %s %s' }, { push: 'groups', reg: /^group:(\w*) (.*)/, names: ['type', 'mids'], format: 'group:%s %s' }, { name: 'rtcpMux', reg: /^(rtcp-mux)/ }, { name: 'rtcpRsize', reg: /^(rtcp-rsize)/ }, { name: 'sctpmap', reg: /^sctpmap:([\w_/]*) (\S*)(?: (\S*))?/, names: ['sctpmapNumber', 'app', 'maxMessageSize'], format: function(s) { return s.maxMessageSize != null ? 'sctpmap:%s %s %s' : 'sctpmap:%s %s' } }, { name: 'xGoogleFlag', reg: /^x-google-flag:([^\s]*)/, format: 'x-google-flag:%s' }, { push: 'rids', reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/, names: ['id', 'direction', 'params'], format: function(s) { return s.params ? 'rid:%s %s %s' : 'rid:%s %s' } }, { push: 'imageattrs', reg: new RegExp('^imageattr:(\\d+|\\*)[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?'), names: ['pt', 'dir1', 'attrs1', 'dir2', 'attrs2'], format: function(s) { return 'imageattr:%s %s %s' + (s.dir2 ? ' %s %s' : '') } }, { name: 'simulcast', reg: new RegExp('^simulcast:(send|recv) ([a-zA-Z0-9\\-_~;,]+)(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?$'), names: ['dir1', 'list1', 'dir2', 'list2'], format: function(s) { return 'simulcast:%s %s' + (s.dir2 ? ' %s %s' : '') } }, { name: 'simulcast_03', reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/, names: ['value'], format: 'simulcast: %s' }, { name: 'framerate', reg: /^framerate:(\d+(?:$|\.\d+))/, format: 'framerate:%s' }, { name: 'sourceFilter', reg: /^source-filter: *(excl|incl) (\S*) (IP4|IP6|\*) (\S*) (.*)/, names: ['filterMode', 'netType', 'addressTypes', 'destAddress', 'srcList'], format: 'source-filter: %s %s %s %s %s' }, { name: 'bundleOnly', reg: /^(bundle-only)/ }, { name: 'label', reg: /^label:(.+)/, format: 'label:%s' }, { name: 'sctpPort', reg: /^sctp-port:(\d+)$/, format: 'sctp-port:%s' }, { name: 'maxMessageSize', reg: /^max-message-size:(\d+)$/, format: 'max-message-size:%s' }, { push: 'tsRefClocks', reg: /^ts-refclk:([^\s=]*)(?:=(\S*))?/, names: ['clksrc', 'clksrcExt'], format: function(s) { return 'ts-refclk:%s' + (s.clksrcExt != null ? '=%s' : '') } }, { name: 'mediaClk', reg: /^mediaclk:(?:id=(\S*))? *([^\s=]*)(?:=(\S*))?(?: *rate=(\d+)\/(\d+))?/, names: ['id', 'mediaClockName', 'mediaClockValue', 'rateNumerator', 'rateDenominator'], format: function(s) { var e = 'mediaclk:'; return e += s.id != null ? 'id=%s %s' : '%v%s', e += s.mediaClockValue != null ? '=%s' : '', e += s.rateNumerator != null ? ' rate=%s' : '', e += s.rateDenominator != null ? '/%s' : '', e } }, { name: 'keywords', reg: /^keywds:(.+)$/, format: 'keywds:%s' }, { name: 'content', reg: /^content:(.+)/, format: 'content:%s' }, { name: 'bfcpFloorCtrl', reg: /^floorctrl:(c-only|s-only|c-s)/, format: 'floorctrl:%s' }, { name: 'bfcpConfId', reg: /^confid:(\d+)/, format: 'confid:%s' }, { name: 'bfcpUserId', reg: /^userid:(\d+)/, format: 'userid:%s' }, { name: 'bfcpFloorId', reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/, names: ['id', 'mStream'], format: 'floorid:%s mstrm:%s' }, { push: 'invalid', names: ['value'] }] }; Object.keys(Da).forEach(function(s) { var e = Da[s]; e.forEach(function(t) { t.reg || (t.reg = /(.*)/), t.format || (t.format = '%s') }) }) }); var Oa = m(je => { var bt = function(s) { return String(Number(s)) === s ? Number(s) : s }; var gl = function(s, e, t, r) { if (r && !t)e[r] = bt(s[1]); else for (var i = 0; i < t.length; i += 1)s[i + 1] != null && (e[t[i]] = bt(s[i + 1])) }; var _l = function(s, e, t) { var r = s.name && s.names; s.push && !e[s.push] ? e[s.push] = [] : r && !e[s.name] && (e[s.name] = {}); var i = s.push ? {} : r ? e[s.name] : e; gl(t.match(s.reg), i, s.names, s.name), s.push && e[s.push].push(i) }; var ka = zs(); var vl = RegExp.prototype.test.bind(/^([a-z])=(.*)/); je.parse = function(s) { var e = {}; var t = []; var r = e; return s.split(/(\r\n|\r|\n)/).filter(vl).forEach(function(i) { var n = i[0]; var c = i.slice(2); n === 'm' && (t.push({ rtp: [], fmtp: [] }), r = t[t.length - 1]); for (var a = 0; a < (ka[n] || []).length; a += 1) { var o = ka[n][a]; if (o.reg.test(c)) return _l(o, r, c) } }), e.media = t, e }; var xa = function(s, e) { var t = e.split(/=(.+)/, 2); return t.length === 2 ? s[t[0]] = bt(t[1]) : t.length === 1 && e.length > 1 && (s[t[0]] = void 0), s }; je.parseParams = function(s) { return s.split(/;\s?/).reduce(xa, {}) }; je.parseFmtpConfig = je.parseParams; je.parsePayloads = function(s) { return s.toString().split(' ').map(Number) }; je.parseRemoteCandidates = function(s) { for (var e = [], t = s.split(' ').map(bt), r = 0; r < t.length; r += 3)e.push({ component: t[r], ip: t[r + 1], port: t[r + 2] }); return e }; je.parseImageAttributes = function(s) { return s.split(' ').map(function(e) { return e.substring(1, e.length - 1).split(',').reduce(xa, {}) }) }; je.parseSimulcastStreamList = function(s) { return s.split(';').map(function(e) { return e.split(',').map(function(t) { var r; var i = !1; return t[0] !== '~' ? r = bt(t) : (r = bt(t.substring(1, t.length)), i = !0), { scid: r, paused: i } }) }) } }); var Ia = m((qh, La) => {
    var Vs = zs(); var yl = /%[sdv%]/g; var bl = function(s) { var e = 1; var t = arguments; var r = t.length; return s.replace(yl, function(i) { if (e >= r) return i; var n = t[e]; switch (e += 1, i) { case '%%':return '%'; case '%s':return String(n); case '%d':return Number(n); case '%v':return '' } }) }; var zt = function(s, e, t) { var r = e.format instanceof Function ? e.format(e.push ? t : t[e.name]) : e.format; var i = [s + '=' + r]; if (e.names) for (var n = 0; n < e.names.length; n += 1) { var c = e.names[n]; e.name ? i.push(t[e.name][c]) : i.push(t[e.names[n]]) } else i.push(t[e.name]); return bl.apply(null, i) }; var wl = ['v', 'o', 's', 'i', 'u', 'e', 'p', 'c', 'b', 't', 'r', 'z', 'a']; var Sl = ['i', 'c', 'b', 'a']; La.exports = function(s, e) {
      e = e || {}, s.version == null && (s.version = 0), s.name == null && (s.name = ' '), s.media.forEach(function(n) { n.payloads == null && (n.payloads = '') }); var t = e.outerOrder || wl; var r = e.innerOrder || Sl; var i = []; return t.forEach(function(n) { Vs[n].forEach(function(c) { c.name in s && s[c.name] != null ? i.push(zt(n, c, s)) : c.push in s && s[c.push] != null && s[c.push].forEach(function(a) { i.push(zt(n, c, a)) }) }) }), s.media.forEach(function(n) { i.push(zt('m', Vs.m[0], n)), r.forEach(function(c) { Vs[c].forEach(function(a) { a.name in n && n[a.name] != null ? i.push(zt(c, a, n)) : a.push in n && n[a.push] != null && n[a.push].forEach(function(o) { i.push(zt(c, a, o)) }) }) }) }), i.join(`\r
`) + `\r
`
    }
  }); var ce = m(Be => { var et = Oa(); var Rl = Ia(); Be.write = Rl; Be.parse = et.parse; Be.parseParams = et.parseParams; Be.parseFmtpConfig = et.parseFmtpConfig; Be.parsePayloads = et.parsePayloads; Be.parseRemoteCandidates = et.parseRemoteCandidates; Be.parseImageAttributes = et.parseImageAttributes; Be.parseSimulcastStreamList = et.parseSimulcastStreamList }); var qe = m(N => { 'use strict'; var Cl = N && N.__createBinding || (Object.create ? function(s, e, t, r) { r === void 0 && (r = t), Object.defineProperty(s, r, { enumerable: !0, get: function() { return e[t] } }) } : function(s, e, t, r) { r === void 0 && (r = t), s[r] = e[t] }); var Tl = N && N.__setModuleDefault || (Object.create ? function(s, e) { Object.defineProperty(s, 'default', { enumerable: !0, value: e }) } : function(s, e) { s.default = e }); var Pl = N && N.__importStar || function(s) { if (s && s.__esModule) return s; var e = {}; if (s != null) for (var t in s)t !== 'default' && Object.hasOwnProperty.call(s, t) && Cl(e, s, t); return Tl(e, s), e }; Object.defineProperty(N, '__esModule', { value: !0 }); N.applyCodecParameters = N.getCname = N.extractDtlsParameters = N.extractRtpCapabilities = void 0; var Aa = Pl(ce()); function El({ sdpObject: s }) { const e = new Map(); const t = []; let r = !1; let i = !1; for (const c of s.media) { const a = c.type; switch (a) { case 'audio': { if (r) continue; r = !0; break } case 'video': { if (i) continue; i = !0; break } default:continue } for (const o of c.rtp) { const d = { kind: a, mimeType: `${a}/${o.codec}`, preferredPayloadType: o.payload, clockRate: o.rate, channels: o.encoding, parameters: {}, rtcpFeedback: [] }; e.set(d.preferredPayloadType, d) } for (const o of c.fmtp || []) { const d = Aa.parseParams(o.config); const l = e.get(o.payload); !l || (d && d.hasOwnProperty('profile-level-id') && (d['profile-level-id'] = String(d['profile-level-id'])), l.parameters = d) } for (const o of c.rtcpFb || []) { const d = e.get(o.payload); if (!d) continue; const l = { type: o.type, parameter: o.subtype }; l.parameter || delete l.parameter, d.rtcpFeedback.push(l) } for (const o of c.ext || []) { if (o['encrypt-uri']) continue; const d = { kind: a, uri: o.uri, preferredId: o.value }; t.push(d) } } return { codecs: Array.from(e.values()), headerExtensions: t } }N.extractRtpCapabilities = El; function Dl({ sdpObject: s }) { const e = (s.media || []).find(n => n.iceUfrag && n.port !== 0); if (!e) throw new Error('no active media section found'); const t = e.fingerprint || s.fingerprint; let r; switch (e.setup) { case 'active':r = 'client'; break; case 'passive':r = 'server'; break; case 'actpass':r = 'auto'; break } return { role: r, fingerprints: [{ algorithm: t.type, value: t.hash }] } }N.extractDtlsParameters = Dl; function Ml({ offerMediaObject: s }) { const e = (s.ssrcs || []).find(t => t.attribute === 'cname'); return e ? e.value : '' }N.getCname = Ml; function kl({ offerRtpParameters: s, answerMediaObject: e }) { for (const t of s.codecs) { const r = t.mimeType.toLowerCase(); if (r !== 'audio/opus' || !(e.rtp || []).find(a => a.payload === t.payloadType)) continue; e.fmtp = e.fmtp || []; let n = e.fmtp.find(a => a.payload === t.payloadType); n || (n = { payload: t.payloadType, config: '' }, e.fmtp.push(n)); const c = Aa.parseParams(n.config); switch (r) { case 'audio/opus': { const a = t.parameters['sprop-stereo']; a !== void 0 && (c.stereo = a ? 1 : 0); break } }n.config = ''; for (const a of Object.keys(c))n.config && (n.config += ';'), n.config += `${a}=${c[a]}` } }N.applyCodecParameters = kl }); var Vt = m(wt => { 'use strict'; Object.defineProperty(wt, '__esModule', { value: !0 }); wt.addLegacySimulcast = wt.getRtpEncodings = void 0; function xl({ offerMediaObject: s }) { const e = new Set(); for (const i of s.ssrcs || []) { const n = i.id; e.add(n) } if (e.size === 0) throw new Error('no a=ssrc lines found'); const t = new Map(); for (const i of s.ssrcGroups || []) { if (i.semantics !== 'FID') continue; let[n, c] = i.ssrcs.split(/\s+/); n = Number(n), c = Number(c), e.has(n) && (e.delete(n), e.delete(c), t.set(n, c)) } for (const i of e)t.set(i, null); const r = []; for (const [i, n] of t) { const c = { ssrc: i }; n && (c.rtx = { ssrc: n }), r.push(c) } return r }wt.getRtpEncodings = xl; function Ol({ offerMediaObject: s, numStreams: e }) { if (e <= 1) throw new TypeError('numStreams must be greater than 1'); const t = (s.ssrcs || []).find(p => p.attribute === 'msid'); if (!t) throw new Error('a=ssrc line with msid information not found'); const [r, i] = t.value.split(' '); const n = t.id; let c; (s.ssrcGroups || []).some(p => { if (p.semantics !== 'FID') return !1; const u = p.ssrcs.split(/\s+/); return Number(u[0]) === n ? (c = Number(u[1]), !0) : !1 }); const a = s.ssrcs.find(p => p.attribute === 'cname'); if (!a) throw new Error('a=ssrc line with cname information not found'); const o = a.value; const d = []; const l = []; for (let p = 0; p < e; ++p)d.push(n + p), c && l.push(c + p); s.ssrcGroups = [], s.ssrcs = [], s.ssrcGroups.push({ semantics: 'SIM', ssrcs: d.join(' ') }); for (let p = 0; p < d.length; ++p) { const u = d[p]; s.ssrcs.push({ id: u, attribute: 'cname', value: o }), s.ssrcs.push({ id: u, attribute: 'msid', value: `${r} ${i}` }) } for (let p = 0; p < l.length; ++p) { const u = d[p]; const h = l[p]; s.ssrcs.push({ id: h, attribute: 'cname', value: o }), s.ssrcs.push({ id: h, attribute: 'msid', value: `${r} ${i}` }), s.ssrcGroups.push({ semantics: 'FID', ssrcs: `${u} ${h}` }) } }wt.addLegacySimulcast = Ol }); var de = m(Mr => { 'use strict'; Object.defineProperty(Mr, '__esModule', { value: !0 }); Mr.HandlerInterface = void 0; var Ll = Ve(); var ja = class extends Ll.EnhancedEventEmitter {constructor() { super() }}; Mr.HandlerInterface = ja }); var Na = m(G => { 'use strict'; var Il = G && G.__createBinding || (Object.create ? function(s, e, t, r) { r === void 0 && (r = t), Object.defineProperty(s, r, { enumerable: !0, get: function() { return e[t] } }) } : function(s, e, t, r) { r === void 0 && (r = t), s[r] = e[t] }); var Al = G && G.__setModuleDefault || (Object.create ? function(s, e) { Object.defineProperty(s, 'default', { enumerable: !0, value: e }) } : function(s, e) { s.default = e }); var jl = G && G.__importStar || function(s) { if (s && s.__esModule) return s; var e = {}; if (s != null) for (var t in s)t !== 'default' && Object.hasOwnProperty.call(s, t) && Il(e, s, t); return Al(e, s), e }; Object.defineProperty(G, '__esModule', { value: !0 }); G.OfferMediaSection = G.AnswerMediaSection = G.MediaSection = void 0; var Bl = jl($()); var kr = class {constructor({ iceParameters: e, iceCandidates: t, dtlsParameters: r, planB: i = !1 }) { if (this._mediaObject = {}, this._planB = i, e && this.setIceParameters(e), t) { this._mediaObject.candidates = []; for (const n of t) { const c = {}; c.component = 1, c.foundation = n.foundation, c.ip = n.ip, c.port = n.port, c.priority = n.priority, c.transport = n.protocol, c.type = n.type, n.tcpType && (c.tcptype = n.tcpType), this._mediaObject.candidates.push(c) } this._mediaObject.endOfCandidates = 'end-of-candidates', this._mediaObject.iceOptions = 'renomination' }r && this.setDtlsRole(r.role) } get mid() { return String(this._mediaObject.mid) } get closed() { return this._mediaObject.port === 0 }getObject() { return this._mediaObject }setIceParameters(e) { this._mediaObject.iceUfrag = e.usernameFragment, this._mediaObject.icePwd = e.password }disable() { this._mediaObject.direction = 'inactive', delete this._mediaObject.ext, delete this._mediaObject.ssrcs, delete this._mediaObject.ssrcGroups, delete this._mediaObject.simulcast, delete this._mediaObject.simulcast_03, delete this._mediaObject.rids }close() { this._mediaObject.direction = 'inactive', this._mediaObject.port = 0, delete this._mediaObject.ext, delete this._mediaObject.ssrcs, delete this._mediaObject.ssrcGroups, delete this._mediaObject.simulcast, delete this._mediaObject.simulcast_03, delete this._mediaObject.rids, delete this._mediaObject.extmapAllowMixed }}; G.MediaSection = kr; var Ba = class extends kr {constructor({ iceParameters: e, iceCandidates: t, dtlsParameters: r, sctpParameters: i, plainRtpParameters: n, planB: c = !1, offerMediaObject: a, offerRtpParameters: o, answerRtpParameters: d, codecOptions: l, extmapAllowMixed: p = !1 }) { super({ iceParameters: e, iceCandidates: t, dtlsParameters: r, planB: c }); switch (this._mediaObject.mid = String(a.mid), this._mediaObject.type = a.type, this._mediaObject.protocol = a.protocol, n ? (this._mediaObject.connection = { ip: n.ip, version: n.ipVersion }, this._mediaObject.port = n.port) : (this._mediaObject.connection = { ip: '127.0.0.1', version: 4 }, this._mediaObject.port = 7), a.type) { case 'audio':case 'video': { this._mediaObject.direction = 'recvonly', this._mediaObject.rtp = [], this._mediaObject.rtcpFb = [], this._mediaObject.fmtp = []; for (const u of d.codecs) { const h = { payload: u.payloadType, codec: Fa(u), rate: u.clockRate }; u.channels > 1 && (h.encoding = u.channels), this._mediaObject.rtp.push(h); const f = Bl.clone(u.parameters, {}); if (l) { const { opusStereo: g, opusFec: k, opusDtx: I, opusMaxPlaybackRate: V, opusMaxAverageBitrate: Oe, opusPtime: Ne, videoGoogleStartBitrate: Ue, videoGoogleMaxBitrate: rt, videoGoogleMinBitrate: Ot } = l; const H = o.codecs.find(st => st.payloadType === u.payloadType); switch (u.mimeType.toLowerCase()) { case 'audio/opus': { g !== void 0 && (H.parameters['sprop-stereo'] = g ? 1 : 0, f.stereo = g ? 1 : 0), k !== void 0 && (H.parameters.useinbandfec = k ? 1 : 0, f.useinbandfec = k ? 1 : 0), I !== void 0 && (H.parameters.usedtx = I ? 1 : 0, f.usedtx = I ? 1 : 0), V !== void 0 && (f.maxplaybackrate = V), Oe !== void 0 && (f.maxaveragebitrate = Oe), Ne !== void 0 && (H.parameters.ptime = Ne, f.ptime = Ne); break } case 'video/vp8':case 'video/vp9':case 'video/h264':case 'video/h265': { Ue !== void 0 && (f['x-google-start-bitrate'] = Ue), rt !== void 0 && (f['x-google-max-bitrate'] = rt), Ot !== void 0 && (f['x-google-min-bitrate'] = Ot); break } } } const _ = { payload: u.payloadType, config: '' }; for (const g of Object.keys(f))_.config && (_.config += ';'), _.config += `${g}=${f[g]}`; _.config && this._mediaObject.fmtp.push(_); for (const g of u.rtcpFeedback) this._mediaObject.rtcpFb.push({ payload: u.payloadType, type: g.type, subtype: g.parameter }) } this._mediaObject.payloads = d.codecs.map(u => u.payloadType).join(' '), this._mediaObject.ext = []; for (const u of d.headerExtensions)!(a.ext || []).some(f => f.uri === u.uri) || this._mediaObject.ext.push({ uri: u.uri, value: u.id }); if (p && a.extmapAllowMixed === 'extmap-allow-mixed' && (this._mediaObject.extmapAllowMixed = 'extmap-allow-mixed'), a.simulcast) { this._mediaObject.simulcast = { dir1: 'recv', list1: a.simulcast.list1 }, this._mediaObject.rids = []; for (const u of a.rids || [])u.direction === 'send' && this._mediaObject.rids.push({ id: u.id, direction: 'recv' }) } else if (a.simulcast_03) { this._mediaObject.simulcast_03 = { value: a.simulcast_03.value.replace(/send/g, 'recv') }, this._mediaObject.rids = []; for (const u of a.rids || [])u.direction === 'send' && this._mediaObject.rids.push({ id: u.id, direction: 'recv' }) } this._mediaObject.rtcpMux = 'rtcp-mux', this._mediaObject.rtcpRsize = 'rtcp-rsize', this._planB && this._mediaObject.type === 'video' && (this._mediaObject.xGoogleFlag = 'conference'); break } case 'application': { typeof a.sctpPort === 'number' ? (this._mediaObject.payloads = 'webrtc-datachannel', this._mediaObject.sctpPort = i.port, this._mediaObject.maxMessageSize = i.maxMessageSize) : a.sctpmap && (this._mediaObject.payloads = i.port, this._mediaObject.sctpmap = { app: 'webrtc-datachannel', sctpmapNumber: i.port, maxMessageSize: i.maxMessageSize }); break } } }setDtlsRole(e) { switch (e) { case 'client':this._mediaObject.setup = 'active'; break; case 'server':this._mediaObject.setup = 'passive'; break; case 'auto':this._mediaObject.setup = 'actpass'; break } }}; G.AnswerMediaSection = Ba; var qa = class extends kr {constructor({ iceParameters: e, iceCandidates: t, dtlsParameters: r, sctpParameters: i, plainRtpParameters: n, planB: c = !1, mid: a, kind: o, offerRtpParameters: d, streamId: l, trackId: p, oldDataChannelSpec: u = !1 }) { super({ iceParameters: e, iceCandidates: t, dtlsParameters: r, planB: c }); switch (this._mediaObject.mid = String(a), this._mediaObject.type = o, n ? (this._mediaObject.connection = { ip: n.ip, version: n.ipVersion }, this._mediaObject.protocol = 'RTP/AVP', this._mediaObject.port = n.port) : (this._mediaObject.connection = { ip: '127.0.0.1', version: 4 }, i ? this._mediaObject.protocol = 'UDP/DTLS/SCTP' : this._mediaObject.protocol = 'UDP/TLS/RTP/SAVPF', this._mediaObject.port = 7), o) { case 'audio':case 'video': { this._mediaObject.direction = 'sendonly', this._mediaObject.rtp = [], this._mediaObject.rtcpFb = [], this._mediaObject.fmtp = [], this._planB || (this._mediaObject.msid = `${l || '-'} ${p}`); for (const g of d.codecs) { const k = { payload: g.payloadType, codec: Fa(g), rate: g.clockRate }; g.channels > 1 && (k.encoding = g.channels), this._mediaObject.rtp.push(k); const I = { payload: g.payloadType, config: '' }; for (const V of Object.keys(g.parameters))I.config && (I.config += ';'), I.config += `${V}=${g.parameters[V]}`; I.config && this._mediaObject.fmtp.push(I); for (const V of g.rtcpFeedback) this._mediaObject.rtcpFb.push({ payload: g.payloadType, type: V.type, subtype: V.parameter }) } this._mediaObject.payloads = d.codecs.map(g => g.payloadType).join(' '), this._mediaObject.ext = []; for (const g of d.headerExtensions) this._mediaObject.ext.push({ uri: g.uri, value: g.id }); this._mediaObject.rtcpMux = 'rtcp-mux', this._mediaObject.rtcpRsize = 'rtcp-rsize'; const h = d.encodings[0]; const f = h.ssrc; const _ = h.rtx && h.rtx.ssrc ? h.rtx.ssrc : void 0; this._mediaObject.ssrcs = [], this._mediaObject.ssrcGroups = [], d.rtcp.cname && this._mediaObject.ssrcs.push({ id: f, attribute: 'cname', value: d.rtcp.cname }), this._planB && this._mediaObject.ssrcs.push({ id: f, attribute: 'msid', value: `${l || '-'} ${p}` }), _ && (d.rtcp.cname && this._mediaObject.ssrcs.push({ id: _, attribute: 'cname', value: d.rtcp.cname }), this._planB && this._mediaObject.ssrcs.push({ id: _, attribute: 'msid', value: `${l || '-'} ${p}` }), this._mediaObject.ssrcGroups.push({ semantics: 'FID', ssrcs: `${f} ${_}` })); break } case 'application': { u ? (this._mediaObject.payloads = i.port, this._mediaObject.sctpmap = { app: 'webrtc-datachannel', sctpmapNumber: i.port, maxMessageSize: i.maxMessageSize }) : (this._mediaObject.payloads = 'webrtc-datachannel', this._mediaObject.sctpPort = i.port, this._mediaObject.maxMessageSize = i.maxMessageSize); break } } }setDtlsRole(e) { this._mediaObject.setup = 'actpass' }planBReceive({ offerRtpParameters: e, streamId: t, trackId: r }) { const i = e.encodings[0]; const n = i.ssrc; const c = i.rtx && i.rtx.ssrc ? i.rtx.ssrc : void 0; e.rtcp.cname && this._mediaObject.ssrcs.push({ id: n, attribute: 'cname', value: e.rtcp.cname }), this._mediaObject.ssrcs.push({ id: n, attribute: 'msid', value: `${t || '-'} ${r}` }), c && (e.rtcp.cname && this._mediaObject.ssrcs.push({ id: c, attribute: 'cname', value: e.rtcp.cname }), this._mediaObject.ssrcs.push({ id: c, attribute: 'msid', value: `${t || '-'} ${r}` }), this._mediaObject.ssrcGroups.push({ semantics: 'FID', ssrcs: `${n} ${c}` })) }planBStopReceiving({ offerRtpParameters: e }) { const t = e.encodings[0]; const r = t.ssrc; const i = t.rtx && t.rtx.ssrc ? t.rtx.ssrc : void 0; this._mediaObject.ssrcs = this._mediaObject.ssrcs.filter(n => n.id !== r && n.id !== i), i && (this._mediaObject.ssrcGroups = this._mediaObject.ssrcGroups.filter(n => n.ssrcs !== `${r} ${i}`)) }}; G.OfferMediaSection = qa; function Fa(s) { const t = new RegExp('^(audio|video)/(.+)', 'i').exec(s.mimeType); if (!t) throw new TypeError('invalid codec.mimeType'); return t[2] } }); var Fe = m(fe => { 'use strict'; var ql = fe && fe.__createBinding || (Object.create ? function(s, e, t, r) { r === void 0 && (r = t), Object.defineProperty(s, r, { enumerable: !0, get: function() { return e[t] } }) } : function(s, e, t, r) { r === void 0 && (r = t), s[r] = e[t] }); var Fl = fe && fe.__setModuleDefault || (Object.create ? function(s, e) { Object.defineProperty(s, 'default', { enumerable: !0, value: e }) } : function(s, e) { s.default = e }); var Nl = fe && fe.__importStar || function(s) { if (s && s.__esModule) return s; var e = {}; if (s != null) for (var t in s)t !== 'default' && Object.hasOwnProperty.call(s, t) && ql(e, s, t); return Fl(e, s), e }; Object.defineProperty(fe, '__esModule', { value: !0 }); fe.RemoteSdp = void 0; var Ul = Nl(ce()); var zl = A(); var xr = Na(); var $s = new zl.Logger('RemoteSdp'); var Ua = class {constructor({ iceParameters: e, iceCandidates: t, dtlsParameters: r, sctpParameters: i, plainRtpParameters: n, planB: c = !1 }) { if (this._mediaSections = [], this._midToIndex = new Map(), this._iceParameters = e, this._iceCandidates = t, this._dtlsParameters = r, this._sctpParameters = i, this._plainRtpParameters = n, this._planB = c, this._sdpObject = { version: 0, origin: { address: '0.0.0.0', ipVer: 4, netType: 'IN', sessionId: 1e4, sessionVersion: 0, username: 'mediasoup-client' }, name: '-', timing: { start: 0, stop: 0 }, media: [] }, e && e.iceLite && (this._sdpObject.icelite = 'ice-lite'), r) { this._sdpObject.msidSemantic = { semantic: 'WMS', token: '*' }; const a = this._dtlsParameters.fingerprints.length; this._sdpObject.fingerprint = { type: r.fingerprints[a - 1].algorithm, hash: r.fingerprints[a - 1].value }, this._sdpObject.groups = [{ type: 'BUNDLE', mids: '' }] }n && (this._sdpObject.origin.address = n.ip, this._sdpObject.origin.ipVer = n.ipVersion) }updateIceParameters(e) { $s.debug('updateIceParameters() [iceParameters:%o]', e), this._iceParameters = e, this._sdpObject.icelite = e.iceLite ? 'ice-lite' : void 0; for (const t of this._mediaSections)t.setIceParameters(e) }updateDtlsRole(e) { $s.debug('updateDtlsRole() [role:%s]', e), this._dtlsParameters.role = e; for (const t of this._mediaSections)t.setDtlsRole(e) }getNextMediaSectionIdx() { for (let e = 0; e < this._mediaSections.length; ++e) { const t = this._mediaSections[e]; if (t.closed) return { idx: e, reuseMid: t.mid } } return { idx: this._mediaSections.length } }send({ offerMediaObject: e, reuseMid: t, offerRtpParameters: r, answerRtpParameters: i, codecOptions: n, extmapAllowMixed: c = !1 }) { const a = new xr.AnswerMediaSection({ iceParameters: this._iceParameters, iceCandidates: this._iceCandidates, dtlsParameters: this._dtlsParameters, plainRtpParameters: this._plainRtpParameters, planB: this._planB, offerMediaObject: e, offerRtpParameters: r, answerRtpParameters: i, codecOptions: n, extmapAllowMixed: c }); t ? this._replaceMediaSection(a, t) : this._midToIndex.has(a.mid) ? this._replaceMediaSection(a) : this._addMediaSection(a) }receive({ mid: e, kind: t, offerRtpParameters: r, streamId: i, trackId: n }) { const c = this._midToIndex.get(e); let a; if (c !== void 0 && (a = this._mediaSections[c]), a)a.planBReceive({ offerRtpParameters: r, streamId: i, trackId: n }), this._replaceMediaSection(a); else { a = new xr.OfferMediaSection({ iceParameters: this._iceParameters, iceCandidates: this._iceCandidates, dtlsParameters: this._dtlsParameters, plainRtpParameters: this._plainRtpParameters, planB: this._planB, mid: e, kind: t, offerRtpParameters: r, streamId: i, trackId: n }); const o = this._mediaSections.find(d => d.closed); o ? this._replaceMediaSection(a, o.mid) : this._addMediaSection(a) } }disableMediaSection(e) { const t = this._midToIndex.get(e); if (t === void 0) throw new Error(`no media section found with mid '${e}'`); this._mediaSections[t].disable() }closeMediaSection(e) { const t = this._midToIndex.get(e); if (t === void 0) throw new Error(`no media section found with mid '${e}'`); const r = this._mediaSections[t]; if (e === this._firstMid) { $s.debug('closeMediaSection() | cannot close first media section, disabling it instead [mid:%s]', e), this.disableMediaSection(e); return }r.close(), this._regenerateBundleMids() }planBStopReceiving({ mid: e, offerRtpParameters: t }) { const r = this._midToIndex.get(e); if (r === void 0) throw new Error(`no media section found with mid '${e}'`); const i = this._mediaSections[r]; i.planBStopReceiving({ offerRtpParameters: t }), this._replaceMediaSection(i) }sendSctpAssociation({ offerMediaObject: e }) { const t = new xr.AnswerMediaSection({ iceParameters: this._iceParameters, iceCandidates: this._iceCandidates, dtlsParameters: this._dtlsParameters, sctpParameters: this._sctpParameters, plainRtpParameters: this._plainRtpParameters, offerMediaObject: e }); this._addMediaSection(t) }receiveSctpAssociation({ oldDataChannelSpec: e = !1 } = {}) { const t = new xr.OfferMediaSection({ iceParameters: this._iceParameters, iceCandidates: this._iceCandidates, dtlsParameters: this._dtlsParameters, sctpParameters: this._sctpParameters, plainRtpParameters: this._plainRtpParameters, mid: 'datachannel', kind: 'application', oldDataChannelSpec: e }); this._addMediaSection(t) }getSdp() { return this._sdpObject.origin.sessionVersion++, Ul.write(this._sdpObject) }_addMediaSection(e) { this._firstMid || (this._firstMid = e.mid), this._mediaSections.push(e), this._midToIndex.set(e.mid, this._mediaSections.length - 1), this._sdpObject.media.push(e.getObject()), this._regenerateBundleMids() }_replaceMediaSection(e, t) { if (typeof t === 'string') { const r = this._midToIndex.get(t); if (r === void 0) throw new Error(`no media section found for reuseMid '${t}'`); const i = this._mediaSections[r]; this._mediaSections[r] = e, this._midToIndex.delete(i.mid), this._midToIndex.set(e.mid, r), this._sdpObject.media[r] = e.getObject(), this._regenerateBundleMids() } else { const r = this._midToIndex.get(e.mid); if (r === void 0) throw new Error(`no media section found with mid '${e.mid}'`); this._mediaSections[r] = e, this._sdpObject.media[r] = e.getObject() } }_regenerateBundleMids() { !this._dtlsParameters || (this._sdpObject.groups[0].mids = this._mediaSections.filter(e => !e.closed).map(e => e.mid).join(' ')) }}; fe.RemoteSdp = Ua }); var Lr = m(Or => { 'use strict'; Object.defineProperty(Or, '__esModule', { value: !0 }); Or.parse = void 0; var Vl = new RegExp('^[LS]([1-9]\\d{0,1})T([1-9]\\d{0,1})'); function $l(s) { const e = Vl.exec(s || ''); return e ? { spatialLayers: Number(e[1]), temporalLayers: Number(e[2]) } : { spatialLayers: 1, temporalLayers: 1 } }Or.parse = $l }); var $a = m(ge => { 'use strict'; var Hl = ge && ge.__createBinding || (Object.create ? function(s, e, t, r) { r === void 0 && (r = t), Object.defineProperty(s, r, { enumerable: !0, get: function() { return e[t] } }) } : function(s, e, t, r) { r === void 0 && (r = t), s[r] = e[t] }); var Kl = ge && ge.__setModuleDefault || (Object.create ? function(s, e) { Object.defineProperty(s, 'default', { enumerable: !0, value: e }) } : function(s, e) { s.default = e }); var $t = ge && ge.__importStar || function(s) { if (s && s.__esModule) return s; var e = {}; if (s != null) for (var t in s)t !== 'default' && Object.hasOwnProperty.call(s, t) && Hl(e, s, t); return Kl(e, s), e }; Object.defineProperty(ge, '__esModule', { value: !0 }); ge.Chrome74 = void 0; var me = $t(ce()); var Gl = A(); var za = $t($()); var St = $t(te()); var Ir = $t(qe()); var Hs = $t(Vt()); var Wl = de(); var Ql = Fe(); var Jl = Lr(); var R = new Gl.Logger('Chrome74'); var Va = { OS: 1024, MIS: 1024 }; var Ar = class extends Wl.HandlerInterface {constructor() { super(); this._mapMidTransceiver = new Map(), this._sendStream = new MediaStream(), this._hasDataChannelMediaSection = !1, this._nextSendSctpStreamId = 0, this._transportReady = !1 }static createFactory() { return () => new Ar() } get name() { return 'Chrome74' }close() { if (R.debug('close()'), this._pc) try { this._pc.close() } catch (e) {} } async getNativeRtpCapabilities() { R.debug('getNativeRtpCapabilities()'); const e = new RTCPeerConnection({ iceServers: [], iceTransportPolicy: 'all', bundlePolicy: 'max-bundle', rtcpMuxPolicy: 'require', sdpSemantics: 'unified-plan' }); try { e.addTransceiver('audio'), e.addTransceiver('video'); const t = await e.createOffer(); try { e.close() } catch (n) {} const r = me.parse(t.sdp); return Ir.extractRtpCapabilities({ sdpObject: r }) } catch (t) { try { e.close() } catch (r) {} throw t } } async getNativeSctpCapabilities() { return R.debug('getNativeSctpCapabilities()'), { numStreams: Va } }run({ direction: e, iceParameters: t, iceCandidates: r, dtlsParameters: i, sctpParameters: n, iceServers: c, iceTransportPolicy: a, additionalSettings: o, proprietaryConstraints: d, extendedRtpCapabilities: l }) { R.debug('run()'), this._direction = e, this._remoteSdp = new Ql.RemoteSdp({ iceParameters: t, iceCandidates: r, dtlsParameters: i, sctpParameters: n }), this._sendingRtpParametersByKind = { audio: St.getSendingRtpParameters('audio', l), video: St.getSendingRtpParameters('video', l) }, this._sendingRemoteRtpParametersByKind = { audio: St.getSendingRemoteRtpParameters('audio', l), video: St.getSendingRemoteRtpParameters('video', l) }, this._pc = new RTCPeerConnection(Object.assign({ iceServers: c || [], iceTransportPolicy: a || 'all', bundlePolicy: 'max-bundle', rtcpMuxPolicy: 'require', sdpSemantics: 'unified-plan' }, o), d), this._pc.addEventListener('iceconnectionstatechange', () => { switch (this._pc.iceConnectionState) { case 'checking':this.emit('@connectionstatechange', 'connecting'); break; case 'connected':case 'completed':this.emit('@connectionstatechange', 'connected'); break; case 'failed':this.emit('@connectionstatechange', 'failed'); break; case 'disconnected':this.emit('@connectionstatechange', 'disconnected'); break; case 'closed':this.emit('@connectionstatechange', 'closed'); break } }) } async updateIceServers(e) { R.debug('updateIceServers()'); const t = this._pc.getConfiguration(); t.iceServers = e, this._pc.setConfiguration(t) } async restartIce(e) { if (R.debug('restartIce()'), this._remoteSdp.updateIceParameters(e), !!this._transportReady) if (this._direction === 'send') { const t = await this._pc.createOffer({ iceRestart: !0 }); R.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', t), await this._pc.setLocalDescription(t); const r = { type: 'answer', sdp: this._remoteSdp.getSdp() }; R.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', r), await this._pc.setRemoteDescription(r) } else { const t = { type: 'offer', sdp: this._remoteSdp.getSdp() }; R.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', t), await this._pc.setRemoteDescription(t); const r = await this._pc.createAnswer(); R.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', r), await this._pc.setLocalDescription(r) } } async getTransportStats() { return this._pc.getStats() } async send({ track: e, encodings: t, codecOptions: r, codec: i }) { this._assertSendDirection(), R.debug('send() [kind:%s, track.id:%s]', e.kind, e.id), t && t.length > 1 && t.forEach((g, k) => { g.rid = `r${k}` }); const n = za.clone(this._sendingRtpParametersByKind[e.kind], {}); n.codecs = St.reduceCodecs(n.codecs, i); const c = za.clone(this._sendingRemoteRtpParametersByKind[e.kind], {}); c.codecs = St.reduceCodecs(c.codecs, i); const a = this._remoteSdp.getNextMediaSectionIdx(); const o = this._pc.addTransceiver(e, { direction: 'sendonly', streams: [this._sendStream], sendEncodings: t }); let d = await this._pc.createOffer(); let l = me.parse(d.sdp); let p; this._transportReady || await this._setupTransport({ localDtlsRole: 'server', localSdpObject: l }); let u = !1; const h = Jl.parse((t || [{}])[0].scalabilityMode); t && t.length === 1 && h.spatialLayers > 1 && n.codecs[0].mimeType.toLowerCase() === 'video/vp9' && (R.debug('send() | enabling legacy simulcast for VP9 SVC'), u = !0, l = me.parse(d.sdp), p = l.media[a.idx], Hs.addLegacySimulcast({ offerMediaObject: p, numStreams: h.spatialLayers }), d = { type: 'offer', sdp: me.write(l) }), R.debug('send() | calling pc.setLocalDescription() [offer:%o]', d), await this._pc.setLocalDescription(d); const f = o.mid; if (n.mid = f, l = me.parse(this._pc.localDescription.sdp), p = l.media[a.idx], n.rtcp.cname = Ir.getCname({ offerMediaObject: p }), !t)n.encodings = Hs.getRtpEncodings({ offerMediaObject: p }); else if (t.length === 1) { let g = Hs.getRtpEncodings({ offerMediaObject: p }); Object.assign(g[0], t[0]), u && (g = [g[0]]), n.encodings = g } else n.encodings = t; if (n.encodings.length > 1 && (n.codecs[0].mimeType.toLowerCase() === 'video/vp8' || n.codecs[0].mimeType.toLowerCase() === 'video/h264')) for (const g of n.encodings)g.scalabilityMode = 'S1T3'; this._remoteSdp.send({ offerMediaObject: p, reuseMid: a.reuseMid, offerRtpParameters: n, answerRtpParameters: c, codecOptions: r, extmapAllowMixed: !0 }); const _ = { type: 'answer', sdp: this._remoteSdp.getSdp() }; return R.debug('send() | calling pc.setRemoteDescription() [answer:%o]', _), await this._pc.setRemoteDescription(_), this._mapMidTransceiver.set(f, o), { localId: f, rtpParameters: n, rtpSender: o.sender } } async stopSending(e) { this._assertSendDirection(), R.debug('stopSending() [localId:%s]', e); const t = this._mapMidTransceiver.get(e); if (!t) throw new Error('associated RTCRtpTransceiver not found'); t.sender.replaceTrack(null), this._pc.removeTrack(t.sender), this._remoteSdp.closeMediaSection(t.mid); const r = await this._pc.createOffer(); R.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', r), await this._pc.setLocalDescription(r); const i = { type: 'answer', sdp: this._remoteSdp.getSdp() }; R.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', i), await this._pc.setRemoteDescription(i) } async replaceTrack(e, t) { this._assertSendDirection(), t ? R.debug('replaceTrack() [localId:%s, track.id:%s]', e, t.id) : R.debug('replaceTrack() [localId:%s, no track]', e); const r = this._mapMidTransceiver.get(e); if (!r) throw new Error('associated RTCRtpTransceiver not found'); await r.sender.replaceTrack(t) } async setMaxSpatialLayer(e, t) { this._assertSendDirection(), R.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', e, t); const r = this._mapMidTransceiver.get(e); if (!r) throw new Error('associated RTCRtpTransceiver not found'); const i = r.sender.getParameters(); i.encodings.forEach((n, c) => { c <= t ? n.active = !0 : n.active = !1 }), await r.sender.setParameters(i) } async setRtpEncodingParameters(e, t) { this._assertSendDirection(), R.debug('setRtpEncodingParameters() [localId:%s, params:%o]', e, t); const r = this._mapMidTransceiver.get(e); if (!r) throw new Error('associated RTCRtpTransceiver not found'); const i = r.sender.getParameters(); i.encodings.forEach((n, c) => { i.encodings[c] = Object.assign(Object.assign({}, n), t) }), await r.sender.setParameters(i) } async getSenderStats(e) { this._assertSendDirection(); const t = this._mapMidTransceiver.get(e); if (!t) throw new Error('associated RTCRtpTransceiver not found'); return t.sender.getStats() } async sendDataChannel({ ordered: e, maxPacketLifeTime: t, maxRetransmits: r, label: i, protocol: n, priority: c }) { this._assertSendDirection(); const a = { negotiated: !0, id: this._nextSendSctpStreamId, ordered: e, maxPacketLifeTime: t, maxRetransmits: r, protocol: n, priority: c }; R.debug('sendDataChannel() [options:%o]', a); const o = this._pc.createDataChannel(i, a); if (this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % Va.MIS, !this._hasDataChannelMediaSection) { const l = await this._pc.createOffer(); const p = me.parse(l.sdp); const u = p.media.find(f => f.type === 'application'); this._transportReady || await this._setupTransport({ localDtlsRole: 'server', localSdpObject: p }), R.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', l), await this._pc.setLocalDescription(l), this._remoteSdp.sendSctpAssociation({ offerMediaObject: u }); const h = { type: 'answer', sdp: this._remoteSdp.getSdp() }; R.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', h), await this._pc.setRemoteDescription(h), this._hasDataChannelMediaSection = !0 } const d = { streamId: a.id, ordered: a.ordered, maxPacketLifeTime: a.maxPacketLifeTime, maxRetransmits: a.maxRetransmits }; return { dataChannel: o, sctpStreamParameters: d } } async receive({ trackId: e, kind: t, rtpParameters: r }) { this._assertRecvDirection(), R.debug('receive() [trackId:%s, kind:%s]', e, t); const i = r.mid || String(this._mapMidTransceiver.size); this._remoteSdp.receive({ mid: i, kind: t, offerRtpParameters: r, streamId: r.rtcp.cname, trackId: e }); const n = { type: 'offer', sdp: this._remoteSdp.getSdp() }; R.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', n), await this._pc.setRemoteDescription(n); let c = await this._pc.createAnswer(); const a = me.parse(c.sdp); const o = a.media.find(l => String(l.mid) === i); Ir.applyCodecParameters({ offerRtpParameters: r, answerMediaObject: o }), c = { type: 'answer', sdp: me.write(a) }, this._transportReady || await this._setupTransport({ localDtlsRole: 'client', localSdpObject: a }), R.debug('receive() | calling pc.setLocalDescription() [answer:%o]', c), await this._pc.setLocalDescription(c); const d = this._pc.getTransceivers().find(l => l.mid === i); if (!d) throw new Error('new RTCRtpTransceiver not found'); return this._mapMidTransceiver.set(i, d), { localId: i, track: d.receiver.track, rtpReceiver: d.receiver } } async stopReceiving(e) { this._assertRecvDirection(), R.debug('stopReceiving() [localId:%s]', e); const t = this._mapMidTransceiver.get(e); if (!t) throw new Error('associated RTCRtpTransceiver not found'); this._remoteSdp.closeMediaSection(t.mid); const r = { type: 'offer', sdp: this._remoteSdp.getSdp() }; R.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', r), await this._pc.setRemoteDescription(r); const i = await this._pc.createAnswer(); R.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', i), await this._pc.setLocalDescription(i) } async getReceiverStats(e) { this._assertRecvDirection(); const t = this._mapMidTransceiver.get(e); if (!t) throw new Error('associated RTCRtpTransceiver not found'); return t.receiver.getStats() } async receiveDataChannel({ sctpStreamParameters: e, label: t, protocol: r }) { this._assertRecvDirection(); const { streamId: i, ordered: n, maxPacketLifeTime: c, maxRetransmits: a } = e; const o = { negotiated: !0, id: i, ordered: n, maxPacketLifeTime: c, maxRetransmits: a, protocol: r }; R.debug('receiveDataChannel() [options:%o]', o); const d = this._pc.createDataChannel(t, o); if (!this._hasDataChannelMediaSection) { this._remoteSdp.receiveSctpAssociation(); const l = { type: 'offer', sdp: this._remoteSdp.getSdp() }; R.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', l), await this._pc.setRemoteDescription(l); const p = await this._pc.createAnswer(); if (!this._transportReady) { const u = me.parse(p.sdp); await this._setupTransport({ localDtlsRole: 'client', localSdpObject: u }) }R.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', p), await this._pc.setLocalDescription(p), this._hasDataChannelMediaSection = !0 } return { dataChannel: d } } async _setupTransport({ localDtlsRole: e, localSdpObject: t }) { t || (t = me.parse(this._pc.localDescription.sdp)); const r = Ir.extractDtlsParameters({ sdpObject: t }); r.role = e, this._remoteSdp.updateDtlsRole(e === 'client' ? 'server' : 'client'), await this.safeEmitAsPromise('@connect', { dtlsParameters: r }), this._transportReady = !0 }_assertSendDirection() { if (this._direction !== 'send') throw new Error('method can just be called for handlers with "send" direction') }_assertRecvDirection() { if (this._direction !== 'recv') throw new Error('method can just be called for handlers with "recv" direction') }}; ge.Chrome74 = Ar }); var Ga = m(_e => { 'use strict'; var Yl = _e && _e.__createBinding || (Object.create ? function(s, e, t, r) { r === void 0 && (r = t), Object.defineProperty(s, r, { enumerable: !0, get: function() { return e[t] } }) } : function(s, e, t, r) { r === void 0 && (r = t), s[r] = e[t] }); var Xl = _e && _e.__setModuleDefault || (Object.create ? function(s, e) { Object.defineProperty(s, 'default', { enumerable: !0, value: e }) } : function(s, e) { s.default = e }); var Ht = _e && _e.__importStar || function(s) { if (s && s.__esModule) return s; var e = {}; if (s != null) for (var t in s)t !== 'default' && Object.hasOwnProperty.call(s, t) && Yl(e, s, t); return Xl(e, s), e }; Object.defineProperty(_e, '__esModule', { value: !0 }); _e.Chrome70 = void 0; var se = Ht(ce()); var Zl = A(); var Ha = Ht($()); var Rt = Ht(te()); var jr = Ht(qe()); var Ks = Ht(Vt()); var ep = de(); var tp = Fe(); var rp = Lr(); var b = new Zl.Logger('Chrome70'); var Ka = { OS: 1024, MIS: 1024 }; var Br = class extends ep.HandlerInterface {constructor() { super(); this._mapMidTransceiver = new Map(), this._sendStream = new MediaStream(), this._hasDataChannelMediaSection = !1, this._nextSendSctpStreamId = 0, this._transportReady = !1 }static createFactory() { return () => new Br() } get name() { return 'Chrome70' }close() { if (b.debug('close()'), this._pc) try { this._pc.close() } catch (e) {} } async getNativeRtpCapabilities() { b.debug('getNativeRtpCapabilities()'); const e = new RTCPeerConnection({ iceServers: [], iceTransportPolicy: 'all', bundlePolicy: 'max-bundle', rtcpMuxPolicy: 'require', sdpSemantics: 'unified-plan' }); try { e.addTransceiver('audio'), e.addTransceiver('video'); const t = await e.createOffer(); try { e.close() } catch (n) {} const r = se.parse(t.sdp); return jr.extractRtpCapabilities({ sdpObject: r }) } catch (t) { try { e.close() } catch (r) {} throw t } } async getNativeSctpCapabilities() { return b.debug('getNativeSctpCapabilities()'), { numStreams: Ka } }run({ direction: e, iceParameters: t, iceCandidates: r, dtlsParameters: i, sctpParameters: n, iceServers: c, iceTransportPolicy: a, additionalSettings: o, proprietaryConstraints: d, extendedRtpCapabilities: l }) { b.debug('run()'), this._direction = e, this._remoteSdp = new tp.RemoteSdp({ iceParameters: t, iceCandidates: r, dtlsParameters: i, sctpParameters: n }), this._sendingRtpParametersByKind = { audio: Rt.getSendingRtpParameters('audio', l), video: Rt.getSendingRtpParameters('video', l) }, this._sendingRemoteRtpParametersByKind = { audio: Rt.getSendingRemoteRtpParameters('audio', l), video: Rt.getSendingRemoteRtpParameters('video', l) }, this._pc = new RTCPeerConnection(Object.assign({ iceServers: c || [], iceTransportPolicy: a || 'all', bundlePolicy: 'max-bundle', rtcpMuxPolicy: 'require', sdpSemantics: 'unified-plan' }, o), d), this._pc.addEventListener('iceconnectionstatechange', () => { switch (this._pc.iceConnectionState) { case 'checking':this.emit('@connectionstatechange', 'connecting'); break; case 'connected':case 'completed':this.emit('@connectionstatechange', 'connected'); break; case 'failed':this.emit('@connectionstatechange', 'failed'); break; case 'disconnected':this.emit('@connectionstatechange', 'disconnected'); break; case 'closed':this.emit('@connectionstatechange', 'closed'); break } }) } async updateIceServers(e) { b.debug('updateIceServers()'); const t = this._pc.getConfiguration(); t.iceServers = e, this._pc.setConfiguration(t) } async restartIce(e) { if (b.debug('restartIce()'), this._remoteSdp.updateIceParameters(e), !!this._transportReady) if (this._direction === 'send') { const t = await this._pc.createOffer({ iceRestart: !0 }); b.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', t), await this._pc.setLocalDescription(t); const r = { type: 'answer', sdp: this._remoteSdp.getSdp() }; b.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', r), await this._pc.setRemoteDescription(r) } else { const t = { type: 'offer', sdp: this._remoteSdp.getSdp() }; b.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', t), await this._pc.setRemoteDescription(t); const r = await this._pc.createAnswer(); b.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', r), await this._pc.setLocalDescription(r) } } async getTransportStats() { return this._pc.getStats() } async send({ track: e, encodings: t, codecOptions: r, codec: i }) { this._assertSendDirection(), b.debug('send() [kind:%s, track.id:%s]', e.kind, e.id); const n = Ha.clone(this._sendingRtpParametersByKind[e.kind], {}); n.codecs = Rt.reduceCodecs(n.codecs, i); const c = Ha.clone(this._sendingRemoteRtpParametersByKind[e.kind], {}); c.codecs = Rt.reduceCodecs(c.codecs, i); const a = this._remoteSdp.getNextMediaSectionIdx(); const o = this._pc.addTransceiver(e, { direction: 'sendonly', streams: [this._sendStream] }); let d = await this._pc.createOffer(); let l = se.parse(d.sdp); let p; this._transportReady || await this._setupTransport({ localDtlsRole: 'server', localSdpObject: l }), t && t.length > 1 && (b.debug('send() | enabling legacy simulcast'), l = se.parse(d.sdp), p = l.media[a.idx], Ks.addLegacySimulcast({ offerMediaObject: p, numStreams: t.length }), d = { type: 'offer', sdp: se.write(l) }); let u = !1; const h = rp.parse((t || [{}])[0].scalabilityMode); if (t && t.length === 1 && h.spatialLayers > 1 && n.codecs[0].mimeType.toLowerCase() === 'video/vp9' && (b.debug('send() | enabling legacy simulcast for VP9 SVC'), u = !0, l = se.parse(d.sdp), p = l.media[a.idx], Ks.addLegacySimulcast({ offerMediaObject: p, numStreams: h.spatialLayers }), d = { type: 'offer', sdp: se.write(l) }), b.debug('send() | calling pc.setLocalDescription() [offer:%o]', d), await this._pc.setLocalDescription(d), t) { b.debug('send() | applying given encodings'); const g = o.sender.getParameters(); for (let k = 0; k < (g.encodings || []).length; ++k) { const I = g.encodings[k]; const V = t[k]; if (!V) break; g.encodings[k] = Object.assign(I, V) } await o.sender.setParameters(g) } const f = o.mid; if (n.mid = f, l = se.parse(this._pc.localDescription.sdp), p = l.media[a.idx], n.rtcp.cname = jr.getCname({ offerMediaObject: p }), n.encodings = Ks.getRtpEncodings({ offerMediaObject: p }), t) for (let g = 0; g < n.encodings.length; ++g)t[g] && Object.assign(n.encodings[g], t[g]); if (u && (n.encodings = [n.encodings[0]]), n.encodings.length > 1 && (n.codecs[0].mimeType.toLowerCase() === 'video/vp8' || n.codecs[0].mimeType.toLowerCase() === 'video/h264')) for (const g of n.encodings)g.scalabilityMode = 'S1T3'; this._remoteSdp.send({ offerMediaObject: p, reuseMid: a.reuseMid, offerRtpParameters: n, answerRtpParameters: c, codecOptions: r }); const _ = { type: 'answer', sdp: this._remoteSdp.getSdp() }; return b.debug('send() | calling pc.setRemoteDescription() [answer:%o]', _), await this._pc.setRemoteDescription(_), this._mapMidTransceiver.set(f, o), { localId: f, rtpParameters: n, rtpSender: o.sender } } async stopSending(e) { this._assertSendDirection(), b.debug('stopSending() [localId:%s]', e); const t = this._mapMidTransceiver.get(e); if (!t) throw new Error('associated RTCRtpTransceiver not found'); t.sender.replaceTrack(null), this._pc.removeTrack(t.sender), this._remoteSdp.closeMediaSection(t.mid); const r = await this._pc.createOffer(); b.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', r), await this._pc.setLocalDescription(r); const i = { type: 'answer', sdp: this._remoteSdp.getSdp() }; b.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', i), await this._pc.setRemoteDescription(i) } async replaceTrack(e, t) { this._assertSendDirection(), t ? b.debug('replaceTrack() [localId:%s, track.id:%s]', e, t.id) : b.debug('replaceTrack() [localId:%s, no track]', e); const r = this._mapMidTransceiver.get(e); if (!r) throw new Error('associated RTCRtpTransceiver not found'); await r.sender.replaceTrack(t) } async setMaxSpatialLayer(e, t) { this._assertSendDirection(), b.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', e, t); const r = this._mapMidTransceiver.get(e); if (!r) throw new Error('associated RTCRtpTransceiver not found'); const i = r.sender.getParameters(); i.encodings.forEach((n, c) => { c <= t ? n.active = !0 : n.active = !1 }), await r.sender.setParameters(i) } async setRtpEncodingParameters(e, t) { this._assertSendDirection(), b.debug('setRtpEncodingParameters() [localId:%s, params:%o]', e, t); const r = this._mapMidTransceiver.get(e); if (!r) throw new Error('associated RTCRtpTransceiver not found'); const i = r.sender.getParameters(); i.encodings.forEach((n, c) => { i.encodings[c] = Object.assign(Object.assign({}, n), t) }), await r.sender.setParameters(i) } async getSenderStats(e) { this._assertSendDirection(); const t = this._mapMidTransceiver.get(e); if (!t) throw new Error('associated RTCRtpTransceiver not found'); return t.sender.getStats() } async sendDataChannel({ ordered: e, maxPacketLifeTime: t, maxRetransmits: r, label: i, protocol: n, priority: c }) { this._assertSendDirection(); const a = { negotiated: !0, id: this._nextSendSctpStreamId, ordered: e, maxPacketLifeTime: t, maxRetransmitTime: t, maxRetransmits: r, protocol: n, priority: c }; b.debug('sendDataChannel() [options:%o]', a); const o = this._pc.createDataChannel(i, a); if (this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % Ka.MIS, !this._hasDataChannelMediaSection) { const l = await this._pc.createOffer(); const p = se.parse(l.sdp); const u = p.media.find(f => f.type === 'application'); this._transportReady || await this._setupTransport({ localDtlsRole: 'server', localSdpObject: p }), b.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', l), await this._pc.setLocalDescription(l), this._remoteSdp.sendSctpAssociation({ offerMediaObject: u }); const h = { type: 'answer', sdp: this._remoteSdp.getSdp() }; b.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', h), await this._pc.setRemoteDescription(h), this._hasDataChannelMediaSection = !0 } const d = { streamId: a.id, ordered: a.ordered, maxPacketLifeTime: a.maxPacketLifeTime, maxRetransmits: a.maxRetransmits }; return { dataChannel: o, sctpStreamParameters: d } } async receive({ trackId: e, kind: t, rtpParameters: r }) { this._assertRecvDirection(), b.debug('receive() [trackId:%s, kind:%s]', e, t); const i = r.mid || String(this._mapMidTransceiver.size); this._remoteSdp.receive({ mid: i, kind: t, offerRtpParameters: r, streamId: r.rtcp.cname, trackId: e }); const n = { type: 'offer', sdp: this._remoteSdp.getSdp() }; b.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', n), await this._pc.setRemoteDescription(n); let c = await this._pc.createAnswer(); const a = se.parse(c.sdp); const o = a.media.find(l => String(l.mid) === i); jr.applyCodecParameters({ offerRtpParameters: r, answerMediaObject: o }), c = { type: 'answer', sdp: se.write(a) }, this._transportReady || await this._setupTransport({ localDtlsRole: 'client', localSdpObject: a }), b.debug('receive() | calling pc.setLocalDescription() [answer:%o]', c), await this._pc.setLocalDescription(c); const d = this._pc.getTransceivers().find(l => l.mid === i); if (!d) throw new Error('new RTCRtpTransceiver not found'); return this._mapMidTransceiver.set(i, d), { localId: i, track: d.receiver.track, rtpReceiver: d.receiver } } async stopReceiving(e) { this._assertRecvDirection(), b.debug('stopReceiving() [localId:%s]', e); const t = this._mapMidTransceiver.get(e); if (!t) throw new Error('associated RTCRtpTransceiver not found'); this._remoteSdp.closeMediaSection(t.mid); const r = { type: 'offer', sdp: this._remoteSdp.getSdp() }; b.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', r), await this._pc.setRemoteDescription(r); const i = await this._pc.createAnswer(); b.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', i), await this._pc.setLocalDescription(i) } async getReceiverStats(e) { this._assertRecvDirection(); const t = this._mapMidTransceiver.get(e); if (!t) throw new Error('associated RTCRtpTransceiver not found'); return t.receiver.getStats() } async receiveDataChannel({ sctpStreamParameters: e, label: t, protocol: r }) { this._assertRecvDirection(); const { streamId: i, ordered: n, maxPacketLifeTime: c, maxRetransmits: a } = e; const o = { negotiated: !0, id: i, ordered: n, maxPacketLifeTime: c, maxRetransmitTime: c, maxRetransmits: a, protocol: r }; b.debug('receiveDataChannel() [options:%o]', o); const d = this._pc.createDataChannel(t, o); if (!this._hasDataChannelMediaSection) { this._remoteSdp.receiveSctpAssociation(); const l = { type: 'offer', sdp: this._remoteSdp.getSdp() }; b.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', l), await this._pc.setRemoteDescription(l); const p = await this._pc.createAnswer(); if (!this._transportReady) { const u = se.parse(p.sdp); await this._setupTransport({ localDtlsRole: 'client', localSdpObject: u }) }b.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', p), await this._pc.setLocalDescription(p), this._hasDataChannelMediaSection = !0 } return { dataChannel: d } } async _setupTransport({ localDtlsRole: e, localSdpObject: t }) { t || (t = se.parse(this._pc.localDescription.sdp)); const r = jr.extractDtlsParameters({ sdpObject: t }); r.role = e, this._remoteSdp.updateDtlsRole(e === 'client' ? 'server' : 'client'), await this.safeEmitAsPromise('@connect', { dtlsParameters: r }), this._transportReady = !0 }_assertSendDirection() { if (this._direction !== 'send') throw new Error('method can just be called for handlers with "send" direction') }_assertRecvDirection() { if (this._direction !== 'recv') throw new Error('method can just be called for handlers with "recv" direction') }}; _e.Chrome70 = Br }); var Kt = m(Ct => { 'use strict'; Object.defineProperty(Ct, '__esModule', { value: !0 }); Ct.addLegacySimulcast = Ct.getRtpEncodings = void 0; function sp({ offerMediaObject: s, track: e }) { let t; const r = new Set(); for (const c of s.ssrcs || []) { if (c.attribute !== 'msid') continue; if (c.value.split(' ')[1] === e.id) { const o = c.id; r.add(o), t || (t = o) } } if (r.size === 0) throw new Error(`a=ssrc line with msid information not found [track.id:${e.id}]`); const i = new Map(); for (const c of s.ssrcGroups || []) { if (c.semantics !== 'FID') continue; let[a, o] = c.ssrcs.split(/\s+/); a = Number(a), o = Number(o), r.has(a) && (r.delete(a), r.delete(o), i.set(a, o)) } for (const c of r)i.set(c, null); const n = []; for (const [c, a] of i) { const o = { ssrc: c }; a && (o.rtx = { ssrc: a }), n.push(o) } return n }Ct.getRtpEncodings = sp; function ip({ offerMediaObject: s, track: e, numStreams: t }) { if (t <= 1) throw new TypeError('numStreams must be greater than 1'); let r, i, n; if (!(s.ssrcs || []).find(p => p.attribute !== 'msid' ? !1 : p.value.split(' ')[1] === e.id ? (r = p.id, n = p.value.split(' ')[0], !0) : !1)) throw new Error(`a=ssrc line with msid information not found [track.id:${e.id}]`); (s.ssrcGroups || []).some(p => { if (p.semantics !== 'FID') return !1; const u = p.ssrcs.split(/\s+/); return Number(u[0]) === r ? (i = Number(u[1]), !0) : !1 }); const a = s.ssrcs.find(p => p.attribute === 'cname' && p.id === r); if (!a) throw new Error(`a=ssrc line with cname information not found [track.id:${e.id}]`); const o = a.value; const d = []; const l = []; for (let p = 0; p < t; ++p)d.push(r + p), i && l.push(i + p); s.ssrcGroups = s.ssrcGroups || [], s.ssrcs = s.ssrcs || [], s.ssrcGroups.push({ semantics: 'SIM', ssrcs: d.join(' ') }); for (let p = 0; p < d.length; ++p) { const u = d[p]; s.ssrcs.push({ id: u, attribute: 'cname', value: o }), s.ssrcs.push({ id: u, attribute: 'msid', value: `${n} ${e.id}` }) } for (let p = 0; p < l.length; ++p) { const u = d[p]; const h = l[p]; s.ssrcs.push({ id: h, attribute: 'cname', value: o }), s.ssrcs.push({ id: h, attribute: 'msid', value: `${n} ${e.id}` }), s.ssrcGroups.push({ semantics: 'FID', ssrcs: `${u} ${h}` }) } }Ct.addLegacySimulcast = ip }); var Ya = m(ye => { 'use strict'; var np = ye && ye.__createBinding || (Object.create ? function(s, e, t, r) { r === void 0 && (r = t), Object.defineProperty(s, r, { enumerable: !0, get: function() { return e[t] } }) } : function(s, e, t, r) { r === void 0 && (r = t), s[r] = e[t] }); var ap = ye && ye.__setModuleDefault || (Object.create ? function(s, e) { Object.defineProperty(s, 'default', { enumerable: !0, value: e }) } : function(s, e) { s.default = e }); var Gt = ye && ye.__importStar || function(s) { if (s && s.__esModule) return s; var e = {}; if (s != null) for (var t in s)t !== 'default' && Object.hasOwnProperty.call(s, t) && np(e, s, t); return ap(e, s), e }; Object.defineProperty(ye, '__esModule', { value: !0 }); ye.Chrome67 = void 0; var ve = Gt(ce()); var op = A(); var Wa = Gt($()); var Tt = Gt(te()); var qr = Gt(qe()); var Qa = Gt(Kt()); var cp = de(); var dp = Fe(); var w = new op.Logger('Chrome67'); var Ja = { OS: 1024, MIS: 1024 }; var Fr = class extends cp.HandlerInterface {constructor() { super(); this._sendStream = new MediaStream(), this._mapSendLocalIdRtpSender = new Map(), this._nextSendLocalId = 0, this._mapRecvLocalIdInfo = new Map(), this._hasDataChannelMediaSection = !1, this._nextSendSctpStreamId = 0, this._transportReady = !1 }static createFactory() { return () => new Fr() } get name() { return 'Chrome67' }close() { if (w.debug('close()'), this._pc) try { this._pc.close() } catch (e) {} } async getNativeRtpCapabilities() { w.debug('getNativeRtpCapabilities()'); const e = new RTCPeerConnection({ iceServers: [], iceTransportPolicy: 'all', bundlePolicy: 'max-bundle', rtcpMuxPolicy: 'require', sdpSemantics: 'plan-b' }); try { const t = await e.createOffer({ offerToReceiveAudio: !0, offerToReceiveVideo: !0 }); try { e.close() } catch (n) {} const r = ve.parse(t.sdp); return qr.extractRtpCapabilities({ sdpObject: r }) } catch (t) { try { e.close() } catch (r) {} throw t } } async getNativeSctpCapabilities() { return w.debug('getNativeSctpCapabilities()'), { numStreams: Ja } }run({ direction: e, iceParameters: t, iceCandidates: r, dtlsParameters: i, sctpParameters: n, iceServers: c, iceTransportPolicy: a, additionalSettings: o, proprietaryConstraints: d, extendedRtpCapabilities: l }) { w.debug('run()'), this._direction = e, this._remoteSdp = new dp.RemoteSdp({ iceParameters: t, iceCandidates: r, dtlsParameters: i, sctpParameters: n, planB: !0 }), this._sendingRtpParametersByKind = { audio: Tt.getSendingRtpParameters('audio', l), video: Tt.getSendingRtpParameters('video', l) }, this._sendingRemoteRtpParametersByKind = { audio: Tt.getSendingRemoteRtpParameters('audio', l), video: Tt.getSendingRemoteRtpParameters('video', l) }, this._pc = new RTCPeerConnection(Object.assign({ iceServers: c || [], iceTransportPolicy: a || 'all', bundlePolicy: 'max-bundle', rtcpMuxPolicy: 'require', sdpSemantics: 'plan-b' }, o), d), this._pc.addEventListener('iceconnectionstatechange', () => { switch (this._pc.iceConnectionState) { case 'checking':this.emit('@connectionstatechange', 'connecting'); break; case 'connected':case 'completed':this.emit('@connectionstatechange', 'connected'); break; case 'failed':this.emit('@connectionstatechange', 'failed'); break; case 'disconnected':this.emit('@connectionstatechange', 'disconnected'); break; case 'closed':this.emit('@connectionstatechange', 'closed'); break } }) } async updateIceServers(e) { w.debug('updateIceServers()'); const t = this._pc.getConfiguration(); t.iceServers = e, this._pc.setConfiguration(t) } async restartIce(e) { if (w.debug('restartIce()'), this._remoteSdp.updateIceParameters(e), !!this._transportReady) if (this._direction === 'send') { const t = await this._pc.createOffer({ iceRestart: !0 }); w.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', t), await this._pc.setLocalDescription(t); const r = { type: 'answer', sdp: this._remoteSdp.getSdp() }; w.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', r), await this._pc.setRemoteDescription(r) } else { const t = { type: 'offer', sdp: this._remoteSdp.getSdp() }; w.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', t), await this._pc.setRemoteDescription(t); const r = await this._pc.createAnswer(); w.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', r), await this._pc.setLocalDescription(r) } } async getTransportStats() { return this._pc.getStats() } async send({ track: e, encodings: t, codecOptions: r, codec: i }) { this._assertSendDirection(), w.debug('send() [kind:%s, track.id:%s]', e.kind, e.id), i && w.warn('send() | codec selection is not available in %s handler', this.name), this._sendStream.addTrack(e), this._pc.addTrack(e, this._sendStream); let n = await this._pc.createOffer(); let c = ve.parse(n.sdp); let a; const o = Wa.clone(this._sendingRtpParametersByKind[e.kind], {}); o.codecs = Tt.reduceCodecs(o.codecs); const d = Wa.clone(this._sendingRemoteRtpParametersByKind[e.kind], {}); if (d.codecs = Tt.reduceCodecs(d.codecs), this._transportReady || await this._setupTransport({ localDtlsRole: 'server', localSdpObject: c }), e.kind === 'video' && t && t.length > 1 && (w.debug('send() | enabling simulcast'), c = ve.parse(n.sdp), a = c.media.find(h => h.type === 'video'), Qa.addLegacySimulcast({ offerMediaObject: a, track: e, numStreams: t.length }), n = { type: 'offer', sdp: ve.write(c) }), w.debug('send() | calling pc.setLocalDescription() [offer:%o]', n), await this._pc.setLocalDescription(n), c = ve.parse(this._pc.localDescription.sdp), a = c.media.find(h => h.type === e.kind), o.rtcp.cname = qr.getCname({ offerMediaObject: a }), o.encodings = Qa.getRtpEncodings({ offerMediaObject: a, track: e }), t) for (let h = 0; h < o.encodings.length; ++h)t[h] && Object.assign(o.encodings[h], t[h]); if (o.encodings.length > 1 && o.codecs[0].mimeType.toLowerCase() === 'video/vp8') for (const h of o.encodings)h.scalabilityMode = 'S1T3'; this._remoteSdp.send({ offerMediaObject: a, offerRtpParameters: o, answerRtpParameters: d, codecOptions: r }); const l = { type: 'answer', sdp: this._remoteSdp.getSdp() }; w.debug('send() | calling pc.setRemoteDescription() [answer:%o]', l), await this._pc.setRemoteDescription(l); const p = String(this._nextSendLocalId); this._nextSendLocalId++; const u = this._pc.getSenders().find(h => h.track === e); return this._mapSendLocalIdRtpSender.set(p, u), { localId: p, rtpParameters: o, rtpSender: u } } async stopSending(e) { this._assertSendDirection(), w.debug('stopSending() [localId:%s]', e); const t = this._mapSendLocalIdRtpSender.get(e); if (!t) throw new Error('associated RTCRtpSender not found'); this._pc.removeTrack(t), t.track && this._sendStream.removeTrack(t.track), this._mapSendLocalIdRtpSender.delete(e); const r = await this._pc.createOffer(); w.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', r); try { await this._pc.setLocalDescription(r) } catch (n) { if (this._sendStream.getTracks().length === 0) { w.warn('stopSending() | ignoring expected error due no sending tracks: %s', n.toString()); return } throw n } if (this._pc.signalingState === 'stable') return; const i = { type: 'answer', sdp: this._remoteSdp.getSdp() }; w.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', i), await this._pc.setRemoteDescription(i) } async replaceTrack(e, t) { this._assertSendDirection(), t ? w.debug('replaceTrack() [localId:%s, track.id:%s]', e, t.id) : w.debug('replaceTrack() [localId:%s, no track]', e); const r = this._mapSendLocalIdRtpSender.get(e); if (!r) throw new Error('associated RTCRtpSender not found'); const i = r.track; await r.replaceTrack(t), i && this._sendStream.removeTrack(i), t && this._sendStream.addTrack(t) } async setMaxSpatialLayer(e, t) { this._assertSendDirection(), w.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', e, t); const r = this._mapSendLocalIdRtpSender.get(e); if (!r) throw new Error('associated RTCRtpSender not found'); const i = r.getParameters(); i.encodings.forEach((n, c) => { c <= t ? n.active = !0 : n.active = !1 }), await r.setParameters(i) } async setRtpEncodingParameters(e, t) { this._assertSendDirection(), w.debug('setRtpEncodingParameters() [localId:%s, params:%o]', e, t); const r = this._mapSendLocalIdRtpSender.get(e); if (!r) throw new Error('associated RTCRtpSender not found'); const i = r.getParameters(); i.encodings.forEach((n, c) => { i.encodings[c] = Object.assign(Object.assign({}, n), t) }), await r.setParameters(i) } async getSenderStats(e) { this._assertSendDirection(); const t = this._mapSendLocalIdRtpSender.get(e); if (!t) throw new Error('associated RTCRtpSender not found'); return t.getStats() } async sendDataChannel({ ordered: e, maxPacketLifeTime: t, maxRetransmits: r, label: i, protocol: n, priority: c }) { this._assertSendDirection(); const a = { negotiated: !0, id: this._nextSendSctpStreamId, ordered: e, maxPacketLifeTime: t, maxRetransmitTime: t, maxRetransmits: r, protocol: n, priority: c }; w.debug('sendDataChannel() [options:%o]', a); const o = this._pc.createDataChannel(i, a); if (this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % Ja.MIS, !this._hasDataChannelMediaSection) { const l = await this._pc.createOffer(); const p = ve.parse(l.sdp); const u = p.media.find(f => f.type === 'application'); this._transportReady || await this._setupTransport({ localDtlsRole: 'server', localSdpObject: p }), w.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', l), await this._pc.setLocalDescription(l), this._remoteSdp.sendSctpAssociation({ offerMediaObject: u }); const h = { type: 'answer', sdp: this._remoteSdp.getSdp() }; w.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', h), await this._pc.setRemoteDescription(h), this._hasDataChannelMediaSection = !0 } const d = { streamId: a.id, ordered: a.ordered, maxPacketLifeTime: a.maxPacketLifeTime, maxRetransmits: a.maxRetransmits }; return { dataChannel: o, sctpStreamParameters: d } } async receive({ trackId: e, kind: t, rtpParameters: r }) { this._assertRecvDirection(), w.debug('receive() [trackId:%s, kind:%s]', e, t); const i = e; const n = t; this._remoteSdp.receive({ mid: n, kind: t, offerRtpParameters: r, streamId: r.rtcp.cname, trackId: e }); const c = { type: 'offer', sdp: this._remoteSdp.getSdp() }; w.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', c), await this._pc.setRemoteDescription(c); let a = await this._pc.createAnswer(); const o = ve.parse(a.sdp); const d = o.media.find(p => String(p.mid) === n); qr.applyCodecParameters({ offerRtpParameters: r, answerMediaObject: d }), a = { type: 'answer', sdp: ve.write(o) }, this._transportReady || await this._setupTransport({ localDtlsRole: 'client', localSdpObject: o }), w.debug('receive() | calling pc.setLocalDescription() [answer:%o]', a), await this._pc.setLocalDescription(a); const l = this._pc.getReceivers().find(p => p.track && p.track.id === i); if (!l) throw new Error('new RTCRtpReceiver not'); return this._mapRecvLocalIdInfo.set(i, { mid: n, rtpParameters: r, rtpReceiver: l }), { localId: i, track: l.track, rtpReceiver: l } } async stopReceiving(e) { this._assertRecvDirection(), w.debug('stopReceiving() [localId:%s]', e); const { mid: t, rtpParameters: r } = this._mapRecvLocalIdInfo.get(e) || {}; this._mapRecvLocalIdInfo.delete(e), this._remoteSdp.planBStopReceiving({ mid: t, offerRtpParameters: r }); const i = { type: 'offer', sdp: this._remoteSdp.getSdp() }; w.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', i), await this._pc.setRemoteDescription(i); const n = await this._pc.createAnswer(); w.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', n), await this._pc.setLocalDescription(n) } async getReceiverStats(e) { this._assertRecvDirection(); const { rtpReceiver: t } = this._mapRecvLocalIdInfo.get(e) || {}; if (!t) throw new Error('associated RTCRtpReceiver not found'); return t.getStats() } async receiveDataChannel({ sctpStreamParameters: e, label: t, protocol: r }) { this._assertRecvDirection(); const { streamId: i, ordered: n, maxPacketLifeTime: c, maxRetransmits: a } = e; const o = { negotiated: !0, id: i, ordered: n, maxPacketLifeTime: c, maxRetransmitTime: c, maxRetransmits: a, protocol: r }; w.debug('receiveDataChannel() [options:%o]', o); const d = this._pc.createDataChannel(t, o); if (!this._hasDataChannelMediaSection) { this._remoteSdp.receiveSctpAssociation({ oldDataChannelSpec: !0 }); const l = { type: 'offer', sdp: this._remoteSdp.getSdp() }; w.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', l), await this._pc.setRemoteDescription(l); const p = await this._pc.createAnswer(); if (!this._transportReady) { const u = ve.parse(p.sdp); await this._setupTransport({ localDtlsRole: 'client', localSdpObject: u }) }w.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', p), await this._pc.setLocalDescription(p), this._hasDataChannelMediaSection = !0 } return { dataChannel: d } } async _setupTransport({ localDtlsRole: e, localSdpObject: t }) { t || (t = ve.parse(this._pc.localDescription.sdp)); const r = qr.extractDtlsParameters({ sdpObject: t }); r.role = e, this._remoteSdp.updateDtlsRole(e === 'client' ? 'server' : 'client'), await this.safeEmitAsPromise('@connect', { dtlsParameters: r }), this._transportReady = !0 }_assertSendDirection() { if (this._direction !== 'send') throw new Error('method can just be called for handlers with "send" direction') }_assertRecvDirection() { if (this._direction !== 'recv') throw new Error('method can just be called for handlers with "recv" direction') }}; ye.Chrome67 = Fr }); var to = m(we => { 'use strict'; var lp = we && we.__createBinding || (Object.create ? function(s, e, t, r) { r === void 0 && (r = t), Object.defineProperty(s, r, { enumerable: !0, get: function() { return e[t] } }) } : function(s, e, t, r) { r === void 0 && (r = t), s[r] = e[t] }); var pp = we && we.__setModuleDefault || (Object.create ? function(s, e) { Object.defineProperty(s, 'default', { enumerable: !0, value: e }) } : function(s, e) { s.default = e }); var Wt = we && we.__importStar || function(s) { if (s && s.__esModule) return s; var e = {}; if (s != null) for (var t in s)t !== 'default' && Object.hasOwnProperty.call(s, t) && lp(e, s, t); return pp(e, s), e }; Object.defineProperty(we, '__esModule', { value: !0 }); we.Chrome55 = void 0; var be = Wt(ce()); var up = A(); var Qt = oe(); var Xa = Wt($()); var Pt = Wt(te()); var Nr = Wt(qe()); var Za = Wt(Kt()); var hp = de(); var fp = Fe(); var P = new up.Logger('Chrome55'); var eo = { OS: 1024, MIS: 1024 }; var Ur = class extends hp.HandlerInterface {constructor() { super(); this._sendStream = new MediaStream(), this._mapSendLocalIdTrack = new Map(), this._nextSendLocalId = 0, this._mapRecvLocalIdInfo = new Map(), this._hasDataChannelMediaSection = !1, this._nextSendSctpStreamId = 0, this._transportReady = !1 }static createFactory() { return () => new Ur() } get name() { return 'Chrome55' }close() { if (P.debug('close()'), this._pc) try { this._pc.close() } catch (e) {} } async getNativeRtpCapabilities() { P.debug('getNativeRtpCapabilities()'); const e = new RTCPeerConnection({ iceServers: [], iceTransportPolicy: 'all', bundlePolicy: 'max-bundle', rtcpMuxPolicy: 'require', sdpSemantics: 'plan-b' }); try { const t = await e.createOffer({ offerToReceiveAudio: !0, offerToReceiveVideo: !0 }); try { e.close() } catch (n) {} const r = be.parse(t.sdp); return Nr.extractRtpCapabilities({ sdpObject: r }) } catch (t) { try { e.close() } catch (r) {} throw t } } async getNativeSctpCapabilities() { return P.debug('getNativeSctpCapabilities()'), { numStreams: eo } }run({ direction: e, iceParameters: t, iceCandidates: r, dtlsParameters: i, sctpParameters: n, iceServers: c, iceTransportPolicy: a, additionalSettings: o, proprietaryConstraints: d, extendedRtpCapabilities: l }) { P.debug('run()'), this._direction = e, this._remoteSdp = new fp.RemoteSdp({ iceParameters: t, iceCandidates: r, dtlsParameters: i, sctpParameters: n, planB: !0 }), this._sendingRtpParametersByKind = { audio: Pt.getSendingRtpParameters('audio', l), video: Pt.getSendingRtpParameters('video', l) }, this._sendingRemoteRtpParametersByKind = { audio: Pt.getSendingRemoteRtpParameters('audio', l), video: Pt.getSendingRemoteRtpParameters('video', l) }, this._pc = new RTCPeerConnection(Object.assign({ iceServers: c || [], iceTransportPolicy: a || 'all', bundlePolicy: 'max-bundle', rtcpMuxPolicy: 'require', sdpSemantics: 'plan-b' }, o), d), this._pc.addEventListener('iceconnectionstatechange', () => { switch (this._pc.iceConnectionState) { case 'checking':this.emit('@connectionstatechange', 'connecting'); break; case 'connected':case 'completed':this.emit('@connectionstatechange', 'connected'); break; case 'failed':this.emit('@connectionstatechange', 'failed'); break; case 'disconnected':this.emit('@connectionstatechange', 'disconnected'); break; case 'closed':this.emit('@connectionstatechange', 'closed'); break } }) } async updateIceServers(e) { P.debug('updateIceServers()'); const t = this._pc.getConfiguration(); t.iceServers = e, this._pc.setConfiguration(t) } async restartIce(e) { if (P.debug('restartIce()'), this._remoteSdp.updateIceParameters(e), !!this._transportReady) if (this._direction === 'send') { const t = await this._pc.createOffer({ iceRestart: !0 }); P.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', t), await this._pc.setLocalDescription(t); const r = { type: 'answer', sdp: this._remoteSdp.getSdp() }; P.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', r), await this._pc.setRemoteDescription(r) } else { const t = { type: 'offer', sdp: this._remoteSdp.getSdp() }; P.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', t), await this._pc.setRemoteDescription(t); const r = await this._pc.createAnswer(); P.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', r), await this._pc.setLocalDescription(r) } } async getTransportStats() { return this._pc.getStats() } async send({ track: e, encodings: t, codecOptions: r, codec: i }) { this._assertSendDirection(), P.debug('send() [kind:%s, track.id:%s]', e.kind, e.id), i && P.warn('send() | codec selection is not available in %s handler', this.name), this._sendStream.addTrack(e), this._pc.addStream(this._sendStream); let n = await this._pc.createOffer(); let c = be.parse(n.sdp); let a; const o = Xa.clone(this._sendingRtpParametersByKind[e.kind], {}); o.codecs = Pt.reduceCodecs(o.codecs); const d = Xa.clone(this._sendingRemoteRtpParametersByKind[e.kind], {}); if (d.codecs = Pt.reduceCodecs(d.codecs), this._transportReady || await this._setupTransport({ localDtlsRole: 'server', localSdpObject: c }), e.kind === 'video' && t && t.length > 1 && (P.debug('send() | enabling simulcast'), c = be.parse(n.sdp), a = c.media.find(u => u.type === 'video'), Za.addLegacySimulcast({ offerMediaObject: a, track: e, numStreams: t.length }), n = { type: 'offer', sdp: be.write(c) }), P.debug('send() | calling pc.setLocalDescription() [offer:%o]', n), await this._pc.setLocalDescription(n), c = be.parse(this._pc.localDescription.sdp), a = c.media.find(u => u.type === e.kind), o.rtcp.cname = Nr.getCname({ offerMediaObject: a }), o.encodings = Za.getRtpEncodings({ offerMediaObject: a, track: e }), t) for (let u = 0; u < o.encodings.length; ++u)t[u] && Object.assign(o.encodings[u], t[u]); if (o.encodings.length > 1 && o.codecs[0].mimeType.toLowerCase() === 'video/vp8') for (const u of o.encodings)u.scalabilityMode = 'S1T3'; this._remoteSdp.send({ offerMediaObject: a, offerRtpParameters: o, answerRtpParameters: d, codecOptions: r }); const l = { type: 'answer', sdp: this._remoteSdp.getSdp() }; P.debug('send() | calling pc.setRemoteDescription() [answer:%o]', l), await this._pc.setRemoteDescription(l); const p = String(this._nextSendLocalId); return this._nextSendLocalId++, this._mapSendLocalIdTrack.set(p, e), { localId: p, rtpParameters: o } } async stopSending(e) { this._assertSendDirection(), P.debug('stopSending() [localId:%s]', e); const t = this._mapSendLocalIdTrack.get(e); if (!t) throw new Error('track not found'); this._mapSendLocalIdTrack.delete(e), this._sendStream.removeTrack(t), this._pc.addStream(this._sendStream); const r = await this._pc.createOffer(); P.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', r); try { await this._pc.setLocalDescription(r) } catch (n) { if (this._sendStream.getTracks().length === 0) { P.warn('stopSending() | ignoring expected error due no sending tracks: %s', n.toString()); return } throw n } if (this._pc.signalingState === 'stable') return; const i = { type: 'answer', sdp: this._remoteSdp.getSdp() }; P.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', i), await this._pc.setRemoteDescription(i) } async replaceTrack(e, t) { throw new Qt.UnsupportedError('not implemented') } async setMaxSpatialLayer(e, t) { throw new Qt.UnsupportedError(' not implemented') } async setRtpEncodingParameters(e, t) { throw new Qt.UnsupportedError('not supported') } async getSenderStats(e) { throw new Qt.UnsupportedError('not implemented') } async sendDataChannel({ ordered: e, maxPacketLifeTime: t, maxRetransmits: r, label: i, protocol: n, priority: c }) { this._assertSendDirection(); const a = { negotiated: !0, id: this._nextSendSctpStreamId, ordered: e, maxPacketLifeTime: t, maxRetransmitTime: t, maxRetransmits: r, protocol: n, priority: c }; P.debug('sendDataChannel() [options:%o]', a); const o = this._pc.createDataChannel(i, a); if (this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % eo.MIS, !this._hasDataChannelMediaSection) { const l = await this._pc.createOffer(); const p = be.parse(l.sdp); const u = p.media.find(f => f.type === 'application'); this._transportReady || await this._setupTransport({ localDtlsRole: 'server', localSdpObject: p }), P.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', l), await this._pc.setLocalDescription(l), this._remoteSdp.sendSctpAssociation({ offerMediaObject: u }); const h = { type: 'answer', sdp: this._remoteSdp.getSdp() }; P.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', h), await this._pc.setRemoteDescription(h), this._hasDataChannelMediaSection = !0 } const d = { streamId: a.id, ordered: a.ordered, maxPacketLifeTime: a.maxPacketLifeTime, maxRetransmits: a.maxRetransmits }; return { dataChannel: o, sctpStreamParameters: d } } async receive({ trackId: e, kind: t, rtpParameters: r }) { this._assertRecvDirection(), P.debug('receive() [trackId:%s, kind:%s]', e, t); const i = e; const n = t; const c = r.rtcp.cname; this._remoteSdp.receive({ mid: n, kind: t, offerRtpParameters: r, streamId: c, trackId: e }); const a = { type: 'offer', sdp: this._remoteSdp.getSdp() }; P.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', a), await this._pc.setRemoteDescription(a); let o = await this._pc.createAnswer(); const d = be.parse(o.sdp); const l = d.media.find(h => String(h.mid) === n); Nr.applyCodecParameters({ offerRtpParameters: r, answerMediaObject: l }), o = { type: 'answer', sdp: be.write(d) }, this._transportReady || await this._setupTransport({ localDtlsRole: 'client', localSdpObject: d }), P.debug('receive() | calling pc.setLocalDescription() [answer:%o]', o), await this._pc.setLocalDescription(o); const u = this._pc.getRemoteStreams().find(h => h.id === c).getTrackById(i); if (!u) throw new Error('remote track not found'); return this._mapRecvLocalIdInfo.set(i, { mid: n, rtpParameters: r }), { localId: i, track: u } } async stopReceiving(e) { this._assertRecvDirection(), P.debug('stopReceiving() [localId:%s]', e); const { mid: t, rtpParameters: r } = this._mapRecvLocalIdInfo.get(e) || {}; this._mapRecvLocalIdInfo.delete(e), this._remoteSdp.planBStopReceiving({ mid: t, offerRtpParameters: r }); const i = { type: 'offer', sdp: this._remoteSdp.getSdp() }; P.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', i), await this._pc.setRemoteDescription(i); const n = await this._pc.createAnswer(); P.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', n), await this._pc.setLocalDescription(n) } async getReceiverStats(e) { throw new Qt.UnsupportedError('not implemented') } async receiveDataChannel({ sctpStreamParameters: e, label: t, protocol: r }) { this._assertRecvDirection(); const { streamId: i, ordered: n, maxPacketLifeTime: c, maxRetransmits: a } = e; const o = { negotiated: !0, id: i, ordered: n, maxPacketLifeTime: c, maxRetransmitTime: c, maxRetransmits: a, protocol: r }; P.debug('receiveDataChannel() [options:%o]', o); const d = this._pc.createDataChannel(t, o); if (!this._hasDataChannelMediaSection) { this._remoteSdp.receiveSctpAssociation({ oldDataChannelSpec: !0 }); const l = { type: 'offer', sdp: this._remoteSdp.getSdp() }; P.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', l), await this._pc.setRemoteDescription(l); const p = await this._pc.createAnswer(); if (!this._transportReady) { const u = be.parse(p.sdp); await this._setupTransport({ localDtlsRole: 'client', localSdpObject: u }) }P.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', p), await this._pc.setLocalDescription(p), this._hasDataChannelMediaSection = !0 } return { dataChannel: d } } async _setupTransport({ localDtlsRole: e, localSdpObject: t }) { t || (t = be.parse(this._pc.localDescription.sdp)); const r = Nr.extractDtlsParameters({ sdpObject: t }); r.role = e, this._remoteSdp.updateDtlsRole(e === 'client' ? 'server' : 'client'), await this.safeEmitAsPromise('@connect', { dtlsParameters: r }), this._transportReady = !0 }_assertSendDirection() { if (this._direction !== 'send') throw new Error('method can just be called for handlers with "send" direction') }_assertRecvDirection() { if (this._direction !== 'recv') throw new Error('method can just be called for handlers with "recv" direction') }}; we.Chrome55 = Ur }); var io = m(Se => { 'use strict'; var mp = Se && Se.__createBinding || (Object.create ? function(s, e, t, r) { r === void 0 && (r = t), Object.defineProperty(s, r, { enumerable: !0, get: function() { return e[t] } }) } : function(s, e, t, r) { r === void 0 && (r = t), s[r] = e[t] }); var gp = Se && Se.__setModuleDefault || (Object.create ? function(s, e) { Object.defineProperty(s, 'default', { enumerable: !0, value: e }) } : function(s, e) { s.default = e }); var Jt = Se && Se.__importStar || function(s) { if (s && s.__esModule) return s; var e = {}; if (s != null) for (var t in s)t !== 'default' && Object.hasOwnProperty.call(s, t) && mp(e, s, t); return gp(e, s), e }; Object.defineProperty(Se, '__esModule', { value: !0 }); Se.Firefox60 = void 0; var He = Jt(ce()); var _p = A(); var vp = oe(); var Gs = Jt($()); var Et = Jt(te()); var zr = Jt(qe()); var ro = Jt(Vt()); var yp = de(); var bp = Fe(); var E = new _p.Logger('Firefox60'); var so = { OS: 16, MIS: 2048 }; var Vr = class extends yp.HandlerInterface {constructor() { super(); this._mapMidTransceiver = new Map(), this._sendStream = new MediaStream(), this._hasDataChannelMediaSection = !1, this._nextSendSctpStreamId = 0, this._transportReady = !1 }static createFactory() { return () => new Vr() } get name() { return 'Firefox60' }close() { if (E.debug('close()'), this._pc) try { this._pc.close() } catch (e) {} } async getNativeRtpCapabilities() { E.debug('getNativeRtpCapabilities()'); const e = new RTCPeerConnection({ iceServers: [], iceTransportPolicy: 'all', bundlePolicy: 'max-bundle', rtcpMuxPolicy: 'require' }); const t = document.createElement('canvas'); t.getContext('2d'); const i = t.captureStream().getVideoTracks()[0]; try { e.addTransceiver('audio', { direction: 'sendrecv' }); const n = e.addTransceiver(i, { direction: 'sendrecv' }); const c = n.sender.getParameters(); const a = [{ rid: 'r0', maxBitrate: 1e5 }, { rid: 'r1', maxBitrate: 5e5 }]; c.encodings = a, await n.sender.setParameters(c); const o = await e.createOffer(); try { t.remove() } catch (p) {} try { i.stop() } catch (p) {} try { e.close() } catch (p) {} const d = He.parse(o.sdp); return zr.extractRtpCapabilities({ sdpObject: d }) } catch (n) { try { t.remove() } catch (c) {} try { i.stop() } catch (c) {} try { e.close() } catch (c) {} throw n } } async getNativeSctpCapabilities() { return E.debug('getNativeSctpCapabilities()'), { numStreams: so } }run({ direction: e, iceParameters: t, iceCandidates: r, dtlsParameters: i, sctpParameters: n, iceServers: c, iceTransportPolicy: a, additionalSettings: o, proprietaryConstraints: d, extendedRtpCapabilities: l }) { E.debug('run()'), this._direction = e, this._remoteSdp = new bp.RemoteSdp({ iceParameters: t, iceCandidates: r, dtlsParameters: i, sctpParameters: n }), this._sendingRtpParametersByKind = { audio: Et.getSendingRtpParameters('audio', l), video: Et.getSendingRtpParameters('video', l) }, this._sendingRemoteRtpParametersByKind = { audio: Et.getSendingRemoteRtpParameters('audio', l), video: Et.getSendingRemoteRtpParameters('video', l) }, this._pc = new RTCPeerConnection(Object.assign({ iceServers: c || [], iceTransportPolicy: a || 'all', bundlePolicy: 'max-bundle', rtcpMuxPolicy: 'require' }, o), d), this._pc.addEventListener('iceconnectionstatechange', () => { switch (this._pc.iceConnectionState) { case 'checking':this.emit('@connectionstatechange', 'connecting'); break; case 'connected':case 'completed':this.emit('@connectionstatechange', 'connected'); break; case 'failed':this.emit('@connectionstatechange', 'failed'); break; case 'disconnected':this.emit('@connectionstatechange', 'disconnected'); break; case 'closed':this.emit('@connectionstatechange', 'closed'); break } }) } async updateIceServers(e) { throw new vp.UnsupportedError('not supported') } async restartIce(e) { if (E.debug('restartIce()'), this._remoteSdp.updateIceParameters(e), !!this._transportReady) if (this._direction === 'send') { const t = await this._pc.createOffer({ iceRestart: !0 }); E.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', t), await this._pc.setLocalDescription(t); const r = { type: 'answer', sdp: this._remoteSdp.getSdp() }; E.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', r), await this._pc.setRemoteDescription(r) } else { const t = { type: 'offer', sdp: this._remoteSdp.getSdp() }; E.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', t), await this._pc.setRemoteDescription(t); const r = await this._pc.createAnswer(); E.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', r), await this._pc.setLocalDescription(r) } } async getTransportStats() { return this._pc.getStats() } async send({ track: e, encodings: t, codecOptions: r, codec: i }) { this._assertSendDirection(), E.debug('send() [kind:%s, track.id:%s]', e.kind, e.id), t && (t = Gs.clone(t, []), t.length > 1 && (t.forEach((h, f) => { h.rid = `r${f}` }), t.reverse())); const n = Gs.clone(this._sendingRtpParametersByKind[e.kind], {}); n.codecs = Et.reduceCodecs(n.codecs, i); const c = Gs.clone(this._sendingRemoteRtpParametersByKind[e.kind], {}); c.codecs = Et.reduceCodecs(c.codecs, i); const a = this._pc.addTransceiver(e, { direction: 'sendonly', streams: [this._sendStream] }); if (t) { const h = a.sender.getParameters(); h.encodings = t, await a.sender.setParameters(h) } const o = await this._pc.createOffer(); let d = He.parse(o.sdp); this._transportReady || await this._setupTransport({ localDtlsRole: 'client', localSdpObject: d }), E.debug('send() | calling pc.setLocalDescription() [offer:%o]', o), await this._pc.setLocalDescription(o); const l = a.mid; n.mid = l, d = He.parse(this._pc.localDescription.sdp); const p = d.media[d.media.length - 1]; if (n.rtcp.cname = zr.getCname({ offerMediaObject: p }), !t)n.encodings = ro.getRtpEncodings({ offerMediaObject: p }); else if (t.length === 1) { const h = ro.getRtpEncodings({ offerMediaObject: p }); Object.assign(h[0], t[0]), n.encodings = h } else n.encodings = t.reverse(); if (n.encodings.length > 1 && (n.codecs[0].mimeType.toLowerCase() === 'video/vp8' || n.codecs[0].mimeType.toLowerCase() === 'video/h264')) for (const h of n.encodings)h.scalabilityMode = 'S1T3'; this._remoteSdp.send({ offerMediaObject: p, offerRtpParameters: n, answerRtpParameters: c, codecOptions: r, extmapAllowMixed: !0 }); const u = { type: 'answer', sdp: this._remoteSdp.getSdp() }; return E.debug('send() | calling pc.setRemoteDescription() [answer:%o]', u), await this._pc.setRemoteDescription(u), this._mapMidTransceiver.set(l, a), { localId: l, rtpParameters: n, rtpSender: a.sender } } async stopSending(e) { E.debug('stopSending() [localId:%s]', e); const t = this._mapMidTransceiver.get(e); if (!t) throw new Error('associated transceiver not found'); t.sender.replaceTrack(null), this._pc.removeTrack(t.sender), this._remoteSdp.disableMediaSection(t.mid); const r = await this._pc.createOffer(); E.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', r), await this._pc.setLocalDescription(r); const i = { type: 'answer', sdp: this._remoteSdp.getSdp() }; E.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', i), await this._pc.setRemoteDescription(i) } async replaceTrack(e, t) { this._assertSendDirection(), t ? E.debug('replaceTrack() [localId:%s, track.id:%s]', e, t.id) : E.debug('replaceTrack() [localId:%s, no track]', e); const r = this._mapMidTransceiver.get(e); if (!r) throw new Error('associated RTCRtpTransceiver not found'); await r.sender.replaceTrack(t) } async setMaxSpatialLayer(e, t) { this._assertSendDirection(), E.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', e, t); const r = this._mapMidTransceiver.get(e); if (!r) throw new Error('associated transceiver not found'); const i = r.sender.getParameters(); t = i.encodings.length - 1 - t, i.encodings.forEach((n, c) => { c >= t ? n.active = !0 : n.active = !1 }), await r.sender.setParameters(i) } async setRtpEncodingParameters(e, t) { this._assertSendDirection(), E.debug('setRtpEncodingParameters() [localId:%s, params:%o]', e, t); const r = this._mapMidTransceiver.get(e); if (!r) throw new Error('associated RTCRtpTransceiver not found'); const i = r.sender.getParameters(); i.encodings.forEach((n, c) => { i.encodings[c] = Object.assign(Object.assign({}, n), t) }), await r.sender.setParameters(i) } async getSenderStats(e) { this._assertSendDirection(); const t = this._mapMidTransceiver.get(e); if (!t) throw new Error('associated RTCRtpTransceiver not found'); return t.sender.getStats() } async sendDataChannel({ ordered: e, maxPacketLifeTime: t, maxRetransmits: r, label: i, protocol: n, priority: c }) { this._assertSendDirection(); const a = { negotiated: !0, id: this._nextSendSctpStreamId, ordered: e, maxPacketLifeTime: t, maxRetransmits: r, protocol: n, priority: c }; E.debug('sendDataChannel() [options:%o]', a); const o = this._pc.createDataChannel(i, a); if (this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % so.MIS, !this._hasDataChannelMediaSection) { const l = await this._pc.createOffer(); const p = He.parse(l.sdp); const u = p.media.find(f => f.type === 'application'); this._transportReady || await this._setupTransport({ localDtlsRole: 'server', localSdpObject: p }), E.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', l), await this._pc.setLocalDescription(l), this._remoteSdp.sendSctpAssociation({ offerMediaObject: u }); const h = { type: 'answer', sdp: this._remoteSdp.getSdp() }; E.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', h), await this._pc.setRemoteDescription(h), this._hasDataChannelMediaSection = !0 } const d = { streamId: a.id, ordered: a.ordered, maxPacketLifeTime: a.maxPacketLifeTime, maxRetransmits: a.maxRetransmits }; return { dataChannel: o, sctpStreamParameters: d } } async receive({ trackId: e, kind: t, rtpParameters: r }) { this._assertRecvDirection(), E.debug('receive() [trackId:%s, kind:%s]', e, t); const i = r.mid || String(this._mapMidTransceiver.size); this._remoteSdp.receive({ mid: i, kind: t, offerRtpParameters: r, streamId: r.rtcp.cname, trackId: e }); const n = { type: 'offer', sdp: this._remoteSdp.getSdp() }; E.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', n), await this._pc.setRemoteDescription(n); let c = await this._pc.createAnswer(); const a = He.parse(c.sdp); const o = a.media.find(l => String(l.mid) === i); zr.applyCodecParameters({ offerRtpParameters: r, answerMediaObject: o }), c = { type: 'answer', sdp: He.write(a) }, this._transportReady || await this._setupTransport({ localDtlsRole: 'client', localSdpObject: a }), E.debug('receive() | calling pc.setLocalDescription() [answer:%o]', c), await this._pc.setLocalDescription(c); const d = this._pc.getTransceivers().find(l => l.mid === i); if (!d) throw new Error('new RTCRtpTransceiver not found'); return this._mapMidTransceiver.set(i, d), { localId: i, track: d.receiver.track, rtpReceiver: d.receiver } } async stopReceiving(e) { this._assertRecvDirection(), E.debug('stopReceiving() [localId:%s]', e); const t = this._mapMidTransceiver.get(e); if (!t) throw new Error('associated RTCRtpTransceiver not found'); this._remoteSdp.closeMediaSection(t.mid); const r = { type: 'offer', sdp: this._remoteSdp.getSdp() }; E.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', r), await this._pc.setRemoteDescription(r); const i = await this._pc.createAnswer(); E.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', i), await this._pc.setLocalDescription(i) } async getReceiverStats(e) { this._assertRecvDirection(); const t = this._mapMidTransceiver.get(e); if (!t) throw new Error('associated RTCRtpTransceiver not found'); return t.receiver.getStats() } async receiveDataChannel({ sctpStreamParameters: e, label: t, protocol: r }) { this._assertRecvDirection(); const { streamId: i, ordered: n, maxPacketLifeTime: c, maxRetransmits: a } = e; const o = { negotiated: !0, id: i, ordered: n, maxPacketLifeTime: c, maxRetransmits: a, protocol: r }; E.debug('receiveDataChannel() [options:%o]', o); const d = this._pc.createDataChannel(t, o); if (!this._hasDataChannelMediaSection) { this._remoteSdp.receiveSctpAssociation(); const l = { type: 'offer', sdp: this._remoteSdp.getSdp() }; E.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', l), await this._pc.setRemoteDescription(l); const p = await this._pc.createAnswer(); if (!this._transportReady) { const u = He.parse(p.sdp); await this._setupTransport({ localDtlsRole: 'client', localSdpObject: u }) }E.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', p), await this._pc.setLocalDescription(p), this._hasDataChannelMediaSection = !0 } return { dataChannel: d } } async _setupTransport({ localDtlsRole: e, localSdpObject: t }) { t || (t = He.parse(this._pc.localDescription.sdp)); const r = zr.extractDtlsParameters({ sdpObject: t }); r.role = e, this._remoteSdp.updateDtlsRole(e === 'client' ? 'server' : 'client'), await this.safeEmitAsPromise('@connect', { dtlsParameters: r }), this._transportReady = !0 }_assertSendDirection() { if (this._direction !== 'send') throw new Error('method can just be called for handlers with "send" direction') }_assertRecvDirection() { if (this._direction !== 'recv') throw new Error('method can just be called for handlers with "recv" direction') }}; Se.Firefox60 = Vr }); var co = m(Ce => { 'use strict'; var wp = Ce && Ce.__createBinding || (Object.create ? function(s, e, t, r) { r === void 0 && (r = t), Object.defineProperty(s, r, { enumerable: !0, get: function() { return e[t] } }) } : function(s, e, t, r) { r === void 0 && (r = t), s[r] = e[t] }); var Sp = Ce && Ce.__setModuleDefault || (Object.create ? function(s, e) { Object.defineProperty(s, 'default', { enumerable: !0, value: e }) } : function(s, e) { s.default = e }); var Yt = Ce && Ce.__importStar || function(s) { if (s && s.__esModule) return s; var e = {}; if (s != null) for (var t in s)t !== 'default' && Object.hasOwnProperty.call(s, t) && wp(e, s, t); return Sp(e, s), e }; Object.defineProperty(Ce, '__esModule', { value: !0 }); Ce.Safari12 = void 0; var Re = Yt(ce()); var Rp = A(); var no = Yt($()); var Dt = Yt(te()); var $r = Yt(qe()); var ao = Yt(Vt()); var Cp = de(); var Tp = Fe(); var C = new Rp.Logger('Safari12'); var oo = { OS: 1024, MIS: 1024 }; var Hr = class extends Cp.HandlerInterface {constructor() { super(); this._mapMidTransceiver = new Map(), this._sendStream = new MediaStream(), this._hasDataChannelMediaSection = !1, this._nextSendSctpStreamId = 0, this._transportReady = !1 }static createFactory() { return () => new Hr() } get name() { return 'Safari12' }close() { if (C.debug('close()'), this._pc) try { this._pc.close() } catch (e) {} } async getNativeRtpCapabilities() { C.debug('getNativeRtpCapabilities()'); const e = new RTCPeerConnection({ iceServers: [], iceTransportPolicy: 'all', bundlePolicy: 'max-bundle', rtcpMuxPolicy: 'require' }); try { e.addTransceiver('audio'), e.addTransceiver('video'); const t = await e.createOffer(); try { e.close() } catch (n) {} const r = Re.parse(t.sdp); return $r.extractRtpCapabilities({ sdpObject: r }) } catch (t) { try { e.close() } catch (r) {} throw t } } async getNativeSctpCapabilities() { return C.debug('getNativeSctpCapabilities()'), { numStreams: oo } }run({ direction: e, iceParameters: t, iceCandidates: r, dtlsParameters: i, sctpParameters: n, iceServers: c, iceTransportPolicy: a, additionalSettings: o, proprietaryConstraints: d, extendedRtpCapabilities: l }) { C.debug('run()'), this._direction = e, this._remoteSdp = new Tp.RemoteSdp({ iceParameters: t, iceCandidates: r, dtlsParameters: i, sctpParameters: n }), this._sendingRtpParametersByKind = { audio: Dt.getSendingRtpParameters('audio', l), video: Dt.getSendingRtpParameters('video', l) }, this._sendingRemoteRtpParametersByKind = { audio: Dt.getSendingRemoteRtpParameters('audio', l), video: Dt.getSendingRemoteRtpParameters('video', l) }, this._pc = new RTCPeerConnection(Object.assign({ iceServers: c || [], iceTransportPolicy: a || 'all', bundlePolicy: 'max-bundle', rtcpMuxPolicy: 'require' }, o), d), this._pc.addEventListener('iceconnectionstatechange', () => { switch (this._pc.iceConnectionState) { case 'checking':this.emit('@connectionstatechange', 'connecting'); break; case 'connected':case 'completed':this.emit('@connectionstatechange', 'connected'); break; case 'failed':this.emit('@connectionstatechange', 'failed'); break; case 'disconnected':this.emit('@connectionstatechange', 'disconnected'); break; case 'closed':this.emit('@connectionstatechange', 'closed'); break } }) } async updateIceServers(e) { C.debug('updateIceServers()'); const t = this._pc.getConfiguration(); t.iceServers = e, this._pc.setConfiguration(t) } async restartIce(e) { if (C.debug('restartIce()'), this._remoteSdp.updateIceParameters(e), !!this._transportReady) if (this._direction === 'send') { const t = await this._pc.createOffer({ iceRestart: !0 }); C.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', t), await this._pc.setLocalDescription(t); const r = { type: 'answer', sdp: this._remoteSdp.getSdp() }; C.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', r), await this._pc.setRemoteDescription(r) } else { const t = { type: 'offer', sdp: this._remoteSdp.getSdp() }; C.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', t), await this._pc.setRemoteDescription(t); const r = await this._pc.createAnswer(); C.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', r), await this._pc.setLocalDescription(r) } } async getTransportStats() { return this._pc.getStats() } async send({ track: e, encodings: t, codecOptions: r, codec: i }) { this._assertSendDirection(), C.debug('send() [kind:%s, track.id:%s]', e.kind, e.id); const n = no.clone(this._sendingRtpParametersByKind[e.kind], {}); n.codecs = Dt.reduceCodecs(n.codecs, i); const c = no.clone(this._sendingRemoteRtpParametersByKind[e.kind], {}); c.codecs = Dt.reduceCodecs(c.codecs, i); const a = this._remoteSdp.getNextMediaSectionIdx(); const o = this._pc.addTransceiver(e, { direction: 'sendonly', streams: [this._sendStream] }); let d = await this._pc.createOffer(); let l = Re.parse(d.sdp); let p; this._transportReady || await this._setupTransport({ localDtlsRole: 'server', localSdpObject: l }), t && t.length > 1 && (C.debug('send() | enabling legacy simulcast'), l = Re.parse(d.sdp), p = l.media[a.idx], ao.addLegacySimulcast({ offerMediaObject: p, numStreams: t.length }), d = { type: 'offer', sdp: Re.write(l) }), C.debug('send() | calling pc.setLocalDescription() [offer:%o]', d), await this._pc.setLocalDescription(d); const u = o.mid; if (n.mid = u, l = Re.parse(this._pc.localDescription.sdp), p = l.media[a.idx], n.rtcp.cname = $r.getCname({ offerMediaObject: p }), n.encodings = ao.getRtpEncodings({ offerMediaObject: p }), t) for (let f = 0; f < n.encodings.length; ++f)t[f] && Object.assign(n.encodings[f], t[f]); if (n.encodings.length > 1 && (n.codecs[0].mimeType.toLowerCase() === 'video/vp8' || n.codecs[0].mimeType.toLowerCase() === 'video/h264')) for (const f of n.encodings)f.scalabilityMode = 'S1T3'; this._remoteSdp.send({ offerMediaObject: p, reuseMid: a.reuseMid, offerRtpParameters: n, answerRtpParameters: c, codecOptions: r }); const h = { type: 'answer', sdp: this._remoteSdp.getSdp() }; return C.debug('send() | calling pc.setRemoteDescription() [answer:%o]', h), await this._pc.setRemoteDescription(h), this._mapMidTransceiver.set(u, o), { localId: u, rtpParameters: n, rtpSender: o.sender } } async stopSending(e) { this._assertSendDirection(), C.debug('stopSending() [localId:%s]', e); const t = this._mapMidTransceiver.get(e); if (!t) throw new Error('associated RTCRtpTransceiver not found'); t.sender.replaceTrack(null), this._pc.removeTrack(t.sender), this._remoteSdp.closeMediaSection(t.mid); const r = await this._pc.createOffer(); C.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', r), await this._pc.setLocalDescription(r); const i = { type: 'answer', sdp: this._remoteSdp.getSdp() }; C.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', i), await this._pc.setRemoteDescription(i) } async replaceTrack(e, t) { this._assertSendDirection(), t ? C.debug('replaceTrack() [localId:%s, track.id:%s]', e, t.id) : C.debug('replaceTrack() [localId:%s, no track]', e); const r = this._mapMidTransceiver.get(e); if (!r) throw new Error('associated RTCRtpTransceiver not found'); await r.sender.replaceTrack(t) } async setMaxSpatialLayer(e, t) { this._assertSendDirection(), C.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', e, t); const r = this._mapMidTransceiver.get(e); if (!r) throw new Error('associated RTCRtpTransceiver not found'); const i = r.sender.getParameters(); i.encodings.forEach((n, c) => { c <= t ? n.active = !0 : n.active = !1 }), await r.sender.setParameters(i) } async setRtpEncodingParameters(e, t) { this._assertSendDirection(), C.debug('setRtpEncodingParameters() [localId:%s, params:%o]', e, t); const r = this._mapMidTransceiver.get(e); if (!r) throw new Error('associated RTCRtpTransceiver not found'); const i = r.sender.getParameters(); i.encodings.forEach((n, c) => { i.encodings[c] = Object.assign(Object.assign({}, n), t) }), await r.sender.setParameters(i) } async getSenderStats(e) { this._assertSendDirection(); const t = this._mapMidTransceiver.get(e); if (!t) throw new Error('associated RTCRtpTransceiver not found'); return t.sender.getStats() } async sendDataChannel({ ordered: e, maxPacketLifeTime: t, maxRetransmits: r, label: i, protocol: n, priority: c }) { this._assertSendDirection(); const a = { negotiated: !0, id: this._nextSendSctpStreamId, ordered: e, maxPacketLifeTime: t, maxRetransmits: r, protocol: n, priority: c }; C.debug('sendDataChannel() [options:%o]', a); const o = this._pc.createDataChannel(i, a); if (this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % oo.MIS, !this._hasDataChannelMediaSection) { const l = await this._pc.createOffer(); const p = Re.parse(l.sdp); const u = p.media.find(f => f.type === 'application'); this._transportReady || await this._setupTransport({ localDtlsRole: 'server', localSdpObject: p }), C.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', l), await this._pc.setLocalDescription(l), this._remoteSdp.sendSctpAssociation({ offerMediaObject: u }); const h = { type: 'answer', sdp: this._remoteSdp.getSdp() }; C.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', h), await this._pc.setRemoteDescription(h), this._hasDataChannelMediaSection = !0 } const d = { streamId: a.id, ordered: a.ordered, maxPacketLifeTime: a.maxPacketLifeTime, maxRetransmits: a.maxRetransmits }; return { dataChannel: o, sctpStreamParameters: d } } async receive({ trackId: e, kind: t, rtpParameters: r }) { this._assertRecvDirection(), C.debug('receive() [trackId:%s, kind:%s]', e, t); const i = r.mid || String(this._mapMidTransceiver.size); this._remoteSdp.receive({ mid: i, kind: t, offerRtpParameters: r, streamId: r.rtcp.cname, trackId: e }); const n = { type: 'offer', sdp: this._remoteSdp.getSdp() }; C.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', n), await this._pc.setRemoteDescription(n); let c = await this._pc.createAnswer(); const a = Re.parse(c.sdp); const o = a.media.find(l => String(l.mid) === i); $r.applyCodecParameters({ offerRtpParameters: r, answerMediaObject: o }), c = { type: 'answer', sdp: Re.write(a) }, this._transportReady || await this._setupTransport({ localDtlsRole: 'client', localSdpObject: a }), C.debug('receive() | calling pc.setLocalDescription() [answer:%o]', c), await this._pc.setLocalDescription(c); const d = this._pc.getTransceivers().find(l => l.mid === i); if (!d) throw new Error('new RTCRtpTransceiver not found'); return this._mapMidTransceiver.set(i, d), { localId: i, track: d.receiver.track, rtpReceiver: d.receiver } } async stopReceiving(e) { this._assertRecvDirection(), C.debug('stopReceiving() [localId:%s]', e); const t = this._mapMidTransceiver.get(e); if (!t) throw new Error('associated RTCRtpTransceiver not found'); this._remoteSdp.closeMediaSection(t.mid); const r = { type: 'offer', sdp: this._remoteSdp.getSdp() }; C.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', r), await this._pc.setRemoteDescription(r); const i = await this._pc.createAnswer(); C.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', i), await this._pc.setLocalDescription(i) } async getReceiverStats(e) { this._assertRecvDirection(); const t = this._mapMidTransceiver.get(e); if (!t) throw new Error('associated RTCRtpTransceiver not found'); return t.receiver.getStats() } async receiveDataChannel({ sctpStreamParameters: e, label: t, protocol: r }) { this._assertRecvDirection(); const { streamId: i, ordered: n, maxPacketLifeTime: c, maxRetransmits: a } = e; const o = { negotiated: !0, id: i, ordered: n, maxPacketLifeTime: c, maxRetransmits: a, protocol: r }; C.debug('receiveDataChannel() [options:%o]', o); const d = this._pc.createDataChannel(t, o); if (!this._hasDataChannelMediaSection) { this._remoteSdp.receiveSctpAssociation(); const l = { type: 'offer', sdp: this._remoteSdp.getSdp() }; C.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', l), await this._pc.setRemoteDescription(l); const p = await this._pc.createAnswer(); if (!this._transportReady) { const u = Re.parse(p.sdp); await this._setupTransport({ localDtlsRole: 'client', localSdpObject: u }) }C.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', p), await this._pc.setLocalDescription(p), this._hasDataChannelMediaSection = !0 } return { dataChannel: d } } async _setupTransport({ localDtlsRole: e, localSdpObject: t }) { t || (t = Re.parse(this._pc.localDescription.sdp)); const r = $r.extractDtlsParameters({ sdpObject: t }); r.role = e, this._remoteSdp.updateDtlsRole(e === 'client' ? 'server' : 'client'), await this.safeEmitAsPromise('@connect', { dtlsParameters: r }), this._transportReady = !0 }_assertSendDirection() { if (this._direction !== 'send') throw new Error('method can just be called for handlers with "send" direction') }_assertRecvDirection() { if (this._direction !== 'recv') throw new Error('method can just be called for handlers with "recv" direction') }}; Ce.Safari12 = Hr }); var ho = m(Pe => { 'use strict'; var Pp = Pe && Pe.__createBinding || (Object.create ? function(s, e, t, r) { r === void 0 && (r = t), Object.defineProperty(s, r, { enumerable: !0, get: function() { return e[t] } }) } : function(s, e, t, r) { r === void 0 && (r = t), s[r] = e[t] }); var Ep = Pe && Pe.__setModuleDefault || (Object.create ? function(s, e) { Object.defineProperty(s, 'default', { enumerable: !0, value: e }) } : function(s, e) { s.default = e }); var Xt = Pe && Pe.__importStar || function(s) { if (s && s.__esModule) return s; var e = {}; if (s != null) for (var t in s)t !== 'default' && Object.hasOwnProperty.call(s, t) && Pp(e, s, t); return Ep(e, s), e }; Object.defineProperty(Pe, '__esModule', { value: !0 }); Pe.Safari11 = void 0; var Te = Xt(ce()); var Dp = A(); var lo = Xt($()); var Mt = Xt(te()); var Kr = Xt(qe()); var po = Xt(Kt()); var Mp = de(); var kp = Fe(); var S = new Dp.Logger('Safari11'); var uo = { OS: 1024, MIS: 1024 }; var Gr = class extends Mp.HandlerInterface {constructor() { super(); this._sendStream = new MediaStream(), this._mapSendLocalIdRtpSender = new Map(), this._nextSendLocalId = 0, this._mapRecvLocalIdInfo = new Map(), this._hasDataChannelMediaSection = !1, this._nextSendSctpStreamId = 0, this._transportReady = !1 }static createFactory() { return () => new Gr() } get name() { return 'Safari11' }close() { if (S.debug('close()'), this._pc) try { this._pc.close() } catch (e) {} } async getNativeRtpCapabilities() { S.debug('getNativeRtpCapabilities()'); const e = new RTCPeerConnection({ iceServers: [], iceTransportPolicy: 'all', bundlePolicy: 'max-bundle', rtcpMuxPolicy: 'require', sdpSemantics: 'plan-b' }); try { const t = await e.createOffer({ offerToReceiveAudio: !0, offerToReceiveVideo: !0 }); try { e.close() } catch (n) {} const r = Te.parse(t.sdp); return Kr.extractRtpCapabilities({ sdpObject: r }) } catch (t) { try { e.close() } catch (r) {} throw t } } async getNativeSctpCapabilities() { return S.debug('getNativeSctpCapabilities()'), { numStreams: uo } }run({ direction: e, iceParameters: t, iceCandidates: r, dtlsParameters: i, sctpParameters: n, iceServers: c, iceTransportPolicy: a, additionalSettings: o, proprietaryConstraints: d, extendedRtpCapabilities: l }) { S.debug('run()'), this._direction = e, this._remoteSdp = new kp.RemoteSdp({ iceParameters: t, iceCandidates: r, dtlsParameters: i, sctpParameters: n, planB: !0 }), this._sendingRtpParametersByKind = { audio: Mt.getSendingRtpParameters('audio', l), video: Mt.getSendingRtpParameters('video', l) }, this._sendingRemoteRtpParametersByKind = { audio: Mt.getSendingRemoteRtpParameters('audio', l), video: Mt.getSendingRemoteRtpParameters('video', l) }, this._pc = new RTCPeerConnection(Object.assign({ iceServers: c || [], iceTransportPolicy: a || 'all', bundlePolicy: 'max-bundle', rtcpMuxPolicy: 'require' }, o), d), this._pc.addEventListener('iceconnectionstatechange', () => { switch (this._pc.iceConnectionState) { case 'checking':this.emit('@connectionstatechange', 'connecting'); break; case 'connected':case 'completed':this.emit('@connectionstatechange', 'connected'); break; case 'failed':this.emit('@connectionstatechange', 'failed'); break; case 'disconnected':this.emit('@connectionstatechange', 'disconnected'); break; case 'closed':this.emit('@connectionstatechange', 'closed'); break } }) } async updateIceServers(e) { S.debug('updateIceServers()'); const t = this._pc.getConfiguration(); t.iceServers = e, this._pc.setConfiguration(t) } async restartIce(e) { if (S.debug('restartIce()'), this._remoteSdp.updateIceParameters(e), !!this._transportReady) if (this._direction === 'send') { const t = await this._pc.createOffer({ iceRestart: !0 }); S.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', t), await this._pc.setLocalDescription(t); const r = { type: 'answer', sdp: this._remoteSdp.getSdp() }; S.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', r), await this._pc.setRemoteDescription(r) } else { const t = { type: 'offer', sdp: this._remoteSdp.getSdp() }; S.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', t), await this._pc.setRemoteDescription(t); const r = await this._pc.createAnswer(); S.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', r), await this._pc.setLocalDescription(r) } } async getTransportStats() { return this._pc.getStats() } async send({ track: e, encodings: t, codecOptions: r, codec: i }) { this._assertSendDirection(), S.debug('send() [kind:%s, track.id:%s]', e.kind, e.id), i && S.warn('send() | codec selection is not available in %s handler', this.name), this._sendStream.addTrack(e), this._pc.addTrack(e, this._sendStream); let n = await this._pc.createOffer(); let c = Te.parse(n.sdp); let a; const o = lo.clone(this._sendingRtpParametersByKind[e.kind], {}); o.codecs = Mt.reduceCodecs(o.codecs); const d = lo.clone(this._sendingRemoteRtpParametersByKind[e.kind], {}); if (d.codecs = Mt.reduceCodecs(d.codecs), this._transportReady || await this._setupTransport({ localDtlsRole: 'server', localSdpObject: c }), e.kind === 'video' && t && t.length > 1 && (S.debug('send() | enabling simulcast'), c = Te.parse(n.sdp), a = c.media.find(h => h.type === 'video'), po.addLegacySimulcast({ offerMediaObject: a, track: e, numStreams: t.length }), n = { type: 'offer', sdp: Te.write(c) }), S.debug('send() | calling pc.setLocalDescription() [offer:%o]', n), await this._pc.setLocalDescription(n), c = Te.parse(this._pc.localDescription.sdp), a = c.media.find(h => h.type === e.kind), o.rtcp.cname = Kr.getCname({ offerMediaObject: a }), o.encodings = po.getRtpEncodings({ offerMediaObject: a, track: e }), t) for (let h = 0; h < o.encodings.length; ++h)t[h] && Object.assign(o.encodings[h], t[h]); if (o.encodings.length > 1 && o.codecs[0].mimeType.toLowerCase() === 'video/vp8') for (const h of o.encodings)h.scalabilityMode = 'S1T3'; this._remoteSdp.send({ offerMediaObject: a, offerRtpParameters: o, answerRtpParameters: d, codecOptions: r }); const l = { type: 'answer', sdp: this._remoteSdp.getSdp() }; S.debug('send() | calling pc.setRemoteDescription() [answer:%o]', l), await this._pc.setRemoteDescription(l); const p = String(this._nextSendLocalId); this._nextSendLocalId++; const u = this._pc.getSenders().find(h => h.track === e); return this._mapSendLocalIdRtpSender.set(p, u), { localId: p, rtpParameters: o, rtpSender: u } } async stopSending(e) { this._assertSendDirection(); const t = this._mapSendLocalIdRtpSender.get(e); if (!t) throw new Error('associated RTCRtpSender not found'); t.track && this._sendStream.removeTrack(t.track), this._mapSendLocalIdRtpSender.delete(e); const r = await this._pc.createOffer(); S.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', r); try { await this._pc.setLocalDescription(r) } catch (n) { if (this._sendStream.getTracks().length === 0) { S.warn('stopSending() | ignoring expected error due no sending tracks: %s', n.toString()); return } throw n } if (this._pc.signalingState === 'stable') return; const i = { type: 'answer', sdp: this._remoteSdp.getSdp() }; S.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', i), await this._pc.setRemoteDescription(i) } async replaceTrack(e, t) { this._assertSendDirection(), t ? S.debug('replaceTrack() [localId:%s, track.id:%s]', e, t.id) : S.debug('replaceTrack() [localId:%s, no track]', e); const r = this._mapSendLocalIdRtpSender.get(e); if (!r) throw new Error('associated RTCRtpSender not found'); const i = r.track; await r.replaceTrack(t), i && this._sendStream.removeTrack(i), t && this._sendStream.addTrack(t) } async setMaxSpatialLayer(e, t) { this._assertSendDirection(), S.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', e, t); const r = this._mapSendLocalIdRtpSender.get(e); if (!r) throw new Error('associated RTCRtpSender not found'); const i = r.getParameters(); i.encodings.forEach((n, c) => { c <= t ? n.active = !0 : n.active = !1 }), await r.setParameters(i) } async setRtpEncodingParameters(e, t) { this._assertSendDirection(), S.debug('setRtpEncodingParameters() [localId:%s, params:%o]', e, t); const r = this._mapSendLocalIdRtpSender.get(e); if (!r) throw new Error('associated RTCRtpSender not found'); const i = r.getParameters(); i.encodings.forEach((n, c) => { i.encodings[c] = Object.assign(Object.assign({}, n), t) }), await r.setParameters(i) } async getSenderStats(e) { this._assertSendDirection(); const t = this._mapSendLocalIdRtpSender.get(e); if (!t) throw new Error('associated RTCRtpSender not found'); return t.getStats() } async sendDataChannel({ ordered: e, maxPacketLifeTime: t, maxRetransmits: r, label: i, protocol: n, priority: c }) { this._assertSendDirection(); const a = { negotiated: !0, id: this._nextSendSctpStreamId, ordered: e, maxPacketLifeTime: t, maxRetransmits: r, protocol: n, priority: c }; S.debug('sendDataChannel() [options:%o]', a); const o = this._pc.createDataChannel(i, a); if (this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % uo.MIS, !this._hasDataChannelMediaSection) { const l = await this._pc.createOffer(); const p = Te.parse(l.sdp); const u = p.media.find(f => f.type === 'application'); this._transportReady || await this._setupTransport({ localDtlsRole: 'server', localSdpObject: p }), S.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', l), await this._pc.setLocalDescription(l), this._remoteSdp.sendSctpAssociation({ offerMediaObject: u }); const h = { type: 'answer', sdp: this._remoteSdp.getSdp() }; S.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', h), await this._pc.setRemoteDescription(h), this._hasDataChannelMediaSection = !0 } const d = { streamId: a.id, ordered: a.ordered, maxPacketLifeTime: a.maxPacketLifeTime, maxRetransmits: a.maxRetransmits }; return { dataChannel: o, sctpStreamParameters: d } } async receive({ trackId: e, kind: t, rtpParameters: r }) { this._assertRecvDirection(), S.debug('receive() [trackId:%s, kind:%s]', e, t); const i = e; const n = t; this._remoteSdp.receive({ mid: n, kind: t, offerRtpParameters: r, streamId: r.rtcp.cname, trackId: e }); const c = { type: 'offer', sdp: this._remoteSdp.getSdp() }; S.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', c), await this._pc.setRemoteDescription(c); let a = await this._pc.createAnswer(); const o = Te.parse(a.sdp); const d = o.media.find(p => String(p.mid) === n); Kr.applyCodecParameters({ offerRtpParameters: r, answerMediaObject: d }), a = { type: 'answer', sdp: Te.write(o) }, this._transportReady || await this._setupTransport({ localDtlsRole: 'client', localSdpObject: o }), S.debug('receive() | calling pc.setLocalDescription() [answer:%o]', a), await this._pc.setLocalDescription(a); const l = this._pc.getReceivers().find(p => p.track && p.track.id === i); if (!l) throw new Error('new RTCRtpReceiver not'); return this._mapRecvLocalIdInfo.set(i, { mid: n, rtpParameters: r, rtpReceiver: l }), { localId: i, track: l.track, rtpReceiver: l } } async stopReceiving(e) { this._assertRecvDirection(), S.debug('stopReceiving() [localId:%s]', e); const { mid: t, rtpParameters: r } = this._mapRecvLocalIdInfo.get(e) || {}; this._mapRecvLocalIdInfo.delete(e), this._remoteSdp.planBStopReceiving({ mid: t, offerRtpParameters: r }); const i = { type: 'offer', sdp: this._remoteSdp.getSdp() }; S.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', i), await this._pc.setRemoteDescription(i); const n = await this._pc.createAnswer(); S.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', n), await this._pc.setLocalDescription(n) } async getReceiverStats(e) { this._assertRecvDirection(); const { rtpReceiver: t } = this._mapRecvLocalIdInfo.get(e) || {}; if (!t) throw new Error('associated RTCRtpReceiver not found'); return t.getStats() } async receiveDataChannel({ sctpStreamParameters: e, label: t, protocol: r }) { this._assertRecvDirection(); const { streamId: i, ordered: n, maxPacketLifeTime: c, maxRetransmits: a } = e; const o = { negotiated: !0, id: i, ordered: n, maxPacketLifeTime: c, maxRetransmits: a, protocol: r }; S.debug('receiveDataChannel() [options:%o]', o); const d = this._pc.createDataChannel(t, o); if (!this._hasDataChannelMediaSection) { this._remoteSdp.receiveSctpAssociation({ oldDataChannelSpec: !0 }); const l = { type: 'offer', sdp: this._remoteSdp.getSdp() }; S.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', l), await this._pc.setRemoteDescription(l); const p = await this._pc.createAnswer(); if (!this._transportReady) { const u = Te.parse(p.sdp); await this._setupTransport({ localDtlsRole: 'client', localSdpObject: u }) }S.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', p), await this._pc.setLocalDescription(p), this._hasDataChannelMediaSection = !0 } return { dataChannel: d } } async _setupTransport({ localDtlsRole: e, localSdpObject: t }) { t || (t = Te.parse(this._pc.localDescription.sdp)); const r = Kr.extractDtlsParameters({ sdpObject: t }); r.role = e, this._remoteSdp.updateDtlsRole(e === 'client' ? 'server' : 'client'), await this.safeEmitAsPromise('@connect', { dtlsParameters: r }), this._transportReady = !0 }_assertSendDirection() { if (this._direction !== 'send') throw new Error('method can just be called for handlers with "send" direction') }_assertRecvDirection() { if (this._direction !== 'recv') throw new Error('method can just be called for handlers with "recv" direction') }}; Pe.Safari11 = Gr }); var mo = m(ie => { 'use strict'; var xp = ie && ie.__createBinding || (Object.create ? function(s, e, t, r) { r === void 0 && (r = t), Object.defineProperty(s, r, { enumerable: !0, get: function() { return e[t] } }) } : function(s, e, t, r) { r === void 0 && (r = t), s[r] = e[t] }); var Op = ie && ie.__setModuleDefault || (Object.create ? function(s, e) { Object.defineProperty(s, 'default', { enumerable: !0, value: e }) } : function(s, e) { s.default = e }); var Lp = ie && ie.__importStar || function(s) { if (s && s.__esModule) return s; var e = {}; if (s != null) for (var t in s)t !== 'default' && Object.hasOwnProperty.call(s, t) && xp(e, s, t); return Op(e, s), e }; Object.defineProperty(ie, '__esModule', { value: !0 }); ie.mangleRtpParameters = ie.getCapabilities = void 0; var fo = Lp($()); function Ip() { const s = RTCRtpReceiver.getCapabilities(); const e = fo.clone(s, {}); for (const t of e.codecs) { if (t.channels = t.numChannels, delete t.numChannels, t.mimeType = t.mimeType || `${t.kind}/${t.name}`, t.parameters) { const r = t.parameters; r.apt && (r.apt = Number(r.apt)), r['packetization-mode'] && (r['packetization-mode'] = Number(r['packetization-mode'])) } for (const r of t.rtcpFeedback || [])r.parameter || (r.parameter = '') } return e }ie.getCapabilities = Ip; function Ap(s) { const e = fo.clone(s, {}); e.mid && (e.muxId = e.mid, delete e.mid); for (const t of e.codecs)t.channels && (t.numChannels = t.channels, delete t.channels), t.mimeType && !t.name && (t.name = t.mimeType.split('/')[1]), delete t.mimeType; return e }ie.mangleRtpParameters = Ap }); var go = m(Ee => { 'use strict'; var jp = Ee && Ee.__createBinding || (Object.create ? function(s, e, t, r) { r === void 0 && (r = t), Object.defineProperty(s, r, { enumerable: !0, get: function() { return e[t] } }) } : function(s, e, t, r) { r === void 0 && (r = t), s[r] = e[t] }); var Bp = Ee && Ee.__setModuleDefault || (Object.create ? function(s, e) { Object.defineProperty(s, 'default', { enumerable: !0, value: e }) } : function(s, e) { s.default = e }); var Ws = Ee && Ee.__importStar || function(s) { if (s && s.__esModule) return s; var e = {}; if (s != null) for (var t in s)t !== 'default' && Object.hasOwnProperty.call(s, t) && jp(e, s, t); return Bp(e, s), e }; Object.defineProperty(Ee, '__esModule', { value: !0 }); Ee.Edge11 = void 0; var qp = A(); var Qs = oe(); var Wr = Ws($()); var Js = Ws(te()); var Ys = Ws(mo()); var Fp = de(); var D = new qp.Logger('Edge11'); var Qr = class extends Fp.HandlerInterface {constructor() { super(); this._rtpSenders = new Map(), this._rtpReceivers = new Map(), this._nextSendLocalId = 0, this._transportReady = !1 }static createFactory() { return () => new Qr() } get name() { return 'Edge11' }close() { D.debug('close()'); try { this._iceGatherer.close() } catch (e) {} try { this._iceTransport.stop() } catch (e) {} try { this._dtlsTransport.stop() } catch (e) {} for (const e of this._rtpSenders.values()) try { e.stop() } catch (t) {} for (const e of this._rtpReceivers.values()) try { e.stop() } catch (t) {} } async getNativeRtpCapabilities() { return D.debug('getNativeRtpCapabilities()'), Ys.getCapabilities() } async getNativeSctpCapabilities() { return D.debug('getNativeSctpCapabilities()'), { numStreams: { OS: 0, MIS: 0 }} }run({ direction: e, iceParameters: t, iceCandidates: r, dtlsParameters: i, sctpParameters: n, iceServers: c, iceTransportPolicy: a, additionalSettings: o, proprietaryConstraints: d, extendedRtpCapabilities: l }) { D.debug('run()'), this._sendingRtpParametersByKind = { audio: Js.getSendingRtpParameters('audio', l), video: Js.getSendingRtpParameters('video', l) }, this._remoteIceParameters = t, this._remoteIceCandidates = r, this._remoteDtlsParameters = i, this._cname = `CNAME-${Wr.generateRandomNumber()}`, this._setIceGatherer({ iceServers: c, iceTransportPolicy: a }), this._setIceTransport(), this._setDtlsTransport() } async updateIceServers(e) { throw new Qs.UnsupportedError('not supported') } async restartIce(e) { if (D.debug('restartIce()'), this._remoteIceParameters = e, !!this._transportReady) { D.debug('restartIce() | calling iceTransport.start()'), this._iceTransport.start(this._iceGatherer, e, 'controlling'); for (const t of this._remoteIceCandidates) this._iceTransport.addRemoteCandidate(t); this._iceTransport.addRemoteCandidate({}) } } async getTransportStats() { return this._iceTransport.getStats() } async send({ track: e, encodings: t, codecOptions: r, codec: i }) { D.debug('send() [kind:%s, track.id:%s]', e.kind, e.id), this._transportReady || await this._setupTransport({ localDtlsRole: 'server' }), D.debug('send() | calling new RTCRtpSender()'); const n = new RTCRtpSender(e, this._dtlsTransport); const c = Wr.clone(this._sendingRtpParametersByKind[e.kind], {}); c.codecs = Js.reduceCodecs(c.codecs, i); const a = c.codecs.some(l => /.+\/rtx$/i.test(l.mimeType)); t || (t = [{}]); for (const l of t)l.ssrc = Wr.generateRandomNumber(), a && (l.rtx = { ssrc: Wr.generateRandomNumber() }); c.encodings = t, c.rtcp = { cname: this._cname, reducedSize: !0, mux: !0 }; const o = Ys.mangleRtpParameters(c); D.debug('send() | calling rtpSender.send() [params:%o]', o), await n.send(o); const d = String(this._nextSendLocalId); return this._nextSendLocalId++, this._rtpSenders.set(d, n), { localId: d, rtpParameters: c, rtpSender: n } } async stopSending(e) { D.debug('stopSending() [localId:%s]', e); const t = this._rtpSenders.get(e); if (!t) throw new Error('RTCRtpSender not found'); this._rtpSenders.delete(e); try { D.debug('stopSending() | calling rtpSender.stop()'), t.stop() } catch (r) { throw D.warn('stopSending() | rtpSender.stop() failed:%o', r), r } } async replaceTrack(e, t) { t ? D.debug('replaceTrack() [localId:%s, track.id:%s]', e, t.id) : D.debug('replaceTrack() [localId:%s, no track]', e); const r = this._rtpSenders.get(e); if (!r) throw new Error('RTCRtpSender not found'); r.setTrack(t) } async setMaxSpatialLayer(e, t) { D.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', e, t); const r = this._rtpSenders.get(e); if (!r) throw new Error('RTCRtpSender not found'); const i = r.getParameters(); i.encodings.forEach((n, c) => { c <= t ? n.active = !0 : n.active = !1 }), await r.setParameters(i) } async setRtpEncodingParameters(e, t) { D.debug('setRtpEncodingParameters() [localId:%s, params:%o]', e, t); const r = this._rtpSenders.get(e); if (!r) throw new Error('RTCRtpSender not found'); const i = r.getParameters(); i.encodings.forEach((n, c) => { i.encodings[c] = Object.assign(Object.assign({}, n), t) }), await r.setParameters(i) } async getSenderStats(e) { const t = this._rtpSenders.get(e); if (!t) throw new Error('RTCRtpSender not found'); return t.getStats() } async sendDataChannel(e) { throw new Qs.UnsupportedError('not implemented') } async receive({ trackId: e, kind: t, rtpParameters: r }) { D.debug('receive() [trackId:%s, kind:%s]', e, t), this._transportReady || await this._setupTransport({ localDtlsRole: 'server' }), D.debug('receive() | calling new RTCRtpReceiver()'); const i = new RTCRtpReceiver(this._dtlsTransport, t); i.addEventListener('error', a => { D.error('rtpReceiver "error" event [event:%o]', a) }); const n = Ys.mangleRtpParameters(r); D.debug('receive() | calling rtpReceiver.receive() [params:%o]', n), await i.receive(n); const c = e; return this._rtpReceivers.set(c, i), { localId: c, track: i.track, rtpReceiver: i } } async stopReceiving(e) { D.debug('stopReceiving() [localId:%s]', e); const t = this._rtpReceivers.get(e); if (!t) throw new Error('RTCRtpReceiver not found'); this._rtpReceivers.delete(e); try { D.debug('stopReceiving() | calling rtpReceiver.stop()'), t.stop() } catch (r) { D.warn('stopReceiving() | rtpReceiver.stop() failed:%o', r) } } async getReceiverStats(e) { const t = this._rtpReceivers.get(e); if (!t) throw new Error('RTCRtpReceiver not found'); return t.getStats() } async receiveDataChannel(e) { throw new Qs.UnsupportedError('not implemented') }_setIceGatherer({ iceServers: e, iceTransportPolicy: t }) { const r = new RTCIceGatherer({ iceServers: e || [], gatherPolicy: t || 'all' }); r.addEventListener('error', i => { D.error('iceGatherer "error" event [event:%o]', i) }); try { r.gather() } catch (i) { D.debug('_setIceGatherer() | iceGatherer.gather() failed: %s', i.toString()) } this._iceGatherer = r }_setIceTransport() { const e = new RTCIceTransport(this._iceGatherer); e.addEventListener('statechange', () => { switch (e.state) { case 'checking':this.emit('@connectionstatechange', 'connecting'); break; case 'connected':case 'completed':this.emit('@connectionstatechange', 'connected'); break; case 'failed':this.emit('@connectionstatechange', 'failed'); break; case 'disconnected':this.emit('@connectionstatechange', 'disconnected'); break; case 'closed':this.emit('@connectionstatechange', 'closed'); break } }), e.addEventListener('icestatechange', () => { switch (e.state) { case 'checking':this.emit('@connectionstatechange', 'connecting'); break; case 'connected':case 'completed':this.emit('@connectionstatechange', 'connected'); break; case 'failed':this.emit('@connectionstatechange', 'failed'); break; case 'disconnected':this.emit('@connectionstatechange', 'disconnected'); break; case 'closed':this.emit('@connectionstatechange', 'closed'); break } }), e.addEventListener('candidatepairchange', t => { D.debug('iceTransport "candidatepairchange" event [pair:%o]', t.pair) }), this._iceTransport = e }_setDtlsTransport() { const e = new RTCDtlsTransport(this._iceTransport); e.addEventListener('statechange', () => { D.debug('dtlsTransport "statechange" event [state:%s]', e.state) }), e.addEventListener('dtlsstatechange', () => { D.debug('dtlsTransport "dtlsstatechange" event [state:%s]', e.state), e.state === 'closed' && this.emit('@connectionstatechange', 'closed') }), e.addEventListener('error', t => { D.error('dtlsTransport "error" event [event:%o]', t) }), this._dtlsTransport = e } async _setupTransport({ localDtlsRole: e }) { D.debug('_setupTransport()'); const t = this._dtlsTransport.getLocalParameters(); t.role = e, await this.safeEmitAsPromise('@connect', { dtlsParameters: t }), this._iceTransport.start(this._iceGatherer, this._remoteIceParameters, 'controlling'); for (const r of this._remoteIceCandidates) this._iceTransport.addRemoteCandidate(r); this._iceTransport.addRemoteCandidate({}), this._remoteDtlsParameters.fingerprints = this._remoteDtlsParameters.fingerprints.filter(r => r.algorithm === 'sha-256' || r.algorithm === 'sha-384' || r.algorithm === 'sha-512'), this._dtlsTransport.start(this._remoteDtlsParameters), this._transportReady = !0 }}; Ee.Edge11 = Qr }); var yo = m(Me => { 'use strict'; var Np = Me && Me.__createBinding || (Object.create ? function(s, e, t, r) { r === void 0 && (r = t), Object.defineProperty(s, r, { enumerable: !0, get: function() { return e[t] } }) } : function(s, e, t, r) { r === void 0 && (r = t), s[r] = e[t] }); var Up = Me && Me.__setModuleDefault || (Object.create ? function(s, e) { Object.defineProperty(s, 'default', { enumerable: !0, value: e }) } : function(s, e) { s.default = e }); var Zt = Me && Me.__importStar || function(s) { if (s && s.__esModule) return s; var e = {}; if (s != null) for (var t in s)t !== 'default' && Object.hasOwnProperty.call(s, t) && Np(e, s, t); return Up(e, s), e }; Object.defineProperty(Me, '__esModule', { value: !0 }); Me.ReactNative = void 0; var De = Zt(ce()); var zp = A(); var er = oe(); var Xs = Zt($()); var kt = Zt(te()); var Jr = Zt(qe()); var _o = Zt(Kt()); var Vp = de(); var $p = Fe(); var T = new zp.Logger('ReactNative'); var vo = { OS: 1024, MIS: 1024 }; var Yr = class extends Vp.HandlerInterface {constructor() { super(); this._sendStream = new MediaStream(), this._mapSendLocalIdTrack = new Map(), this._nextSendLocalId = 0, this._mapRecvLocalIdInfo = new Map(), this._hasDataChannelMediaSection = !1, this._nextSendSctpStreamId = 0, this._transportReady = !1 }static createFactory() { return () => new Yr() } get name() { return 'ReactNative' }close() { if (T.debug('close()'), this._pc) try { this._pc.close() } catch (e) {} } async getNativeRtpCapabilities() { T.debug('getNativeRtpCapabilities()'); const e = new RTCPeerConnection({ iceServers: [], iceTransportPolicy: 'all', bundlePolicy: 'max-bundle', rtcpMuxPolicy: 'require', sdpSemantics: 'plan-b' }); try { const t = await e.createOffer({ offerToReceiveAudio: !0, offerToReceiveVideo: !0 }); try { e.close() } catch (n) {} const r = De.parse(t.sdp); return Jr.extractRtpCapabilities({ sdpObject: r }) } catch (t) { try { e.close() } catch (r) {} throw t } } async getNativeSctpCapabilities() { return T.debug('getNativeSctpCapabilities()'), { numStreams: vo } }run({ direction: e, iceParameters: t, iceCandidates: r, dtlsParameters: i, sctpParameters: n, iceServers: c, iceTransportPolicy: a, additionalSettings: o, proprietaryConstraints: d, extendedRtpCapabilities: l }) { T.debug('run()'), this._direction = e, this._remoteSdp = new $p.RemoteSdp({ iceParameters: t, iceCandidates: r, dtlsParameters: i, sctpParameters: n, planB: !0 }), this._sendingRtpParametersByKind = { audio: kt.getSendingRtpParameters('audio', l), video: kt.getSendingRtpParameters('video', l) }, this._sendingRemoteRtpParametersByKind = { audio: kt.getSendingRemoteRtpParameters('audio', l), video: kt.getSendingRemoteRtpParameters('video', l) }, this._pc = new RTCPeerConnection(Object.assign({ iceServers: c || [], iceTransportPolicy: a || 'all', bundlePolicy: 'max-bundle', rtcpMuxPolicy: 'require', sdpSemantics: 'plan-b' }, o), d), this._pc.addEventListener('iceconnectionstatechange', () => { switch (this._pc.iceConnectionState) { case 'checking':this.emit('@connectionstatechange', 'connecting'); break; case 'connected':case 'completed':this.emit('@connectionstatechange', 'connected'); break; case 'failed':this.emit('@connectionstatechange', 'failed'); break; case 'disconnected':this.emit('@connectionstatechange', 'disconnected'); break; case 'closed':this.emit('@connectionstatechange', 'closed'); break } }) } async updateIceServers(e) { T.debug('updateIceServers()'); const t = this._pc.getConfiguration(); t.iceServers = e, this._pc.setConfiguration(t) } async restartIce(e) { if (T.debug('restartIce()'), this._remoteSdp.updateIceParameters(e), !!this._transportReady) if (this._direction === 'send') { const t = await this._pc.createOffer({ iceRestart: !0 }); T.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', t), await this._pc.setLocalDescription(t); const r = { type: 'answer', sdp: this._remoteSdp.getSdp() }; T.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', r), await this._pc.setRemoteDescription(r) } else { const t = { type: 'offer', sdp: this._remoteSdp.getSdp() }; T.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', t), await this._pc.setRemoteDescription(t); const r = await this._pc.createAnswer(); T.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', r), await this._pc.setLocalDescription(r) } } async getTransportStats() { return this._pc.getStats() } async send({ track: e, encodings: t, codecOptions: r, codec: i }) { this._assertSendDirection(), T.debug('send() [kind:%s, track.id:%s]', e.kind, e.id), i && T.warn('send() | codec selection is not available in %s handler', this.name), this._sendStream.addTrack(e), this._pc.addStream(this._sendStream); let n = await this._pc.createOffer(); let c = De.parse(n.sdp); let a; const o = Xs.clone(this._sendingRtpParametersByKind[e.kind], {}); o.codecs = kt.reduceCodecs(o.codecs); const d = Xs.clone(this._sendingRemoteRtpParametersByKind[e.kind], {}); if (d.codecs = kt.reduceCodecs(d.codecs), this._transportReady || await this._setupTransport({ localDtlsRole: 'server', localSdpObject: c }), e.kind === 'video' && t && t.length > 1 && (T.debug('send() | enabling simulcast'), c = De.parse(n.sdp), a = c.media.find(u => u.type === 'video'), _o.addLegacySimulcast({ offerMediaObject: a, track: e, numStreams: t.length }), n = { type: 'offer', sdp: De.write(c) }), T.debug('send() | calling pc.setLocalDescription() [offer:%o]', n), await this._pc.setLocalDescription(n), c = De.parse(this._pc.localDescription.sdp), a = c.media.find(u => u.type === e.kind), o.rtcp.cname = Jr.getCname({ offerMediaObject: a }), o.encodings = _o.getRtpEncodings({ offerMediaObject: a, track: e }), t) for (let u = 0; u < o.encodings.length; ++u)t[u] && Object.assign(o.encodings[u], t[u]); if (o.encodings.length > 1 && (o.codecs[0].mimeType.toLowerCase() === 'video/vp8' || o.codecs[0].mimeType.toLowerCase() === 'video/h264')) for (const u of o.encodings)u.scalabilityMode = 'S1T3'; this._remoteSdp.send({ offerMediaObject: a, offerRtpParameters: o, answerRtpParameters: d, codecOptions: r }); const l = { type: 'answer', sdp: this._remoteSdp.getSdp() }; T.debug('send() | calling pc.setRemoteDescription() [answer:%o]', l), await this._pc.setRemoteDescription(l); const p = String(this._nextSendLocalId); return this._nextSendLocalId++, this._mapSendLocalIdTrack.set(p, e), { localId: p, rtpParameters: o } } async stopSending(e) { this._assertSendDirection(), T.debug('stopSending() [localId:%s]', e); const t = this._mapSendLocalIdTrack.get(e); if (!t) throw new Error('track not found'); this._mapSendLocalIdTrack.delete(e), this._sendStream.removeTrack(t), this._pc.addStream(this._sendStream); const r = await this._pc.createOffer(); T.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', r); try { await this._pc.setLocalDescription(r) } catch (n) { if (this._sendStream.getTracks().length === 0) { T.warn('stopSending() | ignoring expected error due no sending tracks: %s', n.toString()); return } throw n } if (this._pc.signalingState === 'stable') return; const i = { type: 'answer', sdp: this._remoteSdp.getSdp() }; T.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', i), await this._pc.setRemoteDescription(i) } async replaceTrack(e, t) { throw new er.UnsupportedError('not implemented') } async setMaxSpatialLayer(e, t) { throw new er.UnsupportedError('not implemented') } async setRtpEncodingParameters(e, t) { throw new er.UnsupportedError('not implemented') } async getSenderStats(e) { throw new er.UnsupportedError('not implemented') } async sendDataChannel({ ordered: e, maxPacketLifeTime: t, maxRetransmits: r, label: i, protocol: n, priority: c }) { this._assertSendDirection(); const a = { negotiated: !0, id: this._nextSendSctpStreamId, ordered: e, maxPacketLifeTime: t, maxRetransmitTime: t, maxRetransmits: r, protocol: n, priority: c }; T.debug('sendDataChannel() [options:%o]', a); const o = this._pc.createDataChannel(i, a); if (this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % vo.MIS, !this._hasDataChannelMediaSection) { const l = await this._pc.createOffer(); const p = De.parse(l.sdp); const u = p.media.find(f => f.type === 'application'); this._transportReady || await this._setupTransport({ localDtlsRole: 'server', localSdpObject: p }), T.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', l), await this._pc.setLocalDescription(l), this._remoteSdp.sendSctpAssociation({ offerMediaObject: u }); const h = { type: 'answer', sdp: this._remoteSdp.getSdp() }; T.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', h), await this._pc.setRemoteDescription(h), this._hasDataChannelMediaSection = !0 } const d = { streamId: a.id, ordered: a.ordered, maxPacketLifeTime: a.maxPacketLifeTime, maxRetransmits: a.maxRetransmits }; return { dataChannel: o, sctpStreamParameters: d } } async receive({ trackId: e, kind: t, rtpParameters: r }) { this._assertRecvDirection(), T.debug('receive() [trackId:%s, kind:%s]', e, t); const i = e; const n = t; let c = r.rtcp.cname; T.debug('receive() | forcing a random remote streamId to avoid well known bug in react-native-webrtc'), c += `-hack-${Xs.generateRandomNumber()}`, this._remoteSdp.receive({ mid: n, kind: t, offerRtpParameters: r, streamId: c, trackId: e }); const a = { type: 'offer', sdp: this._remoteSdp.getSdp() }; T.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', a), await this._pc.setRemoteDescription(a); let o = await this._pc.createAnswer(); const d = De.parse(o.sdp); const l = d.media.find(h => String(h.mid) === n); Jr.applyCodecParameters({ offerRtpParameters: r, answerMediaObject: l }), o = { type: 'answer', sdp: De.write(d) }, this._transportReady || await this._setupTransport({ localDtlsRole: 'client', localSdpObject: d }), T.debug('receive() | calling pc.setLocalDescription() [answer:%o]', o), await this._pc.setLocalDescription(o); const u = this._pc.getRemoteStreams().find(h => h.id === c).getTrackById(i); if (!u) throw new Error('remote track not found'); return this._mapRecvLocalIdInfo.set(i, { mid: n, rtpParameters: r }), { localId: i, track: u } } async stopReceiving(e) { this._assertRecvDirection(), T.debug('stopReceiving() [localId:%s]', e); const { mid: t, rtpParameters: r } = this._mapRecvLocalIdInfo.get(e) || {}; this._mapRecvLocalIdInfo.delete(e), this._remoteSdp.planBStopReceiving({ mid: t, offerRtpParameters: r }); const i = { type: 'offer', sdp: this._remoteSdp.getSdp() }; T.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', i), await this._pc.setRemoteDescription(i); const n = await this._pc.createAnswer(); T.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', n), await this._pc.setLocalDescription(n) } async getReceiverStats(e) { throw new er.UnsupportedError('not implemented') } async receiveDataChannel({ sctpStreamParameters: e, label: t, protocol: r }) { this._assertRecvDirection(); const { streamId: i, ordered: n, maxPacketLifeTime: c, maxRetransmits: a } = e; const o = { negotiated: !0, id: i, ordered: n, maxPacketLifeTime: c, maxRetransmitTime: c, maxRetransmits: a, protocol: r }; T.debug('receiveDataChannel() [options:%o]', o); const d = this._pc.createDataChannel(t, o); if (!this._hasDataChannelMediaSection) { this._remoteSdp.receiveSctpAssociation({ oldDataChannelSpec: !0 }); const l = { type: 'offer', sdp: this._remoteSdp.getSdp() }; T.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', l), await this._pc.setRemoteDescription(l); const p = await this._pc.createAnswer(); if (!this._transportReady) { const u = De.parse(p.sdp); await this._setupTransport({ localDtlsRole: 'client', localSdpObject: u }) }T.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', p), await this._pc.setLocalDescription(p), this._hasDataChannelMediaSection = !0 } return { dataChannel: d } } async _setupTransport({ localDtlsRole: e, localSdpObject: t }) { t || (t = De.parse(this._pc.localDescription.sdp)); const r = Jr.extractDtlsParameters({ sdpObject: t }); r.role = e, this._remoteSdp.updateDtlsRole(e === 'client' ? 'server' : 'client'), await this.safeEmitAsPromise('@connect', { dtlsParameters: r }), this._transportReady = !0 }_assertSendDirection() { if (this._direction !== 'send') throw new Error('method can just be called for handlers with "send" direction') }_assertRecvDirection() { if (this._direction !== 'recv') throw new Error('method can just be called for handlers with "recv" direction') }}; Me.ReactNative = Yr }); var Zs = m(W => { 'use strict'; var Hp = W && W.__createBinding || (Object.create ? function(s, e, t, r) { r === void 0 && (r = t), Object.defineProperty(s, r, { enumerable: !0, get: function() { return e[t] } }) } : function(s, e, t, r) { r === void 0 && (r = t), s[r] = e[t] }); var Kp = W && W.__setModuleDefault || (Object.create ? function(s, e) { Object.defineProperty(s, 'default', { enumerable: !0, value: e }) } : function(s, e) { s.default = e }); var bo = W && W.__importStar || function(s) { if (s && s.__esModule) return s; var e = {}; if (s != null) for (var t in s)t !== 'default' && Object.hasOwnProperty.call(s, t) && Hp(e, s, t); return Kp(e, s), e }; var Gp = W && W.__importDefault || function(s) { return s && s.__esModule ? s : { default: s } }; Object.defineProperty(W, '__esModule', { value: !0 }); W.Device = W.detectDevice = void 0; var Wp = Gp(Dn()); var Qp = A(); var Jp = Ve(); var xt = oe(); var Yp = bo($()); var Ke = bo(te()); var Xp = Us(); var Zp = $a(); var eu = Ga(); var tu = Ya(); var ru = to(); var su = io(); var iu = co(); var nu = ho(); var au = go(); var ou = yo(); var U = new Qp.Logger('Device'); function wo() { if (typeof navigator === 'object' && navigator.product === 'ReactNative') { if (typeof RTCPeerConnection === 'undefined') { U.warn('this._detectDevice() | unsupported ReactNative without RTCPeerConnection'); return } return U.debug('this._detectDevice() | ReactNative handler chosen'), 'ReactNative' } else if (typeof navigator === 'object' && typeof navigator.userAgent === 'string') { const s = navigator.userAgent; const e = Wp.default.getParser(s); const t = e.getEngine(); if (e.satisfies({ chrome: '>=74', chromium: '>=74' })) return 'Chrome74'; if (e.satisfies({ chrome: '>=70', chromium: '>=70' })) return 'Chrome70'; if (e.satisfies({ chrome: '>=67', chromium: '>=67' })) return 'Chrome67'; if (e.satisfies({ chrome: '>=55', chromium: '>=55' })) return 'Chrome55'; if (e.satisfies({ firefox: '>=60' })) return 'Firefox60'; if (e.satisfies({ safari: '>=12.0' }) && typeof RTCRtpTransceiver !== 'undefined' && RTCRtpTransceiver.prototype.hasOwnProperty('currentDirection')) return 'Safari12'; if (e.satisfies({ safari: '>=11' })) return 'Safari11'; if (e.satisfies({ 'microsoft edge': '>=11' }) && e.satisfies({ 'microsoft edge': '<=18' })) return 'Edge11'; if (t.name && t.name.toLowerCase() === 'blink') { const r = s.match(/(?:(?:Chrome|Chromium))[ /](\w+)/i); if (r) { const i = Number(r[1]); return i >= 74 ? 'Chrome74' : i >= 70 ? 'Chrome70' : i >= 67 ? 'Chrome67' : 'Chrome55' } else return 'Chrome74' } else { U.warn('this._detectDevice() | browser not supported [name:%s, version:%s]', e.getBrowserName(), e.getBrowserVersion()); return } } else { U.warn('this._detectDevice() | unknown device'); return } }W.detectDevice = wo; var So = class {constructor({ handlerName: e, handlerFactory: t, Handler: r } = {}) { if (this._loaded = !1, this._observer = new Jp.EnhancedEventEmitter(), U.debug('constructor()'), r) if (U.warn('constructor() | Handler option is DEPRECATED, use handlerName or handlerFactory instead'), typeof r === 'string')e = r; else throw new TypeError('non string Handler option no longer supported, use handlerFactory instead'); if (e && t) throw new TypeError('just one of handlerName or handlerInterface can be given'); if (t) this._handlerFactory = t; else { if (e)U.debug('constructor() | handler given: %s', e); else if (e = wo(), e)U.debug('constructor() | detected handler: %s', e); else throw new xt.UnsupportedError('device not supported'); switch (e) { case 'Chrome74':this._handlerFactory = Zp.Chrome74.createFactory(); break; case 'Chrome70':this._handlerFactory = eu.Chrome70.createFactory(); break; case 'Chrome67':this._handlerFactory = tu.Chrome67.createFactory(); break; case 'Chrome55':this._handlerFactory = ru.Chrome55.createFactory(); break; case 'Firefox60':this._handlerFactory = su.Firefox60.createFactory(); break; case 'Safari12':this._handlerFactory = iu.Safari12.createFactory(); break; case 'Safari11':this._handlerFactory = nu.Safari11.createFactory(); break; case 'Edge11':this._handlerFactory = au.Edge11.createFactory(); break; case 'ReactNative':this._handlerFactory = ou.ReactNative.createFactory(); break; default:throw new TypeError(`unknown handlerName "${e}"`) } } const i = this._handlerFactory(); this._handlerName = i.name, i.close(), this._extendedRtpCapabilities = void 0, this._recvRtpCapabilities = void 0, this._canProduceByKind = { audio: !1, video: !1 }, this._sctpCapabilities = void 0 } get handlerName() { return this._handlerName } get loaded() { return this._loaded } get rtpCapabilities() { if (!this._loaded) throw new xt.InvalidStateError('not loaded'); return this._recvRtpCapabilities } get sctpCapabilities() { if (!this._loaded) throw new xt.InvalidStateError('not loaded'); return this._sctpCapabilities } get observer() { return this._observer } async load({ routerRtpCapabilities: e }) { U.debug('load() [routerRtpCapabilities:%o]', e), e = Yp.clone(e, void 0); let t; try { if (this._loaded) throw new xt.InvalidStateError('already loaded'); Ke.validateRtpCapabilities(e), t = this._handlerFactory(); const r = await t.getNativeRtpCapabilities(); U.debug('load() | got native RTP capabilities:%o', r), Ke.validateRtpCapabilities(r), this._extendedRtpCapabilities = Ke.getExtendedRtpCapabilities(r, e), U.debug('load() | got extended RTP capabilities:%o', this._extendedRtpCapabilities), this._canProduceByKind.audio = Ke.canSend('audio', this._extendedRtpCapabilities), this._canProduceByKind.video = Ke.canSend('video', this._extendedRtpCapabilities), this._recvRtpCapabilities = Ke.getRecvRtpCapabilities(this._extendedRtpCapabilities), Ke.validateRtpCapabilities(this._recvRtpCapabilities), U.debug('load() | got receiving RTP capabilities:%o', this._recvRtpCapabilities), this._sctpCapabilities = await t.getNativeSctpCapabilities(), U.debug('load() | got native SCTP capabilities:%o', this._sctpCapabilities), Ke.validateSctpCapabilities(this._sctpCapabilities), U.debug('load() succeeded'), this._loaded = !0, t.close() } catch (r) { throw t && t.close(), r } }canProduce(e) { if (this._loaded) { if (e !== 'audio' && e !== 'video') throw new TypeError(`invalid kind "${e}"`) } else throw new xt.InvalidStateError('not loaded'); return this._canProduceByKind[e] }createSendTransport({ id: e, iceParameters: t, iceCandidates: r, dtlsParameters: i, sctpParameters: n, iceServers: c, iceTransportPolicy: a, additionalSettings: o, proprietaryConstraints: d, appData: l = {}}) { return U.debug('createSendTransport()'), this._createTransport({ direction: 'send', id: e, iceParameters: t, iceCandidates: r, dtlsParameters: i, sctpParameters: n, iceServers: c, iceTransportPolicy: a, additionalSettings: o, proprietaryConstraints: d, appData: l }) }createRecvTransport({ id: e, iceParameters: t, iceCandidates: r, dtlsParameters: i, sctpParameters: n, iceServers: c, iceTransportPolicy: a, additionalSettings: o, proprietaryConstraints: d, appData: l = {}}) { return U.debug('createRecvTransport()'), this._createTransport({ direction: 'recv', id: e, iceParameters: t, iceCandidates: r, dtlsParameters: i, sctpParameters: n, iceServers: c, iceTransportPolicy: a, additionalSettings: o, proprietaryConstraints: d, appData: l }) }_createTransport({ direction: e, id: t, iceParameters: r, iceCandidates: i, dtlsParameters: n, sctpParameters: c, iceServers: a, iceTransportPolicy: o, additionalSettings: d, proprietaryConstraints: l, appData: p = {}}) { if (this._loaded) { if (typeof t !== 'string') throw new TypeError('missing id'); if (typeof r !== 'object') throw new TypeError('missing iceParameters'); if (Array.isArray(i)) { if (typeof n !== 'object') throw new TypeError('missing dtlsParameters'); if (c && typeof c !== 'object') throw new TypeError('wrong sctpParameters'); if (p && typeof p !== 'object') throw new TypeError('if given, appData must be an object') } else throw new TypeError('missing iceCandidates') } else throw new xt.InvalidStateError('not loaded'); const u = new Xp.Transport({ direction: e, id: t, iceParameters: r, iceCandidates: i, dtlsParameters: n, sctpParameters: c, iceServers: a, iceTransportPolicy: o, additionalSettings: d, proprietaryConstraints: l, appData: p, handlerFactory: this._handlerFactory, extendedRtpCapabilities: this._extendedRtpCapabilities, canProduceByKind: this._canProduceByKind }); return this._observer.safeEmit('newtransport', u), u }}; W.Device = So }); var Co = m(Ro => { 'use strict'; Object.defineProperty(Ro, '__esModule', { value: !0 }) }); var Po = m(To => { 'use strict'; Object.defineProperty(To, '__esModule', { value: !0 }) }); var Eo = m(z => { 'use strict'; var cu = z && z.__createBinding || (Object.create ? function(s, e, t, r) { r === void 0 && (r = t), Object.defineProperty(s, r, { enumerable: !0, get: function() { return e[t] } }) } : function(s, e, t, r) { r === void 0 && (r = t), s[r] = e[t] }); var ke = z && z.__exportStar || function(s, e) { for (var t in s)t !== 'default' && !e.hasOwnProperty(t) && cu(e, s, t) }; Object.defineProperty(z, '__esModule', { value: !0 }); ke(Zs(), z); ke(Us(), z); ke(js(), z); ke(Bs(), z); ke(qs(), z); ke(Fs(), z); ke(Co(), z); ke(Po(), z); ke(de(), z); ke(oe(), z) }); var Mo = m(q => { 'use strict'; var du = q && q.__createBinding || (Object.create ? function(s, e, t, r) { r === void 0 && (r = t), Object.defineProperty(s, r, { enumerable: !0, get: function() { return e[t] } }) } : function(s, e, t, r) { r === void 0 && (r = t), s[r] = e[t] }); var lu = q && q.__setModuleDefault || (Object.create ? function(s, e) { Object.defineProperty(s, 'default', { enumerable: !0, value: e }) } : function(s, e) { s.default = e }); var pu = q && q.__importStar || function(s) { if (s && s.__esModule) return s; var e = {}; if (s != null) for (var t in s)t !== 'default' && Object.hasOwnProperty.call(s, t) && du(e, s, t); return lu(e, s), e }; Object.defineProperty(q, '__esModule', { value: !0 }); q.detectDevice = q.Device = q.version = q.types = void 0; var Do = Zs(); Object.defineProperty(q, 'Device', { enumerable: !0, get: function() { return Do.Device } }); Object.defineProperty(q, 'detectDevice', { enumerable: !0, get: function() { return Do.detectDevice } }); var uu = pu(Eo()); q.types = uu; q.version = '3.6.30'; var hu = Lr(); Object.defineProperty(q, 'parseScalabilityMode', { enumerable: !0, get: function() { return hu.parse } }) }); var xo = m((lf, ko) => { var fu = Ps(); var mu = Mo(); ko.exports = class extends fu {constructor(e) { super(e); this.log('sfu client'), this.consumers = new Map(), this.producers = new Map(), this.producerTransport = null, this.consumerTransport = null, this.device = null, this.producerLabel = new Map() } async onJoinRoom(e) { this.log('sfu', 'onJoinRoom', e); const t = await this.socket.request('getRouterRtpCapabilities'); const r = await this.loadDevice(t); this.device = r, await this.initTransports(r), this.socket.emit('getProducers'), this.roomInfo = e } async onInitSockets(e) { this.log('sfu', 'onInitSockets'), this.socket = e, this.initSockets() } async onProduce(e) { if (this.isProducer) return this.log('sfu', 'onProduce', e), this.produce(e) } async onCloseProducer(e) { const t = e.type; if (this.log('sfu', 'onCloseProducer', t), !this.producerLabel.has(t)) { this.log('there is no producer for this type ' + t); return } const r = this.producerLabel.get(t); this.log(r), this.socket.emit('producerClosed', { producer_id: r }), this.producers.get(r).close(), this.producers.delete(r), this.producerLabel.delete(t) } async onClean(e = !1) { this.log('sfu', 'onJoinRoom'), this.consumerTransport.close(), this.producerTransport.close(), this.socket.off('newProducers'), this.socket.off('consumerClosed') } async loadDevice(e) { let t; try { t = new mu.Device() } catch (r) { r.name === 'UnsupportedError' && this.error('browser not supported'), this.error(r) } return await t.load({ routerRtpCapabilities: e }), t } async initTransports(e) { { const t = await this.socket.request('createWebRtcTransport', { forceTcp: !1, rtpCapabilities: e.rtpCapabilities }); if (t.error) { this.error(t.error); return } this.producerTransport = e.createSendTransport(t), this.producerTransport.on('connect', async function({ dtlsParameters: r }, i, n) { this.socket.request('connectTransport', { dtlsParameters: r, transport_id: t.id }).then(i).catch(n) }.bind(this)), this.producerTransport.on('produce', async function({ kind: r, rtpParameters: i, appData: n }, c, a) { try { const { producer_id: o } = await this.socket.request('produce', { producerTransportId: this.producerTransport.id, kind: r, rtpParameters: i, appData: n }); c({ id: o }) } catch (o) { a(o) } }.bind(this)), this.producerTransport.on('connectionstatechange', function(r) { switch (r) { case 'connecting':break; case 'connected':break; case 'failed':this.producerTransport.close(); break; default:break } }.bind(this)) } { const t = await this.socket.request('createWebRtcTransport', { forceTcp: !1 }); if (t.error) { this.error(t.error); return } this.consumerTransport = e.createRecvTransport(t), this.consumerTransport.on('connect', function({ dtlsParameters: r }, i, n) { this.socket.request('connectTransport', { transport_id: this.consumerTransport.id, dtlsParameters: r }).then(i).catch(n) }.bind(this)), this.consumerTransport.on('connectionstatechange', async function(r) { switch (r) { case 'connecting':break; case 'connected':break; case 'failed':this.consumerTransport.close(); break; default:break } }.bind(this)) } }initSockets() { this.socket.on('consumerClosed', function({ consumer_id: e }) { this.log('closing consumer:', e), this.removeConsumer(e) }.bind(this)), this.socket.on('newProducers', async function(e) { this.log('new producers', e); for (const { producer_id: t, producer_socket_id: r, peerName: i, kind: n, appData: c } of e) { const a = this.room.canConsumePeer(r, n, c.mediaType); this.log('canConsumePeer', a), a && await this.consume(t, r, i, c) } }.bind(this)) } async produce(e) { const t = e.audio; const r = e.screen; const i = e.type; if (this.producerLabel.has(i)) { this.log('sfu', 'there is already a producer for this type ' + i); const { producer_id: c } = await this.socket.request('reproduce', { producerId: this.producerLabel.get(i), kind: i, appData: { mediaType: i }}); return } if (!this.device.canProduce('video') && !t) { this.error('cannot produce video'); return } const n = e.stream; try { const a = { track: t ? n.getAudioTracks()[0] : n.getVideoTracks()[0], appData: {}}; !t && !r && (a.encodings = [{ rid: 'r0', maxBitrate: 1e5, scalabilityMode: 'S1T3' }, { rid: 'r1', maxBitrate: 3e5, scalabilityMode: 'S1T3' }, { rid: 'r2', maxBitrate: 9e5, scalabilityMode: 'S1T3' }], a.codecOptions = { videoGoogleStartBitrate: 1e3 }), a.appData.mediaType = i; const o = await this.producerTransport.produce(a); this.log('producer', o), this.producers.set(o.id, o); const d = e.elem; t || (d.id = o.id), o.on('trackended', () => { this.room.closeProducer(i) }), o.on('transportclose', () => { this.log('producer transport close'), t || this.room.removeUserMedia(d), this.producers.delete(o.id) }), o.on('close', () => { this.log('closing producer'), t || this.room.removeUserMedia(d), this.producers.delete(o.id) }), this.producerLabel.set(i, o.id) } catch (c) { this.log(c) } } async consume(e, t, r, i) { this.getConsumeStream(e).then(function({ consumer: n, stream: c, kind: a }) { this.consumers.set(n.id, n), this.room.consume(a, n.id, t, r, c, i.mediaType), n.on('trackended', function() { this.removeConsumer(n.id) }.bind(this)), n.on('transportclose', function() { this.removeConsumer(n.id) }.bind(this)) }.bind(this)) }removeConsumer(e) { this.consumers.delete(e), this.room.closeConsumer(e) } async getConsumeStream(e) { const { rtpCapabilities: t } = this.device; const r = await this.socket.request('consume', { rtpCapabilities: t, consumerTransportId: this.consumerTransport.id, producerId: e }); const { id: i, kind: n, rtpParameters: c } = r; const a = {}; const o = await this.consumerTransport.consume({ id: i, producerId: e, kind: n, rtpParameters: c, codecOptions: a }); const d = new MediaStream(); return d.addTrack(o.track), { consumer: o, stream: d, kind: n } }} }); var Lo = m((uf, Oo) => { var gu = En(); var _u = xo(); var xe = { audio: 'audioType', video: 'videoType', screen: 'screenType' }; var tt = { sfufirst: 'sfufirst', sfu: 'sfu', p2pfirst: 'p2pfirst', p2p: 'p2p' }; var F = { exitRoom: 'exitRoom', openRoom: 'openRoom', startVideo: 'startVideo', stopVideo: 'stopVideo', startAudio: 'startAudio', stopAudio: 'stopAudio', startScreen: 'startScreen', stopScreen: 'stopScreen', localMediaAdd: 'localMediaAdd', localMediaRemove: 'localMediaRemove', remoteMediaAdd: 'remoteMediaAdd', remoteMediaRemove: 'remoteMediaRemove', userMsg: 'userMsg', addPeer: 'addPeer', removePeer: 'removePeer' }; Oo.exports = class {constructor(e, t, r, i, n, c) { this.config = e, this.name = n, this.localMediaEl = e.localMedia, this.remoteMediaEl = e.remoteMedias, this.connectType = t, this.socket = r, this.room_id = i, this.debug = !!e.debug, this._muted = !1, this._isOpen = !1, this._producerLabel = new Map(), this._consumers = new Map(), this._initClients(t), this._eventListeners = new Map(), Object.keys(F).forEach(function(a) { this._eventListeners.set(a, []) }.bind(this)), this.createRoom(i).then(async function() { const a = await this.join(n, i); this._initSockets(), this._isOpen = !0, this._initUserCards(a), c(a) }.bind(this)) }log(...e) { this.debug && console.log(...e) }error(...e) { console.error(...e) } async createRoom(e) { await this.socket.request('createRoom', { room_id: e }).catch(t => { this.error(t) }) } async join(e, t) { return this.socket.request('join', { name: e, room_id: t }).then(async function(r) { return this._onClientEvent('onJoinRoom', r), r }.bind(this)).catch(r => { this.error(r) }) }_initClients(e) { switch (e !== tt.sfu && (this._p2p = new gu(this)), e !== tt.p2p && (this._sfu = new _u(this)), e) { case tt.p2p:this._clients = [this._p2p]; break; case tt.p2pfirst:this._sfu.isProducer = !1, this._clients = [this._p2p, this._sfu]; break; case tt.sfu:this._clients = [this._sfu]; break; case tt.sfufirst:default:this._p2p.isProducer = !1, this._clients = [this._sfu, this._p2p]; break } }_onClientEvent(e, ...t) { this._clients.forEach(async r => { typeof r[e] === 'function' && await r[e](...t) }) }_initSockets() { this.socket.on('disconnect', function() { this.exit(!0) }.bind(this)), this.socket.on('userMsg', function(e) { this.event(F.userMsg, e) }.bind(this)), this.socket.on('command', function(e) { this._onClientEvent('onCommand', e) }.bind(this)), this.socket.on('addPeer', function(e) { this.addUserCard(e), this._onClientEvent('onAddPeer', e), this.event(F.addPeer, e) }.bind(this)), this.socket.on('removePeer', function(e) { this.removeUserCard(e), this._onClientEvent('onRemovePeer', e), this.event(F.removePeer, e) }.bind(this)), this._onClientEvent('onInitSockets', this.socket) }_initUserCards(e) { const t = e.roomInfo; const r = e.myInfo; t.peers.forEach(i => { i.id !== r.id && this.addUserCard(i) }) } async produce(e, t = null) { let r = {}; let i = !1; let n = !1; const c = !(t === null || typeof t === 'string'); let a = this.config.audio; let o = this.config.video; if (a ? t && (a.deviceId = t) : a = { deviceId: t }, o ? t && (o.deviceId = t) : o = { width: { min: 640, ideal: 1920 }, height: { min: 400, ideal: 1080 }, deviceId: t }, !c) switch (e) { case xe.audio:r = { audio: a, video: !1 }, i = !0; break; case xe.video:r = { audio: !1, video: o }; break; case xe.screen:r = !1, n = !0; break; default:console.warn('unsupport media type:', e); return } if (this._producerLabel.has(e)) { this.log('producer already exists for this type ' + e); return } this.log('mediacontraints:', r); let d; c ? (d = t, this.log('use custom stream')) : (d = n ? await navigator.mediaDevices.getDisplayMedia() : await navigator.mediaDevices.getUserMedia(r), this.log('require media device, navigator supported media constraints:', navigator.mediaDevices.getSupportedConstraints())); let l; i || (l = document.createElement('video'), l.srcObject = d, l.playsinline = !1, l.autoplay = !0, l.className = n ? 'screenVid' : 'vid', l.setAttribute('playsinline', !0)); const p = { type: e, mediaConstraints: r, audio: i, screen: n, stream: d, elem: l }; switch (this._producerLabel.set(e, p), this._onClientEvent('onProduce', p), i || (this.localMediaEl && this.localMediaEl.appendChild(l), this.event(F.localMediaAdd, l)), e) { case xe.audio:this.event(F.startAudio); break; case xe.video:this.event(F.startVideo); break; case xe.screen:this.event(F.startScreen); break; default:return } }closeProducer(e) { if (!this._producerLabel.has(e)) { this.log('there is no producer for this type ' + e); return } const t = this._producerLabel.get(e); switch (this._onClientEvent('onCloseProducer', t), this.removeUserMedia(t.elem), this._producerLabel.delete(e), e) { case xe.audio:this.event(F.stopAudio); break; case xe.video:this.event(F.stopVideo); break; case xe.screen:this.event(F.stopScreen); break; default:return } }consume(e, t, r, i, n, c) { if (e !== 'video' && e !== 'audio') return null; const a = { type: e, elemId: t, peerId: r, peerName: i, mediaType: c }; this._consumers.has(r) ? this._consumers.get(r).push(a) : this._consumers.set(r, [a]); const o = document.createElement(e); return o.srcObject = n, o.id = t, o.playsinline = !1, o.autoplay = !0, o.className = c.substr(0, 3), o.peerId = r, o.peerName = i, o.mediaType = c, o.type = e, o.setAttribute('playsinline', !0), this.remoteMediaEl && this.addUserMedia(o), this.event(F.remoteMediaAdd, o), o }closeConsumer(e) { const t = document.getElementById(e); if (t) { if (this._consumers.has(t.peerId)) { const r = this._consumers.get(t.peerId).filter(i => i.elemId != e); r.length > 0 ? this._consumers.set(t.peerId, r) : this._consumers.delete(t.peerId) } this.removeUserMedia(t), this.event(F.remoteMediaRemove, t) } }exit(e = !1) { const t = function() { this._isOpen = !1, this._consumers.clear(), this._onClientEvent('onClean', e), this.socket.off('disconnect'), this.socket.off('addPeer'), this.socket.off('removePeer'), this.socket.off('userMsg'), this.socket.off('command') }.bind(this); e ? t() : this.socket.request('exitRoom').then(r => this.log(r)).catch(r => console.warn(r)).finally(function() { t() }), this.event(F.exitRoom) }addUserCard(e) { const t = 'um_' + e.id; if (this.remoteMediaEl) { if (this.remoteMediaEl.querySelector('#' + t)) return this.remoteMediaEl.querySelector('#' + t); { const r = document.createElement('div'); r.id = t, r.peerId = e.id, r.className = 'userCard'; const i = document.createElement('div'); return i.className = 'userInfo', r.appendChild(i), this.remoteMediaEl.appendChild(r), r } } return null }removeUserCard(e) { const t = 'um_' + e.id; if (this.remoteMediaEl) { const r = this.remoteMediaEl.querySelector('#' + t); if (r) { let i = r.querySelectorAll('audio'); i && i.forEach(n => { n.srcObject.getTracks().forEach(function(c) { c.stop() }), this.event(F.remoteMediaRemove, n) }), i = r.querySelectorAll('video'), i && i.forEach(n => { n.srcObject.getTracks().forEach(function(c) { c.stop() }), this.event(F.remoteMediaRemove, n) }), r.parentNode.removeChild(r) } } }addUserMedia(e) { const t = this.addUserCard({ id: e.peerId, name: e.peerName }); return t && t.appendChild(e), t }removeUserMedia(e) { e && (e.srcObject.getTracks().forEach(function(t) { t.stop() }), e.parentNode.removeChild(e)) } async roomInfo() { return await this.socket.request('getMyRoomInfo') } async sendMsg(e) { return await this.socket.request('sendMessage', e) }event(e, t) { this._eventListeners.has(e) && this._eventListeners.get(e).forEach(r => r(t)) }on(e, t) { this._eventListeners.get(e).push(t) }setSpeakerMuted(e) { this.remoteMediaEl && this.remoteMediaEl.querySelectorAll('audio').forEach(t => { t.muted = e }), this.muted = e }isSpeakerMuted() { return this.muted } async tryNext(e, t, r) { this.log('tryNext', t), e === this._p2p && this._sfu && r && (await this._p2p.hungup(t.id, t.type), this._sfu.produce(r)) }canConsumePeer(e, t, r) { return this.log('canConsumePeer', e, t, r), this._consumers.has(e) ? this._consumers.get(e).filter(n => n.mediaType === r).length < 1 : !0 }isOpen() { return this._isOpen }static get EVENTS() { return F }static get mediaType() { return xe }static get connectType() { return tt }} }); var Ao = m((hf, Io) => { Io.exports = { debug: !1, listenPort: 4e4 } }); var Bo = m((ff, jo) => { async function vu(s) { const e = s; let t; return e && e.screen ? t = navigator.mediaDevices.getDisplayMedia(e.screen) : t = navigator.mediaDevices.getUserMedia(e).catch(function(r) { if (r.name !== 'NotFoundError') throw r; return navigator.mediaDevices.enumerateDevices().then(function(i) { var n = i.find(function(o) { return o.kind === 'videoinput' }); var c = i.find(function(o) { return o.kind === 'audioinput' }); var a = { video: n && e.video, audio: c && e.audio }; return navigator.mediaDevices.getUserMedia(a) }) }).then(function(r) { return r }).catch(function(r) { return _err('\u65E0\u6CD5\u6253\u5F00\u672C\u5730\u89C6\u9891\u6216\u97F3\u9891\u8BBE\u5907: ', r.message, r.name), typeof m_event.error === 'function' ? m_event.error({ msg: '\u65E0\u6CD5\u6253\u5F00\u672C\u5730\u89C6\u9891\u6216\u97F3\u9891\u8BBE\u5907: ', e: r }) : alert('\u65E0\u6CD5\u6253\u5F00\u672C\u5730\u89C6\u9891\u6216\u97F3\u9891\u8BBE\u5907: ' + r.message), !1 }), t } async function yu(s) { const e = await navigator.mediaDevices.enumerateDevices(); return s ? e.filter(t => t.kind === s) : e }jo.exports = { getDevice: vu, getDeviceList: yu } }); var Fo = m((mf, qo) => { var bu = bn(); var wu = Sn().promise; var ei = Lo(); var Ge = Ao(); var Su = Bo(); var Ru = '2.6.1'; var x = null; function ti(...s) { Ge.debug && console.log(...s) } async function Cu() { const s = Ge.signalServer || window.location.hostname; const e = { withCredentials: !0, path: '/server', transports: ['websocket'] }; ti('connecting...'); const t = `https://${s}:${Ge.listenPort}`; const r = bu(t, e); return r.request = wu(r), r } function Tu(s) { Ge = Object.assign(Ge, s), ti('config:', Ge) } async function Pu(s, e, t, r) { if (x && x.isOpen())ti('already connected to a room'), r({ result: !1, error: 'already connected to a room' }); else { const i = await Cu(); x = new ei(Ge, t, i, s, e, n => r({ result: !0, ...n })) } } async function Eu() { x && (x.exit(), x = null) } function Du() { return x && x.isOpen() } async function Mu() { return x ? await x.roomInfo() : {} } async function ku(s, e) { if (x)x.on(s, e); else return !1 } async function xu(s, e, t) { if (x)e ? x.produce(s, t) : x.closeProducer(s); else return !1 } async function Ou(s) { return x ? await x.sendMsg(s) : !1 } function Lu(s) { x && x.setSpeakerMuted(s) } function Iu() { return x ? x.isSpeakerMuted() : null } function Au() { return x }qo.exports = { version: Ru, config: Ge, device: Su, EVENTS: ei.EVENTS, mediaType: ei.mediaType, setup: Tu, joinRoom: Pu, exitRoom: Eu, isJoinRoom: Du, roomInfo: Mu, on: ku, setMediaEnable: xu, sendMsg: Ou, isSpeakerMuted: Iu, setSpeakerMuted: Lu, __debug: { getRC: Au }} }); var ju = m((gf, ri) => { var No = Fo(); typeof moodule !== 'undefined' && typeof ri.exports !== 'undefined' && (ri.exports = No); window && (window.UmVideo2 = No) }); ju()
})()
// # sourceMappingURL=client.min.js.map
